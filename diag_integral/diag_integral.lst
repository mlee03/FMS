Page 1           Source Listing                  DIAG_INTEGRAL_INIT
2021-06-01 08:55                                 /tmp/ifortiU9mzL.i90

      1 # 1 "diag_integral.F90"
      2 !***********************************************************************
      3 !*                   GNU Lesser General Public License
      4 !*
      5 !* This file is part of the GFDL Flexible Modeling System (FMS).
      6 !*
      7 !* FMS is free software: you can redistribute it and/or modify it under
      8 !* the terms of the GNU Lesser General Public License as published by
      9 !* the Free Software Foundation, either version 3 of the License, or (at
     10 !* your option) any later version.
     11 !*
     12 !* FMS is distributed in the hope that it will be useful, but WITHOUT
     13 !* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
     14 !* FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
     15 !* for more details.
     16 !*
     17 !* You should have received a copy of the GNU Lesser General Public
     18 !* License along with FMS.  If not, see <http://www.gnu.org/licenses/>.
     19 !***********************************************************************
     20 
     21 !> @file
     22 !! @brief This module computes and outputs global and / or hemispheric physics
     23 !!        integrals.
     24 !! @author Fei Liu
     25 !! @email gfdl.climate.model.info@noaa.gov
     26                      module diag_integral_mod
     27 
     28 
     29 
     30 !###############################################################################
     31 !> \defgroup diag_integral_mod diag_integral_mod
     32 !!
     33 !! \author Fei Liu <Fei.Liu@noaa.gov>
     34 !!
     35 !! \brief This module computes and outputs global and / or hemispheric physics
     36 !!        integrals.
     37 !!
     38 !! <b> Modules Included: </b>
     39 !!
     40 !! <table>
     41 !!   <tr>
     42 !!     <th> Module Name </th>
     43 !!     <th> Included Values </th>
     44 !!   </tr>
     45 !!   <tr>
     46 !!     <td> time_manager_mod </td>
     47 !!     <td> time_type, get_time, set_time, time_manager_init, operator(+),
     48 !!          operator(-), operator(==), operator(>=), operator(/=) </td>
     49 !!   </tr>
     50 !!   <tr>
     51 !!     <td> mpp_mod </td>
     52 !!     <td> input_nml_file <\td>
     53 !!   </tr>
     54 !!   <tr>
     55 !!     <td> fms_mod </td>
     56 !!     <td> open_file, file_exist, error_mesg, open_namelist_file,
     57 !!          check_nml_error, fms_init, mpp_pe, mpp_root_pe, FATAL,

Page 2           Source Listing                  DIAG_INTEGRAL_INIT
2021-06-01 08:55                                 diag_integral.F90

     58 !!          write_version_number, stdlog </td>
     59 !!   </tr>
     60 !!   <tr>
     61 !!     <td> constants_mod </td>
     62 !!     <td> radius, constants_init </td>
     63 !!   </tr>
     64 !!   <tr>
     65 !!     <td> mpp_mod </td>
     66 !!     <td> mpp_sum, mpp_init </td>
     67 !!   </tr>
     68 !! </table>
     69 !!
     70 !! <b> Public Interfaces: </b>
     71 !!
     72 !! - sum_diag_integral_field
     73 !!
     74 !! <b> Public Subroutines: </b>
     75 !!
     76 !! - diag_integral_init
     77 !! - diag_integral_field_init
     78 !! - diag_integral_output
     79 !! - diag_integral_end
     80 !! - sum_field_2d
     81 !! - sum_field_3d
     82 !! - sum_field_wght_3d
     83 !! - sum_field_2d_hemi
     84 !!
     85 !! <b> Private Functions: </b>
     86 !!
     87 !! - set_axis_time
     88 !! - get_field_index
     89 !! - get_axis_time
     90 !! - diag_integral_alarm
     91 !! - vert_diag_integral
     92 !!
     93 !! <b> Private Subroutines: </b>
     94 !!
     95 !! - write_field_averages
     96 !! - format_text_init
     97 !! - format_data_init
     98 !!
     99 
    100 use platform_mod,     only:  i8_kind
    101 use time_manager_mod, only:  time_type, get_time, set_time,  &
    102                              time_manager_init, &
    103                              operator(+),  operator(-),      &
    104                              operator(==), operator(>=),     &
    105                              operator(/=)
    106 use mpp_mod,          only:  input_nml_file, get_unit
    107 use fms_mod,          only:  open_file, error_mesg, &
    108                              check_nml_error, &
    109                              fms_init, &
    110                              mpp_pe, mpp_root_pe,&
    111                              FATAL, write_version_number, &
    112                              stdlog
    113 use fms2_io_mod,      only:  file_exists
    114 use constants_mod,    only:  radius, constants_init

Page 3           Source Listing                  DIAG_INTEGRAL_INIT
2021-06-01 08:55                                 diag_integral.F90

    115 use mpp_mod,          only:  mpp_sum, mpp_init
    116 use ensemble_manager_mod, only : get_ensemble_id, get_ensemble_size
    117 
    118 !-------------------------------------------------------------------------------
    119 
    120 implicit none
    121 private
    122 
    123 !-------------------------------------------------------------------------------
    124 ! version number of this module
    125 ! Include variable "version" to be written to log file.
    126 # 1 "../include/file_version.h" 1 
    127 ! -*-f90-*-
    128 !***********************************************************************
    129 !*                   GNU Lesser General Public License
    130 !*
    131 !* This file is part of the GFDL Flexible Modeling System (FMS).
    132 !*
    133 !* FMS is free software: you can redistribute it and/or modify it under
    134 !* the terms of the GNU Lesser General Public License as published by
    135 !* the Free Software Foundation, either version 3 of the License, or (at
    136 !* your option) any later version.
    137 !*
    138 !* FMS is distributed in the hope that it will be useful, but WITHOUT
    139 !* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
    140 !* FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
    141 !* for more details.
    142 !*
    143 !* You should have received a copy of the GNU Lesser General Public
    144 !* License along with FMS.  If not, see <http://www.gnu.org/licenses/>.
    145 !***********************************************************************
    146 
    147 # 23
    148 
    149   character(len=*), parameter :: version = 'unknown'
    150 
    151 # 126 "diag_integral.F90" 2 
    152 
    153 !-------------------------------------------------------------------------------
    154 !------ interfaces ------
    155 
    156 public      &
    157           diag_integral_init, diag_integral_field_init, &
    158           sum_diag_integral_field, diag_integral_output,  &
    159           diag_integral_end
    160 
    161 
    162 
    163 !###############################################################################
    164 !> \defgroup sum_diag_integral_field sum_diag_integral_field
    165 !! \ingroup diag_integral_mod
    166 !!
    167 !! This interface can be called in any one of three ways:
    168 !!
    169 !! \code{.f90}
    170 !! call sum_diag_integral_field (name, data, is, js)
    171 !! call sum_diag_integral_field (name, data, wt, is, js)

Page 4           Source Listing                  DIAG_INTEGRAL_INIT
2021-06-01 08:55                                 diag_integral.F90

    172 !! call sum_diag_integral_field (name, data, is, ie, js, je)
    173 !! \endcode
    174 !!
    175 !! in the first option above, `data` may be either
    176 !! \code{.f90}
    177 !! real, intent(in) :: data(:,:)   ![ sum_field_2d ]
    178 !! real, intent(in) :: data(:,:,:) ![ sum_field_3d ]
    179 !! \endcode
    180 !!
    181 !! <b> Parameters: </b>
    182 !!
    183 !! \code{.f90}
    184 !! character(len=*),  intent(in) :: name
    185 !! real,              intent(in) :: wt(:,:,:)
    186 !! integer, optional, intent(in) :: is, ie, js, je
    187 !! \endcode
    188 !!
    189 !! \param [in] <name> name associated with integral
    190 !! \param [in] <data> field of integrands to be summed over
    191 !! \param [in] <wt> vertical weighting factor to be applied to integrands
    192 !!        when summing
    193 !! \param [in] <is, ie, js, je> starting/ending i,j indices over which summation
    194 !!        is to occur
    195 !!
    196 interface sum_diag_integral_field
    197    module procedure sum_field_2d,   &
    198                     sum_field_2d_hemi, &
    199                     sum_field_3d,   &
    200                     sum_field_wght_3d
    201 end interface
    202 
    203 
    204 
    205 private         &
    206 
    207 !   from diag_integral_init:
    208           set_axis_time,  &
    209 
    210 !   from diag_integral_field_init and sum_diag_integral_field:
    211           get_field_index, &
    212 
    213 !   from diag_integral_output and diag_integral_end:
    214           write_field_averages,  &
    215 
    216 !   from write_field_averages:
    217           format_text_init, format_data_init, &
    218           get_axis_time,     &
    219 
    220 !   from diag_integral_output:
    221           diag_integral_alarm, &
    222 
    223 !   from sum_diag_integral_field:
    224           vert_diag_integral
    225 
    226 !-------------------------------------------------------------------------------
    227 !------ namelist -------
    228 

Page 5           Source Listing                  DIAG_INTEGRAL_INIT
2021-06-01 08:55                                 diag_integral.F90

    229 integer, parameter  ::    &
    230                       mxch = 64    !< maximum number of characters in
    231 !! the optional output file name
    232 real                ::    &
    233          output_interval = -1.0    !< time interval at which integrals
    234 !! are to be output
    235 character(len=8)    ::    &
    236             time_units = 'hours'   !< time units associated with
    237 !! output_interval
    238 character(len=mxch) ::    &
    239                  file_name = ' '   !< optional integrals output file name
    240 logical             ::    &
    241            print_header = .true.   !< print a header for the integrals
    242 !! file ?
    243 integer             ::    &
    244        fields_per_print_line = 4   !< number of fields to write per line
    245 !! of output
    246 
    247 namelist / diag_integral_nml /      &
    248                                 output_interval, time_units,  &
    249                                 file_name, print_header, &
    250                                 fields_per_print_line
    251 
    252 !-------------------------------------------------------------------------------
    253 !------- public data ------
    254 
    255 
    256 !-------------------------------------------------------------------------------
    257 !------- private data ------
    258 
    259 !-------------------------------------------------------------------------------
    260 !    variables associated with the determination of when integrals
    261 !    are to be written.
    262 !         Next_alarm_time  next time at which integrals are to be
    263 !                          written
    264 !         Alarm_interval   time interval between writing integrals
    265 !         Zero_time        time_type variable set to (0,0); used as
    266 !                          flag to indicate integrals are not being
    267 !                          output
    268 !         Time_init_save   initial time associated with experiment;
    269 !                          used as a base for defining time
    270 !-------------------------------------------------------------------------------
    271 type (time_type) :: Next_alarm_time !< next time at which integrals are to be written
    272 type (time_type) :: Alarm_interval !< time interval between writing integrals
    273 type (time_type) :: Zero_time !< time_type variable set to (0,0); used as
    274 !! flag to indicate integrals are not being output
    275 type (time_type) :: Time_init_save !< initial time associated with experiment;
    276 !! used as a base for defining time
    277 
    278 !-------------------------------------------------------------------------------
    279 !    variables used in determining weights associated with each
    280 !    contribution to the integrand.
    281 !        area         area of each grid box
    282 !        idim         x dimension of grid on local processor
    283 !        jdim         y dimension of grid on local processor
    284 !        field_size   number of columns on global domain
    285 !        sum_area     surface area of globe

Page 6           Source Listing                  DIAG_INTEGRAL_INIT
2021-06-01 08:55                                 diag_integral.F90

    286 !-------------------------------------------------------------------------------
    287 real, allocatable, dimension(:,:) :: area !< area of each grid box
    288 integer                           :: idim !< x dimension of grid on local processor
    289 integer                           :: jdim !< y dimension of grid on local processor
    290 integer                           :: field_size !< number of columns on global domain
    291 real                              :: sum_area !< surface area of globe
    292 
    293 !-------------------------------------------------------------------------------
    294 !    variables used to define the integral fields:
    295 !      max_len_name     maximum length of name associated with integral
    296 !      max_num_field    maximum number of integrals allowed
    297 !      num_field        number of integrals that have been activated
    298 !      field_name(i)    name associated with integral i
    299 !      field_format(i)  output format for integral i
    300 !      field_sum(i)     integrand for integral i
    301 !      field_count(i)   number of values in integrand i
    302 !-------------------------------------------------------------------------------
    303 integer, parameter          :: max_len_name   = 12 !< maximum length of name associated with integral
    304 integer, parameter          :: max_num_field = 32 !< maximum number of integrals allowed
    305 integer                     :: num_field = 0 !< number of integrals that have been activated
    306 character(len=max_len_name) :: field_name   (max_num_field) !< name associated with integral i
    307 character(len=16)           :: field_format (max_num_field) !< output format for integral i
    308 real                        :: field_sum    (max_num_field) !< integrand for integral i
    309 integer                     :: field_count  (max_num_field) !< number of values in integrand i
    310 
    311 !-------------------------------------------------------------------------------
    312 !    variables defining output formats.
    313 !       format_text       format statement for header
    314 !       format_data       format statement for data output
    315 !       do_format_data    a data format needs to be generated ?
    316 !       nd                number of characters in data format statement
    317 !       nt                number of characters in text format statement
    318 !-------------------------------------------------------------------------------
    319 character(len=160) :: format_text !< format statement for header
    320 character(len=160) :: format_data !< format statement for data output
    321 logical            :: do_format_data = .true. !< a data format needs to be generated ?
    322 integer            :: nd !< number of characters in data format statement
    323 integer            :: nt !< number of characters in text format statement
    324 
    325 !-------------------------------------------------------------------------------
    326 !    miscellaneous variables.
    327 !-------------------------------------------------------------------------------
    328 integer :: diag_unit = 0             !< unit number for output file
    329 logical :: module_is_initialized = .false. !< module is initialized ?
    330 
    331 
    332 
    333                            contains
    334 
    335 
    336 
    337 !###############################################################################
    338 !
    339 !                     PUBLIC SUBROUTINES
    340 !
    341 !###############################################################################
    342 

Page 7           Source Listing                  DIAG_INTEGRAL_INIT
2021-06-01 08:55                                 diag_integral.F90

    343 
    344 
    345 !###############################################################################
    346 !> \fn diag_integral_init
    347 !!
    348 !! \brief diag_integral_init is the constructor for diag_integral_mod.
    349 !!
    350 !! <b> Template: </b>
    351 !!
    352 !! \code{.f90}
    353 !! call diag_integral_init (Time_init, Time, blon, blat)
    354 !! \endcode
    355 !!
    356 !! <b> Parameters: </b>
    357 !!
    358 !! \code{.f90}
    359 !! type (time_type),  intent(in), optional :: Time_init, Time
    360 !! real,dimension(:,:), intent(in), optional :: blon, blat, area_in
    361 !! \endcode
    362 !!
    363 !! \param [in] <Time_init> Initial time to start the integral
    364 !! \param [in] <Time> current time
    365 !! \param [in] <latb> array of model latitudes at cell boundaries [radians]
    366 !! \param [in] <lonb> array of model longitudes at cell boundaries [radians]
    367 !!
    368 subroutine diag_integral_init (Time_init, Time, blon, blat, area_in)
    369 
    370 type (time_type),  intent(in), optional :: Time_init !< Initial time to start the integral
    371 type (time_type),  intent(in), optional :: Time !< current time
    372 real,dimension(:,:), intent(in), optional :: blon !< array of model latitudes at cell boundaries [radians]
    373 real,dimension(:,:), intent(in), optional :: blat !< array of model longitudes at cell boundaries [radians]
    374 real,dimension(:,:), intent(in), optional :: area_in
    375 
    376 !-------------------------------------------------------------------------------
    377 ! local variables:
    378 !       r2
    379 !       rsize
    380 !       unit
    381 !       io
    382 !       ierr
    383 !       seconds
    384 !       nc
    385 !       i,j
    386 !-------------------------------------------------------------------------------
    387       real    :: rsize
    388       integer :: io, ierr, nc, logunit
    389       integer :: field_size_local
    390       real    :: sum_area_local
    391       integer :: ensemble_size(6)
    392 !-------------------------------------------------------------------------------
    393 !    if routine has already been executed, exit.
    394 !-------------------------------------------------------------------------------
    395       if (module_is_initialized) return
    396 
    397 !-------------------------------------------------------------------------------
    398 !    verify that modules used by this module that are not called later
    399 !    have already been initialized.

Page 8           Source Listing                  DIAG_INTEGRAL_INIT
2021-06-01 08:55                                 diag_integral.F90

    400 !-------------------------------------------------------------------------------
    401       call fms_init
    402       call mpp_init
    403       call constants_init
    404       call time_manager_init
    405 
    406 !-------------------------------------------------------------------------------
    407 !    if this is the initialization call, proceed. if this was simply
    408 !    a verification of previous initialization, return.
    409 !-------------------------------------------------------------------------------
    410       if (present(Time_init) .and. present(Time) .and. &
    411           present(blon) .and. present(blat) ) then
    412 
    413 !-------------------------------------------------------------------------------
    414 !    read namelist.
    415 !-------------------------------------------------------------------------------
    416     if ( file_exists('input.nml')) then
    417         read (input_nml_file, nml=diag_integral_nml, iostat=io)
    418         ierr = check_nml_error(io,'diag_integral_nml')
    419     endif
    420 
    421 !-------------------------------------------------------------------------------
    422 !    write version number and namelist to logfile.
    423 !-------------------------------------------------------------------------------
    424       call write_version_number ('DIAG_INTEGRAL_MOD', version)
    425       logunit = stdlog()
    426       if (mpp_pe() == mpp_root_pe() ) &
    427                        write (logunit, nml=diag_integral_nml)
    428 
    429 !-------------------------------------------------------------------------------
    430 !    save the initial time to time-stamp the integrals which will be
    431 !    calculated.
    432 !-------------------------------------------------------------------------------
    433       Time_init_save = Time_init
    434 
    435 !-------------------------------------------------------------------------------
    436 !    define the model grid sizes and the total number of columns on
    437 !    the processor. sum over all processors and store the global
    438 !    number of columns in field_size.
    439 !-------------------------------------------------------------------------------
    440       idim = size(blon,1) - 1
    441       jdim = size(blon,2) - 1
    442       field_size_local = idim*jdim
    443       rsize = real(field_size_local)
    444       call mpp_sum (rsize)
    445       field_size = nint(rsize)
    446 
    447 !-------------------------------------------------------------------------------
    448 !    define an array to hold the surface area of each grid column
    449 !    so that the integrals may be weighted properly. sum over the
    450 !    processor, and then over all processors, storing the total
    451 !    global surface area in sum_area.
    452 !-------------------------------------------------------------------------------
    453       allocate (area(idim,jdim))
    454 
    455       area = area_in
    456 

Page 9           Source Listing                  DIAG_INTEGRAL_INIT
2021-06-01 08:55                                 diag_integral.F90

    457       sum_area_local = sum(area)
    458       sum_area = sum_area_local
    459       call mpp_sum (sum_area)
    460 
    461 !-------------------------------------------------------------------------------
    462 !    if integral output is  to go to a file, open the file on unit
    463 !    diag_unit.
    464 !-------------------------------------------------------------------------------
    465       if (file_name(1:1) /= ' ' ) then
    466         ensemble_size = get_ensemble_size()
    467         if (ensemble_size(1) > 1) then
    468           file_name = ensemble_file_name(file_name)
    469         endif
    470         nc = len_trim(file_name)
    471         diag_unit = open_file (file_name(1:nc), action='write')
    472       endif
    473 
    474 !-------------------------------------------------------------------------------
    475 !    define the variables needed to control the time interval of
    476 !    output. Zero time is a flag indicating that the alarm is not set,
    477 !    i.e., integrals are not desired.  otherwise set the next time to
    478 !    output integrals to be at the value of nml variable
    479 !    output_interval from now.
    480 !-------------------------------------------------------------------------------
    481       Zero_time = set_time (0,0)
    482       if (output_interval >= -0.01) then
    483         Alarm_interval = set_axis_time (output_interval, time_units)
    484         Next_alarm_time = Time + Alarm_interval
    485       else
    486         Alarm_interval = Zero_time
    487       endif
    488       Next_alarm_time = Time + Alarm_interval
    489 
    490 !-------------------------------------------------------------------------------
    491 !    deallocate the local array and mark the module as initialized.
    492 !-------------------------------------------------------------------------------
    493       module_is_initialized = .true.
    494    endif  ! (present optional arguments)
    495 
    496 end subroutine diag_integral_init

Page 10          Source Listing                  DIAG_INTEGRAL_INIT
2021-06-01 08:55 Entry Points                    diag_integral.F90



ENTRY POINTS

  Name                                                
                                                      
 diag_integral_mod_mp_diag_integral_init_             


SYMBOL CROSS REFERENCE

 Name                       Object Declared Type            Bytes Dimen Elements Attributes       References                        
                                                                                                                                    
 ALARM_INTERVAL             Local  483      TIME_TYPE       16          scalar                    483,484,486,488,1002,1045,1557    
 AREA                       Local  453      R(8)            8     2     1        ALC              453,455,457,656,752,848,950,1054  
 AREA_IN                    Dummy  368      R(8)            8     2     1        ARG,IN           455                               
 BLAT                       Dummy  368      R(8)            8     2     1        ARG,IN           411                               
 BLON                       Dummy  368      R(8)            8     2     1        ARG,IN           411,440,441                       
 CHECK_NML_ERROR            Func   418      I(4)            4           scalar   PRIV             108,418                           
 CONSTANTS_INIT             Subr   403                                           PRIV             114,403                           
 DIAG_INTEGRAL_INIT         Subr   368                                                                                              
 DIAG_INTEGRAL_NML          Local  417                                  scalar                    417,427                           
 DIAG_UNIT                  Local  471      I(4)            4           scalar                    328,471,1297,1298,1391,1392       
 ENSEMBLE_SIZE              Local  391      I(4)            4     1     6                         466,467                           
 FIELD_SIZE                 Local  445      I(4)            4           scalar                    445,1259,1260,1261                
 FIELD_SIZE_LOCAL           Local  389      I(4)            4           scalar                    442,443                           
 FILE_EXISTS                Func   416      L(4)            4           scalar   PRIV             113,416                           
 FILE_NAME                  Local  465      CHAR            64          scalar                    239,249,465,468,470,471           
 FMS_INIT                   Subr   401                                           PRIV             109,401                           
 GET_ENSEMBLE_SIZE          Func   466      I(4)            4     1     6        PRIV             116,466                           
 IDIM                       Local  440      I(4)            4           scalar                    440,442,453                       
 IERR                       Local  388      I(4)            4           scalar                    418                               
 INPUT_NML_FILE             Local  417      CHAR                  1     1        ALC,TGT,PRIV     106,417                           
 IO                         Local  388      I(4)            4           scalar                    417,418                           
 JDIM                       Local  441      I(4)            4           scalar                    441,442,453                       
 LEN_TRIM                   Func   470                                  scalar                    470                               
 LOGUNIT                    Local  388      I(4)            4           scalar                    425,427                           
 MODULE_IS_INITIALIZED      Local  395      L(4)            4           scalar                    329,395,493,625,719,814,913,987,10
                                                                                                  35,1059                           
 MPP_INIT                   Subr   402                                           PRIV             115,402                           
 MPP_PE                     Func   426      I(4)            4           scalar   PRIV             110,426,1261,1279,1351            
 MPP_ROOT_PE                Func   426      I(4)            4           scalar   PRIV             110,426,1279,1351                 
 MPP_SUM                    Local  444                                  scalar   PRIV             115,444,459,1247,1248             
 MPP_SUM_REAL8_SCALAR       Subr   444                                           PRIV             444,459,1247,1248                 
 NC                         Local  388      I(4)            4           scalar                    470,471                           
 NEXT_ALARM_TIME            Local  484      TIME_TYPE       16          scalar                    484,488,1002,1558                 
 NINT                       Func   445                                  scalar                    445                               
 OPEN_FILE                  Func   471      I(4)            4           scalar   PRIV             107,471                           
 OUTPUT_INTERVAL            Local  482      R(8)            8           scalar                    233,248,482,483                   
 PRESENT                    Func   410                                  scalar                    410,411                           
 REAL                       Func   443                                  scalar                    443                               
 RSIZE                      Local  387      R(8)            8           scalar                    443,444,445                       
 SET_AXIS_TIME              Func   483      RECORD          16          scalar   PRIV             208,483                           
 SET_TIME                   Local  481                                  scalar   PRIV             101,481,1128                      
 SET_TIME_I                 Func   481      RECORD          16          scalar   PRIV             481,1128                          
 SIZE                       Func   440                                  scalar                    440,441                           
 STDLOG                     Func   425      I(4)            4           scalar   PRIV             112,425                           

Page 11          Source Listing                  DIAG_INTEGRAL_INIT
2021-06-01 08:55 Symbol Table                    diag_integral.F90

 Name                       Object Declared Type            Bytes Dimen Elements Attributes       References                        
                                                                                                                                    
 SUM                        Func   457                                  scalar                    457                               
 SUM_AREA                   Local  458      R(8)            8           scalar                    458,459,1271                      
 SUM_AREA_LOCAL             Local  390      R(8)            8           scalar                    457,458                           
 TIME                       Dummy  368      TIME_TYPE       16          scalar   ARG,IN           410,484,488                       
 TIME_INIT                  Dummy  368      TIME_TYPE       16          scalar   ARG,IN           410,433                           
 TIME_INIT_SAVE             Local  433      TIME_TYPE       16          scalar                    433,1284                          
 TIME_MANAGER_INIT          Subr   404                                           PRIV             102,404                           
 TIME_PLUS                  Func   484      RECORD          16          scalar   PRIV             484,488,1002                      
 TIME_TYPE                  Type   370                                  scalar                    101,271,272,273,275,370,371,982,10
                                                                                                  30,1100,1213,1504,1553            
 TIME_UNITS                 Local  483      CHAR            8           scalar                    236,248,483,1284                  
 VERSION                    Param  424      CHAR            7           scalar                    424                               
 WRITE_VERSION_NUMBER       Subr   424                                           PRIV             111,424                           
 ZERO_TIME                  Local  481      TIME_TYPE       16          scalar                    481,486,1045,1557                 

Page 12          Source Listing                  DIAG_INTEGRAL_INIT
2021-06-01 08:55                                 diag_integral.F90

    497 
    498 
    499 
    500 !###############################################################################
    501 !> \fn diag_integral_field_init
    502 !!
    503 !! \brief diag_integral_field_init registers and intializes an integral field
    504 !!
    505 !! <b> Template: </b>
    506 !!
    507 !! \code{.f90}
    508 !! call diag_integral_field_init (name, format)
    509 !! \endcode
    510 !!
    511 !! <b> Parameters: </b>
    512 !!
    513 !! \code{.f90}
    514 !! character(len=*), intent(in) :: name, format
    515 !! \endcode
    516 !!
    517 !! \param [in] <name> Name of the field to be integrated
    518 !! \param [in] <format> Output format of the field to be integrated
    519 !!
    520 subroutine diag_integral_field_init (name, format)
    521 
    522 character(len=*), intent(in) :: name !< Name of the field to be integrated
    523 character(len=*), intent(in) :: format !< Output format of the field to be integrated
    524 
    525 !-------------------------------------------------------------------------------
    526 ! local variables:
    527 !-------------------------------------------------------------------------------
    528       integer :: field   !< index assigned to the current integral
    529 
    530 !-------------------------------------------------------------------------------
    531 !    note: no initialization is required for this interface. all needed
    532 !    variables are initialized in the source.
    533 !-------------------------------------------------------------------------------
    534 
    535 !-------------------------------------------------------------------------------
    536 !    make sure the integral name is not too long.
    537 !-------------------------------------------------------------------------------
    538       if (len(name) > max_len_name )  then
    539         call error_mesg ('diag_integral_mod',  &
    540                 ' integral name too long', FATAL)
    541       endif
    542 
    543 !-------------------------------------------------------------------------------
    544 !    check to be sure the integral name has not already been
    545 !    initialized.
    546 !-------------------------------------------------------------------------------
    547       field = get_field_index (name)
    548       if (field /= 0)   then
    549         call error_mesg ('diag_integral_mod', &
    550                              'integral name already exists', FATAL)
    551       endif
    552 
    553 !-------------------------------------------------------------------------------

Page 13          Source Listing                  DIAG_INTEGRAL_FIELD_INIT
2021-06-01 08:55                                 diag_integral.F90

    554 !    prepare to register the integral. make sure that there are not
    555 !    more integrals registered than space was provided for; if so, exit.
    556 !-------------------------------------------------------------------------------
    557       num_field = num_field + 1
    558       if (num_field > max_num_field)  then
    559         call error_mesg ('diag_integral_mod', &
    560                               'too many fields initialized', FATAL)
    561       endif
    562 
    563 !-------------------------------------------------------------------------------
    564 !    register the name and output format desired for the given integral.
    565 !    initialize its value and the number of grid points that have been
    566 !    counted to zero.
    567 !-------------------------------------------------------------------------------
    568       field_name   (num_field) = name
    569       field_format (num_field) = format
    570       field_sum    (num_field) = 0.0
    571       field_count  (num_field) = 0
    572 
    573 end subroutine diag_integral_field_init


ENTRY POINTS

  Name                                                      
                                                            
 diag_integral_mod_mp_diag_integral_field_init_             


SYMBOL CROSS REFERENCE

 Name                       Object Declared Type            Bytes Dimen Elements Attributes       References                        
                                                                                                                                    
 DIAG_INTEGRAL_FIELD_INIT   Subr   520                                                                                              
 ERROR_MESG                 Subr   539                                           PRIV             107,539,549,559,626,635,720,729,81
                                                                                                  5,824,914,923,988,1036,1121,1169,1
                                                                                                  255,1262,1602,1619,1631           
 FATAL                      Param  540      I(4)            4           scalar   PRIV             111,540,550,560,627,636,721,730,81
                                                                                                  6,825,915,924,989,1037,1122,1170,1
                                                                                                  258,1264,1603,1621,1632           
 FIELD                      Local  528      I(4)            4           scalar                    547,548                           
 FIELD_COUNT                Local  571      I(4)            4     1     32                        571,653,748,844,948,1246,1273     
 FIELD_FORMAT               Local  569      CHAR            16    1     32                        569,1462,1463                     
 FIELD_NAME                 Local  568      CHAR            12    1     32                        568,1181,1258,1261,1377,1378      
 FIELD_SUM                  Local  570      R(8)            8     1     32                        570,655,751,847,949,1248,1270,1272
 FORMAT                     Dummy  520      CHAR                        scalar   ARG,IN           569                               
 GET_FIELD_INDEX            Func   547      I(4)            4           scalar   PRIV             211,547,633,727,822,921           
 LEN                        Func   538                                  scalar                    538                               
 MAX_LEN_NAME               Param  538      I(4)            4           scalar                    306,538,1168                      
 MAX_NUM_FIELD              Param  558      I(4)            4           scalar                    306,307,308,309,558,1228          
 NAME                       Dummy  520      CHAR                        scalar   ARG,IN           538,547,568                       
 NUM_FIELD                  Local  557      I(4)            4           scalar                    305,557,558,568,569,570,571,1179,1
                                                                                                  239,1291,1294,1362,1454           

Page 14          Source Listing                  DIAG_INTEGRAL_FIELD_INIT
2021-06-01 08:55                                 diag_integral.F90

    574 
    575 
    576 
    577 !###############################################################################
    578 !> \fn sum_field_2d
    579 !! \implements sum_diag_integral_field
    580 !!
    581 !! \brief Perform a 2 dimensional summation of named field
    582 !!
    583 !! <b> Template: </b>
    584 !!
    585 !! \code{.f90}
    586 !! call sum_field_2d (name, data, is, js)
    587 !! \endcode
    588 !!
    589 !! <b> Parameters: </b>
    590 !!
    591 !! \code{.f90}
    592 !! character(len=*),  intent(in) :: name
    593 !! real,              intent(in) :: data(:,:)
    594 !! integer, optional, intent(in) :: is, js
    595 !! \endcode
    596 !!
    597 !! \param [in] <name> Name of the field to be integrated
    598 !! \param [in] <data> field of integrands to be summed over
    599 !! \param [in] <is, js> starting i,j indices over which summation is to occur
    600 !!
    601 subroutine sum_field_2d (name, data, is, js)
    602 
    603 character(len=*),  intent(in) :: name !< Name of the field to be integrated
    604 real,              intent(in) :: data(:,:) !< field of integrands to be summed over
    605 integer, optional, intent(in) :: is !< starting i indices over which summation is to occur
    606 integer, optional, intent(in) :: js !< starting j indices over which summation is to occur
    607 
    608 !-------------------------------------------------------------------------------
    609 ! local variables:
    610 !-------------------------------------------------------------------------------
    611       integer :: field           !< index of desired integral
    612       integer :: i1  !< location indices of current data in
    613 !! processor-global coordinates
    614       integer :: j1  !< location indices of current data in
    615 !! processor-global coordinates
    616       integer :: i2  !< location indices of current data in
    617 !! processor-global coordinates
    618       integer :: j2  !< location indices of current data in
    619 !! processor-global coordinates
    620 
    621 
    622 !-------------------------------------------------------------------------------
    623 !    be sure module has been initialized.
    624 !-------------------------------------------------------------------------------
    625       if (.not. module_is_initialized ) then
    626         call error_mesg ('diag_integral_mod',   &
    627               'module has not been initialized', FATAL )
    628       endif
    629 
    630 !-------------------------------------------------------------------------------

Page 15          Source Listing                  SUM_FIELD_2D
2021-06-01 08:55                                 diag_integral.F90

    631 !    obtain the index of the current integral. make certain it is valid.
    632 !-------------------------------------------------------------------------------
    633       field = get_field_index (name)
    634       if (field == 0)  then
    635         call error_mesg ('diag_integral_mod', &
    636                                     'field does not exist', FATAL)
    637       endif
    638 
    639 !-------------------------------------------------------------------------------
    640 !   define the processor-global indices of the current data. use the
    641 !   value 1 for the initial grid points, if is and js are not input.
    642 !-------------------------------------------------------------------------------
    643      i1 = 1;  if (present(is)) i1 = is
    644      j1 = 1;  if (present(js)) j1 = js
    645      i2 = i1 + size(data,1) - 1
    646      j2 = j1 + size(data,2) - 1
    647 
    648 !-------------------------------------------------------------------------------
    649 !    increment the count of points toward this integral and add the
    650 !    values at this set of grid points to the accumulation array.
    651 !-------------------------------------------------------------------------------
    652 !$OMP CRITICAL
    653       field_count (field) = field_count(field) +   &
    654                             size(data,1)*size(data,2)
    655       field_sum   (field) = field_sum   (field) +  &
    656                             sum (data * area(i1:i2,j1:j2))
    657 
    658 !$OMP END CRITICAL
    659 
    660 end subroutine sum_field_2d

Page 16          Source Listing                  SUM_FIELD_2D
2021-06-01 08:55 Entry Points                    diag_integral.F90



ENTRY POINTS

  Name                                          
                                                
 diag_integral_mod_mp_sum_field_2d_             


SYMBOL CROSS REFERENCE

 Name                       Object Declared Type            Bytes Dimen Elements Attributes       References                        
                                                                                                                                    
 DATA                       Dummy  601      R(8)            8     2     1        ARG,IN           645,646,654,656                   
 FIELD                      Local  611      I(4)            4           scalar                    633,634,653,655                   
 I1                         Local  612      I(4)            4           scalar                    643,645,656                       
 I2                         Local  616      I(4)            4           scalar                    645,656                           
 IS                         Dummy  601      I(4)            4           scalar   ARG,IN           643                               
 J1                         Local  614      I(4)            4           scalar                    644,646,656                       
 J2                         Local  618      I(4)            4           scalar                    646,656                           
 JS                         Dummy  601      I(4)            4           scalar   ARG,IN           644                               
 NAME                       Dummy  601      CHAR                        scalar   ARG,IN           633                               
 PRESENT                    Func   643                                  scalar                    643,644                           
 SIZE                       Func   645                                  scalar                    645,646,654                       
 SUM                        Func   656                                  scalar                    656                               
 SUM_FIELD_2D               Subr   601                                           PRIV                                               

Page 17          Source Listing                  SUM_FIELD_2D
2021-06-01 08:55                                 diag_integral.F90

    661 
    662 
    663 
    664 !###############################################################################
    665 !> \fn sum_field_3d
    666 !! \implements sum_diag_integral_field
    667 !!
    668 !! \brief Perform a 3 dimensional summation of named field
    669 !!
    670 !! <b> Template: </b>
    671 !!
    672 !! \code{.f90}
    673 !! call sum_field_3d (name, data, is, js)
    674 !! \endcode
    675 !!
    676 !! <b> Parameters: </b>
    677 !!
    678 !! \code{.f90}
    679 !! character(len=*),  intent(in) :: name
    680 !! real,              intent(in) :: data(:,:,:)
    681 !! integer, optional, intent(in) :: is, js
    682 !! \endcode
    683 !!
    684 !! \param [in] <name> Name of the field to be integrated
    685 !! \param [in] <data> field of integrands to be summed over
    686 !! \param [in] <is, js> starting i,j indices over which summation is to occur
    687 !!
    688 subroutine sum_field_3d (name, data, is, js)
    689 
    690 character(len=*),  intent(in) :: name !< Name of the field to be integrated
    691 real,              intent(in) :: data(:,:,:) !< field of integrands to be summed over
    692 integer, optional, intent(in) :: is !< starting i,j indices over which summation is to occur
    693 integer, optional, intent(in) :: js !< starting i,j indices over which summation is to occur
    694 
    695 !-------------------------------------------------------------------------------
    696 ! local variables:
    697 !     data2
    698 !     field           ! index of desired integral
    699 !     i1, j1, i2, j2  ! location indices of current data in
    700 !                       processor-global coordinates
    701 !-------------------------------------------------------------------------------
    702       real, dimension (size(data,1),  &
    703                        size(data,2)) :: data2
    704 
    705       integer :: field !< index of desired integral
    706       integer :: i1 !< location indices of current data in
    707 !! processor-global coordinates
    708       integer :: j1 !< location indices of current data in
    709 !! processor-global coordinates
    710       integer :: i2 !< location indices of current data in
    711 !! processor-global coordinates
    712       integer :: j2 !< location indices of current data in
    713 !! processor-global coordinates
    714 
    715 
    716 !-------------------------------------------------------------------------------
    717 !    be sure module has been initialized.

Page 18          Source Listing                  SUM_FIELD_3D
2021-06-01 08:55                                 diag_integral.F90

    718 !-------------------------------------------------------------------------------
    719       if (.not. module_is_initialized ) then
    720         call error_mesg ('diag_integral_mod',   &
    721               'module has not been initialized', FATAL )
    722       endif
    723 
    724 !-------------------------------------------------------------------------------
    725 !    obtain the index of the current integral. make certain it is valid.
    726 !-------------------------------------------------------------------------------
    727       field = get_field_index (name)
    728       if (field == 0)   then
    729         call error_mesg ('diag_integral_mod', &
    730                                'field does not exist', FATAL)
    731       endif
    732 
    733 !-------------------------------------------------------------------------------
    734 !   define the processor-global indices of the current data. use the
    735 !   value 1 for the initial grid points, if is and js are not input.
    736 !-------------------------------------------------------------------------------
    737       i1 = 1;  if (present(is)) i1 = is
    738       j1 = 1;  if (present(js)) j1 = js
    739       i2 = i1 + size(data,1) - 1
    740       j2 = j1 + size(data,2) - 1
    741 
    742 !-------------------------------------------------------------------------------
    743 !    increment the count of points toward this integral. sum first
    744 !    in the vertical and then add the values at this set of grid points
    745 !    to the accumulation array.
    746 !-------------------------------------------------------------------------------
    747 !$OMP CRITICAL
    748       field_count (field) = field_count (field) +   &
    749                             size(data,1)*size(data,2)
    750       data2 = sum(data,3)
    751       field_sum   (field) = field_sum   (field) +  &
    752                             sum (data2 * area(i1:i2,j1:j2))
    753 
    754 !$OMP END CRITICAL
    755 
    756 end subroutine sum_field_3d

Page 19          Source Listing                  SUM_FIELD_3D
2021-06-01 08:55 Entry Points                    diag_integral.F90



ENTRY POINTS

  Name                                          
                                                
 diag_integral_mod_mp_sum_field_3d_             


SYMBOL CROSS REFERENCE

 Name                       Object Declared Type            Bytes Dimen Elements Attributes       References                        
                                                                                                                                    
 DATA                       Dummy  688      R(8)            8     3     1        ARG,IN           702,703,739,740,749,750           
 DATA2                      Local  703      R(8)            8     2     0                         750,752                           
 FIELD                      Local  705      I(4)            4           scalar                    727,728,748,751                   
 I1                         Local  706      I(4)            4           scalar                    737,739,752                       
 I2                         Local  710      I(4)            4           scalar                    739,752                           
 IS                         Dummy  688      I(4)            4           scalar   ARG,IN           737                               
 J1                         Local  708      I(4)            4           scalar                    738,740,752                       
 J2                         Local  712      I(4)            4           scalar                    740,752                           
 JS                         Dummy  688      I(4)            4           scalar   ARG,IN           738                               
 NAME                       Dummy  688      CHAR                        scalar   ARG,IN           727                               
 PRESENT                    Func   737                                  scalar                    737,738                           
 SIZE                       Func   702                                  scalar                    702,703,739,740,749               
 SUM                        Func   750                                  scalar                    750,752                           
 SUM_FIELD_3D               Subr   688                                           PRIV                                               

Page 20          Source Listing                  SUM_FIELD_3D
2021-06-01 08:55                                 diag_integral.F90

    757 
    758 
    759 
    760 !###############################################################################
    761 !> \fn sum_field_wght_3d
    762 !! \implements sum_diag_integral_field
    763 !!
    764 !! \brief Perform a 3 dimensional weighted summation of named field
    765 !!
    766 !! <b> Template: </b>
    767 !!
    768 !! \code{.f90}
    769 !! call sum_field_wght_3d (name, data, wt, is, js)
    770 !! \endcode
    771 !!
    772 !! <b> Parameters: </b>
    773 !!
    774 !! \code{.f90}
    775 !! character(len=*),  intent(in) :: name
    776 !! real,              intent(in) :: data(:,:,:), wt(:,:,:)
    777 !! integer, optional, intent(in) :: is, js
    778 !! \endcode
    779 !!
    780 !! \param [in] <name> Name of the field to be integrated
    781 !! \param [in] <data> field of integrands to be summed over
    782 !! \param [in] <wt> the weight function to be evaluated at summation
    783 !! \param [in] <is, js> starting i,j indices over which summation is to occur
    784 !!
    785 subroutine sum_field_wght_3d (name, data, wt, is, js)
    786 
    787 character(len=*),  intent(in) :: name !< Name of the field to be integrated
    788 real,              intent(in) :: data(:,:,:) !< field of integrands to be summed over
    789 real,              intent(in) :: wt(:,:,:) !< the weight function to be evaluated at summation
    790 integer, optional, intent(in) :: is !< starting i indices over which summation is to occur
    791 integer, optional, intent(in) :: js !< starting j indices over which summation is to occur
    792 
    793 !-------------------------------------------------------------------------------
    794 ! local variables:
    795 !     data2
    796 !     field           ! index of desired integral
    797 !     i1, j1, i2, j2  ! location indices of current data in
    798 !                       processor-global coordinates
    799 !-------------------------------------------------------------------------------
    800       real, dimension (size(data,1),size(data,2)) :: data2
    801       integer :: field !< index of desired integral
    802       integer :: i1 !< location indices of current data in
    803 !! processor-global coordinates
    804       integer :: j1 !< location indices of current data in
    805 !! processor-global coordinates
    806       integer :: i2 !< location indices of current data in
    807 !! processor-global coordinates
    808       integer :: j2 !< location indices of current data in
    809 !! processor-global coordinates
    810 
    811 !-------------------------------------------------------------------------------
    812 !    be sure module has been initialized.
    813 !-------------------------------------------------------------------------------

Page 21          Source Listing                  SUM_FIELD_WGHT_3D
2021-06-01 08:55                                 diag_integral.F90

    814       if (.not. module_is_initialized ) then
    815         call error_mesg ('diag_integral_mod',   &
    816               'module has not been initialized', FATAL )
    817       endif
    818 
    819 !-------------------------------------------------------------------------------
    820 !    obtain the index of the current integral. make certain it is valid.
    821 !-------------------------------------------------------------------------------
    822       field = get_field_index (name)
    823       if (field == 0)   then
    824         call error_mesg ('diag_integral_mod', &
    825                                'field does not exist', FATAL)
    826       endif
    827 
    828 !-------------------------------------------------------------------------------
    829 !   define the processor-global indices of the current data. use the
    830 !   value 1 for the initial grid points, if is and js are not input.
    831 !-------------------------------------------------------------------------------
    832       i1 = 1;  if (present(is)) i1 = is
    833       j1 = 1;  if (present(js)) j1 = js
    834       i2 = i1 + size(data,1) - 1
    835       j2 = j1 + size(data,2) - 1
    836 
    837 !-------------------------------------------------------------------------------
    838 !    increment the count of points toward this integral. sum first
    839 !    in the vertical (including a vertical weighting factor) and then
    840 !    add the values at this set of grid points to the accumulation
    841 !    array.
    842 !-------------------------------------------------------------------------------
    843 !$OMP CRITICAL
    844       field_count (field) = field_count (field) +   &
    845                             size(data,1)*size(data,2)
    846       data2 = vert_diag_integral (data, wt)
    847       field_sum(field) = field_sum   (field) +  &
    848                          sum (data2 * area(i1:i2,j1:j2))
    849 
    850 !$OMP END CRITICAL
    851 
    852 end subroutine sum_field_wght_3d

Page 22          Source Listing                  SUM_FIELD_WGHT_3D
2021-06-01 08:55 Entry Points                    diag_integral.F90



ENTRY POINTS

  Name                                               
                                                     
 diag_integral_mod_mp_sum_field_wght_3d_             


SYMBOL CROSS REFERENCE

 Name                       Object Declared Type            Bytes Dimen Elements Attributes       References                        
                                                                                                                                    
 DATA                       Dummy  785      R(8)            8     3     1        ARG,IN           800,834,835,845,846               
 DATA2                      Local  800      R(8)            8     2     0                         846,848                           
 FIELD                      Local  801      I(4)            4           scalar                    822,823,844,847                   
 I1                         Local  802      I(4)            4           scalar                    832,834,848                       
 I2                         Local  806      I(4)            4           scalar                    834,848                           
 IS                         Dummy  785      I(4)            4           scalar   ARG,IN           832                               
 J1                         Local  804      I(4)            4           scalar                    833,835,848                       
 J2                         Local  808      I(4)            4           scalar                    835,848                           
 JS                         Dummy  785      I(4)            4           scalar   ARG,IN           833                               
 NAME                       Dummy  785      CHAR                        scalar   ARG,IN           822                               
 PRESENT                    Func   832                                  scalar                    832,833                           
 SIZE                       Func   800                                  scalar                    800,834,835,845                   
 SUM                        Func   848                                  scalar                    848                               
 SUM_FIELD_WGHT_3D          Subr   785                                           PRIV                                               
 VERT_DIAG_INTEGRAL         Func   846      R(8)            8     2     0        PRIV             224,846                           
 WT                         Dummy  785      R(8)            8     3     1        ARG,IN           846                               

Page 23          Source Listing                  SUM_FIELD_WGHT_3D
2021-06-01 08:55                                 diag_integral.F90

    853 
    854 
    855 
    856 !###############################################################################
    857 !> \fn sum_field_2d_hemi
    858 !! \implements sum_diag_integral_field
    859 !!
    860 !! \brief Perform a 2 dimensional hemispherical summation of named field
    861 !!
    862 !! <b> Template: </b>
    863 !!
    864 !! \code{.f90}
    865 !! call sum_field_2d_hemi (name, data, is, ie, js, je)
    866 !! \endcode
    867 !!
    868 !! <b> Parameters: </b>
    869 !!
    870 !! \code{.f90}
    871 !! character(len=*),  intent(in) :: name
    872 !! real,              intent(in) :: data(:,:)
    873 !! integer,           intent(in) :: is, js, ie, je
    874 !! \endcode
    875 !!
    876 !! \param [in] <name> Name of the field to be integrated
    877 !! \param [in] <data> field of integrands to be summed over
    878 !! \param [in] <is, js, ie, je> starting/ending i,j indices over which summation
    879 !!        is to occur
    880 !!
    881 subroutine sum_field_2d_hemi (name, data, is, ie, js, je)
    882 
    883 character(len=*),  intent(in) :: name !< Name of the field to be integrated
    884 real,              intent(in) :: data(:,:) !< field of integrands to be summed over
    885 integer,           intent(in) :: is !< starting/ending i,j indices over which summation
    886 !! is to occur
    887 integer,           intent(in) :: js !< starting/ending i,j indices over which summation
    888 !! is to occur
    889 integer,           intent(in) :: ie !< starting/ending i,j indices over which summation
    890 !! is to occur
    891 integer,           intent(in) :: je !< starting/ending i,j indices over which summation
    892 !! is to occur
    893 
    894 !-------------------------------------------------------------------------------
    895 ! local variables:
    896 !     field           ! index of desired integral
    897 !     i1, j1, i2, j2  ! location indices of current data in
    898 !                       processor-global coordinates
    899 !-------------------------------------------------------------------------------
    900    integer :: field !< index of desired integral
    901    integer :: i1 !< location indices of current data in
    902 !! processor-global coordinates
    903    integer :: j1 !< location indices of current data in
    904 !! processor-global coordinates
    905    integer :: i2 !< location indices of current data in
    906 !! processor-global coordinates
    907    integer :: j2 !< location indices of current data in
    908 !! processor-global coordinates
    909 

Page 24          Source Listing                  SUM_FIELD_2D_HEMI
2021-06-01 08:55                                 diag_integral.F90

    910 !-------------------------------------------------------------------------------
    911 !    be sure module has been initialized.
    912 !-------------------------------------------------------------------------------
    913       if (.not. module_is_initialized ) then
    914         call error_mesg ('diag_integral_mod',   &
    915               'module has not been initialized', FATAL )
    916       endif
    917 
    918 !-------------------------------------------------------------------------------
    919 !    obtain the index of the current integral. make certain it is valid.
    920 !-------------------------------------------------------------------------------
    921       field = get_field_index (name)
    922       if (field == 0)    then
    923         call error_mesg ('diag_integral_mod', &
    924                                'field does not exist', FATAL)
    925       endif
    926 
    927 !-------------------------------------------------------------------------------
    928 !    define the processor-global indices of the current data. this form
    929 !    is needed to handle case of 2d domain decomposition with physics
    930 !    window smaller than processor domain size.
    931 !-------------------------------------------------------------------------------
    932       i1 = mod ( (is-1), size(data,1) ) + 1
    933       i2 = i1 + size(data,1) - 1
    934 
    935 !-------------------------------------------------------------------------------
    936 !    for a hemispheric sum, sum one jrow at a time in case a processor
    937 !    has data from both hemispheres.
    938 !-------------------------------------------------------------------------------
    939       j1 = mod ( (js-1) ,size(data,2) ) + 1
    940       j2 = j1
    941 
    942 !-------------------------------------------------------------------------------
    943 !    increment the count of points toward this integral. include hemi-
    944 !    spheric factor of 2 in field_count. add the data values at this
    945 !    set of grid points to the accumulation array.
    946 !-------------------------------------------------------------------------------
    947 !$OMP CRITICAL
    948       field_count (field) = field_count (field) + 2* (i2-i1+1)*(j2-j1+1)
    949       field_sum   (field) = field_sum   (field) +  &
    950                             sum (data(i1:i2,j1:j2)*area(is:ie,js:je))
    951 
    952 !$OMP END CRITICAL
    953 
    954 end subroutine sum_field_2d_hemi

Page 25          Source Listing                  SUM_FIELD_2D_HEMI
2021-06-01 08:55 Entry Points                    diag_integral.F90



ENTRY POINTS

  Name                                               
                                                     
 diag_integral_mod_mp_sum_field_2d_hemi_             


SYMBOL CROSS REFERENCE

 Name                       Object Declared Type            Bytes Dimen Elements Attributes       References                        
                                                                                                                                    
 DATA                       Dummy  881      R(8)            8     2     1        ARG,IN           932,933,939,950                   
 FIELD                      Local  900      I(4)            4           scalar                    921,922,948,949                   
 I1                         Local  901      I(4)            4           scalar                    932,933,948,950                   
 I2                         Local  905      I(4)            4           scalar                    933,948,950                       
 IE                         Dummy  881      I(4)            4           scalar   ARG,IN           950                               
 IS                         Dummy  881      I(4)            4           scalar   ARG,IN           932,950                           
 J1                         Local  903      I(4)            4           scalar                    939,940,948,950                   
 J2                         Local  907      I(4)            4           scalar                    940,948,950                       
 JE                         Dummy  881      I(4)            4           scalar   ARG,IN           950                               
 JS                         Dummy  881      I(4)            4           scalar   ARG,IN           939,950                           
 MOD                        Func   932                                  scalar                    932,939                           
 NAME                       Dummy  881      CHAR                        scalar   ARG,IN           921                               
 SIZE                       Func   932                                  scalar                    932,933,939                       
 SUM                        Func   950                                  scalar                    950                               
 SUM_FIELD_2D_HEMI          Subr   881                                           PRIV                                               

Page 26          Source Listing                  SUM_FIELD_2D_HEMI
2021-06-01 08:55                                 diag_integral.F90

    955 
    956 
    957 
    958 !###############################################################################
    959 !> \fn diag_integral_output
    960 !!
    961 !! \brief diag_integral_output determines if this is a timestep on which
    962 !!        integrals are to be written. if not, it returns; if so, it calls
    963 !!        write_field_averages.
    964 !!
    965 !!
    966 !! <b> Template: </b>
    967 !!
    968 !! \code{.f90}
    969 !! call diag_integral_output (Time)
    970 !! \endcode
    971 !!
    972 !! <b> Parameters: </b>
    973 !!
    974 !! \code{.f90}
    975 !! type (time_type), intent(in) :: Time
    976 !! \endcode
    977 !!
    978 !! \param [in] <Time> integral time stamp at the current time
    979 !!
    980 subroutine diag_integral_output (Time)
    981 
    982 type (time_type), intent(in) :: Time
    983 
    984 !-------------------------------------------------------------------------------
    985 !    be sure module has been initialized.
    986 !-------------------------------------------------------------------------------
    987       if (.not. module_is_initialized ) then
    988         call error_mesg ('diag_integral_mod',   &
    989               'module has not been initialized', FATAL )
    990       endif
    991 
    992 !-------------------------------------------------------------------------------
    993 !    see if integral output is desired at this time.
    994 !-------------------------------------------------------------------------------
    995       if ( diag_integral_alarm(Time) ) then
    996 
    997 !-------------------------------------------------------------------------------
    998 !    write the integrals by calling write_field_averages. upon return
    999 !    reset the alarm to the next diagnostics time.
   1000 !-------------------------------------------------------------------------------
   1001         call write_field_averages (Time)
   1002         Next_alarm_time = Next_alarm_time + Alarm_interval
   1003       endif
   1004 
   1005 end subroutine diag_integral_output

Page 27          Source Listing                  DIAG_INTEGRAL_OUTPUT
2021-06-01 08:55 Entry Points                    diag_integral.F90



ENTRY POINTS

  Name                                                  
                                                        
 diag_integral_mod_mp_diag_integral_output_             


SYMBOL CROSS REFERENCE

 Name                       Object Declared Type            Bytes Dimen Elements Attributes       References                        
                                                                                                                                    
 DIAG_INTEGRAL_ALARM        Func   995      L(4)            4           scalar   PRIV             221,995                           
 DIAG_INTEGRAL_OUTPUT       Subr   980                                                                                              
 TIME                       Dummy  980      TIME_TYPE       16          scalar   ARG,IN           995,1001                          
 WRITE_FIELD_AVERAGES       Subr   1001                                          PRIV             214,1001,1048                     

Page 28          Source Listing                  DIAG_INTEGRAL_OUTPUT
2021-06-01 08:55                                 diag_integral.F90

   1006 
   1007 
   1008 
   1009 !###############################################################################
   1010 !> \fn diag_integral_end
   1011 !!
   1012 !! \brief diag_integral_end is the destructor for diag_integral_mod.
   1013 !!
   1014 !! <b> Template: </b>
   1015 !!
   1016 !! \code{.f90}
   1017 !! call diag_integral_end (Time)
   1018 !! \endcode
   1019 !!
   1020 !! <b> Parameters: </b>
   1021 !!
   1022 !! \code{.f90}
   1023 !! type (time_type), intent(in) :: Time
   1024 !! \endcode
   1025 !!
   1026 !! \param [in] <Time> integral time stamp at the current time
   1027 !!
   1028 subroutine diag_integral_end (Time)
   1029 
   1030 type (time_type), intent(in) :: Time
   1031 
   1032 !-------------------------------------------------------------------------------
   1033 !    be sure module has been initialized.
   1034 !-------------------------------------------------------------------------------
   1035       if (.not. module_is_initialized ) then
   1036         call error_mesg ('diag_integral_mod',   &
   1037               'module has not been initialized', FATAL )
   1038       endif
   1039 
   1040 !-------------------------------------------------------------------------------
   1041 !    if the alarm interval was set to Zero_time (meaning no integral
   1042 !    output during the model run) call write_field_averages to output
   1043 !    the integrals valid over the entire period of integration.
   1044 !-------------------------------------------------------------------------------
   1045       if (Alarm_interval == Zero_time ) then
   1046 !       if (Alarm_interval /= Zero_time ) then
   1047 !       else
   1048         call write_field_averages (Time)
   1049       endif
   1050 
   1051 !-------------------------------------------------------------------------------
   1052 !    deallocate module variables.
   1053 !-------------------------------------------------------------------------------
   1054       deallocate (area)
   1055 
   1056 !-------------------------------------------------------------------------------
   1057 !    mark the module as uninitialized.
   1058 !-------------------------------------------------------------------------------
   1059       module_is_initialized = .false.
   1060 
   1061 end subroutine diag_integral_end

Page 29          Source Listing                  DIAG_INTEGRAL_END
2021-06-01 08:55 Entry Points                    diag_integral.F90



ENTRY POINTS

  Name                                               
                                                     
 diag_integral_mod_mp_diag_integral_end_             


SYMBOL CROSS REFERENCE

 Name                       Object Declared Type            Bytes Dimen Elements Attributes       References                        
                                                                                                                                    
 DIAG_INTEGRAL_END          Subr   1028                                                                                             
 TIME                       Dummy  1028     TIME_TYPE       16          scalar   ARG,IN           1048                              
 TIME_EQ                    Func   1045     L(4)            4           scalar   PRIV             1045,1557                         

Page 30          Source Listing                  DIAG_INTEGRAL_END
2021-06-01 08:55                                 diag_integral.F90

   1062 
   1063 
   1064 
   1065 !###############################################################################
   1066 !
   1067 !                    PRIVATE SUBROUTINES
   1068 !
   1069 !###############################################################################
   1070 
   1071 
   1072 
   1073 !###############################################################################
   1074 !> \fn set_axis_time
   1075 !!
   1076 !! \brief Function to convert input time to a time_type
   1077 !!
   1078 !! <b> Template: </b>
   1079 !!
   1080 !! \code{.f90}
   1081 !! time = set_axis_time (atime, units)
   1082 !! \endcode
   1083 !!
   1084 !! <b> Parameters: </b>
   1085 !!
   1086 !! \code{.f90}
   1087 !! real,             intent(in) :: atime
   1088 !! character(len=*), intent(in) :: units
   1089 !! type(time_type)  :: Time
   1090 !! \endcode
   1091 !!
   1092 !! \param [in] <atime> integral time stamp at the current time
   1093 !! \param [in] <units> input units, not used
   1094 !! \param [out] <Time>
   1095 !!
   1096 function set_axis_time (atime, units) result (Time)
   1097 
   1098 real,             intent(in) :: atime !< integral time stamp at the current time
   1099 character(len=*), intent(in) :: units !< input units, not used
   1100 type(time_type)  :: Time
   1101 
   1102 !-------------------------------------------------------------------------------
   1103 ! local variables:
   1104 !-------------------------------------------------------------------------------
   1105       integer          :: sec     !< seconds corresponding to the input
   1106 !! variable atime
   1107       integer          :: day = 0 !< day component of time_type variable
   1108 
   1109 !-------------------------------------------------------------------------------
   1110 !    convert the input time to seconds, regardless of input units.
   1111 !-------------------------------------------------------------------------------
   1112       if (units(1:3) == 'sec') then
   1113          sec = int(atime + 0.5)
   1114       else if (units(1:3) == 'min') then
   1115          sec = int(atime*60. + 0.5)
   1116       else if (units(1:3) == 'hou') then
   1117          sec = int(atime*3600. + 0.5)
   1118       else if (units(1:3) == 'day') then

Page 31          Source Listing                  SET_AXIS_TIME
2021-06-01 08:55                                 diag_integral.F90

   1119          sec = int(atime*86400. + 0.5)
   1120       else
   1121          call error_mesg('diag_integral_mod', &
   1122                          'Invalid units sent to set_axis_time', FATAL)
   1123       endif
   1124 
   1125 !-------------------------------------------------------------------------------
   1126 !    convert the time in seconds to a time_type variable.
   1127 !-------------------------------------------------------------------------------
   1128       Time = set_time (sec, day)
   1129 
   1130 end function set_axis_time


ENTRY POINTS

  Name                                           
                                                 
 diag_integral_mod_mp_set_axis_time_             


SYMBOL CROSS REFERENCE

 Name                       Object Declared Type            Bytes Dimen Elements Attributes       References                        
                                                                                                                                    
 ATIME                      Dummy  1096     R(8)            8           scalar   ARG,IN           1113,1115,1117,1119               
 DAY                        Local  1107     I(4)            4           scalar                    1107,1128                         
 INT                        Func   1113                                 scalar                    1113,1115,1117,1119               
 SEC                        Local  1105     I(4)            4           scalar                    1113,1115,1117,1119,1128          
 SET_AXIS_TIME              Func   1096     TIME_TYPE       16          scalar                                                      
 TIME                       Local  1100     TIME_TYPE       16          scalar                    1128                              
 UNITS                      Dummy  1096     CHAR                        scalar   ARG,IN           1112,1114,1116,1118               

Page 32          Source Listing                  SET_AXIS_TIME
2021-06-01 08:55                                 diag_integral.F90

   1131 
   1132 
   1133 
   1134 !###############################################################################
   1135 !> \fn get_field_index
   1136 !!
   1137 !! \brief get_field_index returns returns the index associated with an
   1138 !!   integral name.
   1139 !!
   1140 !! <b> Template: </b>
   1141 !!
   1142 !! \code{.f90}
   1143 !! index = get_field_index (name)
   1144 !! \endcode
   1145 !!
   1146 !! <b> Parameters: </b>
   1147 !!
   1148 !! \code{.f90}
   1149 !! character(len=*),  intent(in) :: name
   1150 !! integer                       :: index
   1151 !! \endcode
   1152 !!
   1153 !! \param [in] <name> Name associated with an integral
   1154 !! \param [out] <index>
   1155 !!
   1156 function get_field_index (name) result (index)
   1157 
   1158 character(len=*),  intent(in) :: name !< Name associated with an integral
   1159 integer                       :: index
   1160 
   1161 !-------------------------------------------------------------------------------
   1162 ! local variables:
   1163 !-------------------------------------------------------------------------------
   1164       integer :: nc
   1165       integer :: i
   1166 
   1167       nc = len_trim (name)
   1168       if (nc > max_len_name)  then
   1169         call error_mesg ('diag_integral_mod',  &
   1170                                         'name too long', FATAL)
   1171       endif
   1172 
   1173 !-------------------------------------------------------------------------------
   1174 !    search each field name for the current string. when found exit
   1175 !    with the index. if not found index will be 0 upon return, which
   1176 !    initiates error condition.
   1177 !-------------------------------------------------------------------------------
   1178       index = 0
   1179       do i = 1, num_field
   1180         if (name(1:nc) ==     &
   1181                        field_name(i) (1:len_trim(field_name(i))) ) then
   1182           index = i
   1183           exit
   1184         endif
   1185       end do
   1186 
   1187 end function get_field_index

Page 33          Source Listing                  GET_FIELD_INDEX
2021-06-01 08:55 Entry Points                    diag_integral.F90



ENTRY POINTS

  Name                                             
                                                   
 diag_integral_mod_mp_get_field_index_             


SYMBOL CROSS REFERENCE

 Name                       Object Declared Type            Bytes Dimen Elements Attributes       References                        
                                                                                                                                    
 GET_FIELD_INDEX            Func   1156     I(4)            4           scalar                                                      
 I                          Local  1165     I(4)            4           scalar                    1179,1181,1182                    
 INDEX                      Local  1159     I(4)            4           scalar                    1178,1182                         
 LEN_TRIM                   Func   1167                                 scalar                    1167,1181                         
 NAME                       Dummy  1156     CHAR                        scalar   ARG,IN           1167,1180                         
 NC                         Local  1164     I(4)            4           scalar                    1167,1168,1180                    

Page 34          Source Listing                  GET_FIELD_INDEX
2021-06-01 08:55                                 diag_integral.F90

   1188 
   1189 
   1190 
   1191 !###############################################################################
   1192 !> \fn write_field_averages
   1193 !!
   1194 !! \brief Subroutine to sum multiple fields, average them and then write the
   1195 !!        result to an output file.
   1196 !!
   1197 !! <b> Template: </b>
   1198 !!
   1199 !! \code{.f90}
   1200 !! call  write_field_averages (Time)
   1201 !! \endcode
   1202 !!
   1203 !! <b> Parameters: </b>
   1204 !!
   1205 !! \code{.f90}
   1206 !! type (time_type), intent(in) :: Time
   1207 !! \endcode
   1208 !!
   1209 !! \param [in] <Time> integral time stamp at the current time
   1210 !!
   1211 subroutine write_field_averages (Time)
   1212 
   1213 type (time_type), intent(in) :: Time !< integral time stamp at the current time
   1214 
   1215 !-------------------------------------------------------------------------------
   1216 ! local variables:
   1217 !      field_avg
   1218 !      xtime
   1219 !      rcount
   1220 !      nn
   1221 !      ninc
   1222 !      nst
   1223 !      nend
   1224 !      fields_to_print
   1225 !      i
   1226 !      kount
   1227 !-------------------------------------------------------------------------------
   1228       real    :: field_avg(max_num_field)
   1229       real    :: xtime, rcount
   1230       integer :: nn, ninc, nst, nend, fields_to_print
   1231       integer :: i, kount
   1232       integer(i8_kind) :: icount
   1233 
   1234 !-------------------------------------------------------------------------------
   1235 !    each header and data format may be different and must be generated
   1236 !    as needed.
   1237 !-------------------------------------------------------------------------------
   1238       fields_to_print = 0
   1239       do i = 1, num_field
   1240 
   1241 !-------------------------------------------------------------------------------
   1242 !    increment the fields_to_print counter.  sum the integrand and the
   1243 !    number of data points contributing to it over all processors.
   1244 !-------------------------------------------------------------------------------

Page 35          Source Listing                  WRITE_FIELD_AVERAGES
2021-06-01 08:55                                 diag_integral.F90

   1245         fields_to_print = fields_to_print + 1
   1246         rcount = real(field_count(i))
   1247         call mpp_sum (rcount)
   1248         call mpp_sum (field_sum(i))
   1249         icount = rcount
   1250 
   1251 !-------------------------------------------------------------------------------
   1252 !    verify that all the data expected for an integral has been
   1253 !    obtained.
   1254 !-------------------------------------------------------------------------------
   1255         if (icount == 0 ) call error_mesg &
   1256                      ('diag_integral_mod',  &
   1257                       'field_count equals zero for field_name ' //  &
   1258                        field_name(i)(1:len_trim(field_name(i))), FATAL )
   1259         kount = icount/field_size
   1260         if ((field_size)*kount /= icount) then
   1261            print*,"name,pe,kount,field_size,icount,rcount=",trim(field_name(i)),mpp_pe(),kount,field_size,icount,rcount
   1262            call error_mesg &
   1263                  ('diag_integral_mod',  &
   1264                   'field_count not a multiple of field_size', FATAL )
   1265         endif
   1266 !-------------------------------------------------------------------------------
   1267 !    define the global integral for field i. reinitialize the point
   1268 !    and data accumulators.
   1269 !-------------------------------------------------------------------------------
   1270         field_avg(fields_to_print) = field_sum(i)/  &
   1271                                      (sum_area*float(kount))
   1272         field_sum  (i) = 0.0
   1273         field_count(i) = 0
   1274       end do
   1275 
   1276 !-------------------------------------------------------------------------------
   1277 !    only the root pe will write out data.
   1278 !-------------------------------------------------------------------------------
   1279       if ( mpp_pe() /= mpp_root_pe() ) return
   1280 
   1281 !-------------------------------------------------------------------------------
   1282 !    define the time associated with the integrals just calculated.
   1283 !-------------------------------------------------------------------------------
   1284       xtime = get_axis_time (Time-Time_init_save, time_units)
   1285 
   1286 !-------------------------------------------------------------------------------
   1287 !    generate the new header and data formats.
   1288 !-------------------------------------------------------------------------------
   1289       nst = 1
   1290       nend = fields_per_print_line
   1291       ninc = (num_field-1)/fields_per_print_line + 1
   1292       do nn=1, ninc
   1293         nst = 1 + (nn-1)*fields_per_print_line
   1294         nend = MIN (nn*fields_per_print_line, num_field)
   1295         if (print_header)  call format_text_init (nst, nend)
   1296         call format_data_init (nst, nend)
   1297         if (diag_unit /= 0) then
   1298           write (diag_unit,format_data(1:nd)) &
   1299                  xtime, (field_avg(i),i=nst,nend)
   1300         else
   1301           write (*, format_data(1:nd)) &

Page 36          Source Listing                  WRITE_FIELD_AVERAGES
2021-06-01 08:55                                 diag_integral.F90

   1302                  xtime, (field_avg(i),i=nst,nend)
   1303         endif
   1304       end do
   1305 
   1306 end subroutine write_field_averages


ENTRY POINTS

  Name                                                  
                                                        
 diag_integral_mod_mp_write_field_averages_             


SYMBOL CROSS REFERENCE

 Name                       Object Declared Type            Bytes Dimen Elements Attributes       References                        
                                                                                                                                    
 FIELDS_PER_PRINT_LINE      Local  1290     I(4)            4           scalar                    244,250,1290,1291,1293,1294       
 FIELDS_TO_PRINT            Local  1230     I(4)            4           scalar                    1238,1245,1270                    
 FIELD_AVG                  Local  1228     R(8)            8     1     32                        1270,1299,1302                    
 FLOAT                      Func   1271                                 scalar                    1271                              
 FORMAT_DATA                Local  1298     CHAR            160         scalar                    1298,1301,1443,1463,1470          
 FORMAT_DATA_INIT           Subr   1296                                          PRIV             217,1296                          
 FORMAT_TEXT_INIT           Subr   1295                                          PRIV             217,1295                          
 GET_AXIS_TIME              Func   1284     R(8)            8           scalar   PRIV             218,1284                          
 I                          Local  1231     I(4)            4           scalar                    1239,1246,1248,1258,1261,1270,1272
                                                                                                  ,1273,1299,1302                   
 I8_KIND                    Param  1232     I(4)            4           scalar   PRIV             100,1232                          
 ICOUNT                     Local  1232     I(8)            8           scalar                    1249,1255,1259,1260,1261          
 KOUNT                      Local  1231     I(4)            4           scalar                    1259,1260,1261,1271               
 LEN_TRIM                   Func   1258                                 scalar                    1258                              
 MIN                        Func   1294                                 scalar                    1294                              
 ND                         Local  1298     I(4)            4           scalar                    1298,1301,1442,1443,1463,1464,1470
                                                                                                  ,1471                             
 NEND                       Local  1230     I(4)            4           scalar                    1290,1294,1295,1296,1299,1302     
 NINC                       Local  1230     I(4)            4           scalar                    1291,1292                         
 NN                         Local  1230     I(4)            4           scalar                    1292,1293,1294                    
 NST                        Local  1230     I(4)            4           scalar                    1289,1293,1295,1296,1299,1302     
 PRINT_HEADER               Local  1295     L(4)            4           scalar                    241,249,1295                      
 RCOUNT                     Local  1229     R(8)            8           scalar                    1246,1247,1249,1261               
 REAL                       Func   1246                                 scalar                    1246                              
 TIME                       Dummy  1211     TIME_TYPE       16          scalar   ARG,IN           1284                              
 TIME_MINUS                 Func   1284     RECORD          16          scalar   PRIV             1284                              
 TRIM                       Func   1261                                 scalar                    1261                              
 WRITE_FIELD_AVERAGES       Subr   1211                                                                                             
 XTIME                      Local  1229     R(8)            8           scalar                    1284,1299,1302                    

Page 37          Source Listing                  WRITE_FIELD_AVERAGES
2021-06-01 08:55                                 diag_integral.F90

   1307 
   1308 
   1309 
   1310 !###############################################################################
   1311 !> \fn format_text_init
   1312 !!
   1313 !! \brief format_text_init generates the header records to be output in the
   1314 !!    integrals file.
   1315 !!
   1316 !! <b> Template: </b>
   1317 !!
   1318 !! \code{.f90}
   1319 !! call  format_text_init (nst_in, nend_in)
   1320 !! \endcode
   1321 !!
   1322 !! <b> Parameters: </b>
   1323 !!
   1324 !! \code{.f90}
   1325 !! integer, intent(in), optional :: nst_in, nend_in
   1326 !! \endcode
   1327 !!
   1328 !! \param [in] <nst_in, nend_in> starting/ending integral index which will be
   1329 !!        included in this format statement
   1330 !!
   1331 subroutine format_text_init (nst_in, nend_in)
   1332 
   1333 integer, intent(in), optional :: nst_in !< starting/ending integral index which will be
   1334 !! included in this format statement
   1335 integer, intent(in), optional :: nend_in !< starting/ending integral index which will be
   1336 !! included in this format statement
   1337 
   1338 !-------------------------------------------------------------------------------
   1339 ! local variables:
   1340 !        i
   1341 !        nc
   1342 !        nst
   1343 !        nend
   1344 !-------------------------------------------------------------------------------
   1345       integer :: i, nc, nst, nend
   1346 
   1347 !-------------------------------------------------------------------------------
   1348 !    only the root pe need execute this routine, since only it will
   1349 !    be outputting integrals.
   1350 !-------------------------------------------------------------------------------
   1351       if (mpp_pe() /= mpp_root_pe()) return
   1352 
   1353 !-------------------------------------------------------------------------------
   1354 !    define the starting and ending integral indices that will be
   1355 !    included in this format statement.
   1356 !-------------------------------------------------------------------------------
   1357       if (present (nst_in) ) then
   1358         nst = nst_in
   1359         nend = nend_in
   1360       else
   1361         nst = 1
   1362         nend = num_field
   1363       endif

Page 38          Source Listing                  FORMAT_TEXT_INIT
2021-06-01 08:55                                 diag_integral.F90

   1364 
   1365 !-------------------------------------------------------------------------------
   1366 !    define the first 11 characters in the format statement.
   1367 !-------------------------------------------------------------------------------
   1368       nt = 11
   1369       format_text(1:nt) = "('#    time"
   1370 
   1371 !-------------------------------------------------------------------------------
   1372 !    generate the rest of the format statement, which will cover
   1373 !    integral indices nst to nend. if satndard printout is desired,
   1374 !    cycle through the loop.
   1375 !-------------------------------------------------------------------------------
   1376       do i=nst,nend
   1377         nc = len_trim(field_name(i))
   1378         format_text(nt+1:nt+nc+5) =  '     ' // field_name(i)(1:nc)
   1379         nt = nt+nc+5
   1380       end do
   1381 
   1382 !-------------------------------------------------------------------------------
   1383 !    include the end of the format statement.
   1384 !-------------------------------------------------------------------------------
   1385       format_text(nt+1:nt+2) = "')"
   1386       nt = nt+2
   1387 
   1388 !-------------------------------------------------------------------------------
   1389 !    write the format statement to either an output file or to stdout.
   1390 !-------------------------------------------------------------------------------
   1391       if (diag_unit /= 0) then
   1392         write (diag_unit, format_text(1:nt))
   1393       else
   1394         write (*, format_text(1:nt))
   1395       endif
   1396 
   1397 end subroutine format_text_init

Page 39          Source Listing                  FORMAT_TEXT_INIT
2021-06-01 08:55 Entry Points                    diag_integral.F90



ENTRY POINTS

  Name                                              
                                                    
 diag_integral_mod_mp_format_text_init_             


SYMBOL CROSS REFERENCE

 Name                       Object Declared Type            Bytes Dimen Elements Attributes       References                        
                                                                                                                                    
 FORMAT_TEXT                Local  1369     CHAR            160         scalar                    1369,1378,1385,1392,1394          
 FORMAT_TEXT_INIT           Subr   1331                                                                                             
 I                          Local  1345     I(4)            4           scalar                    1376,1377,1378                    
 LEN_TRIM                   Func   1377                                 scalar                    1377                              
 NC                         Local  1345     I(4)            4           scalar                    1377,1378,1379                    
 NEND                       Local  1345     I(4)            4           scalar                    1359,1362,1376                    
 NEND_IN                    Dummy  1331     I(4)            4           scalar   ARG,IN           1359                              
 NST                        Local  1345     I(4)            4           scalar                    1358,1361,1376                    
 NST_IN                     Dummy  1331     I(4)            4           scalar   ARG,IN           1357,1358                         
 NT                         Local  1368     I(4)            4           scalar                    1368,1369,1378,1379,1385,1386,1392
                                                                                                  ,1394                             
 PRESENT                    Func   1357                                 scalar                    1357                              

Page 40          Source Listing                  FORMAT_TEXT_INIT
2021-06-01 08:55                                 diag_integral.F90

   1398 
   1399 
   1400 
   1401 !###############################################################################
   1402 !> \fn format_data_init
   1403 !!
   1404 !! \brief format_text_init generates the format to be output in the
   1405 !!    integrals file.
   1406 !!
   1407 !! <b> Template: </b>
   1408 !!
   1409 !! \code{.f90}
   1410 !! call  format_data_init (nst_in, nend_in)
   1411 !! \endcode
   1412 !!
   1413 !! <b> Parameters: </b>
   1414 !!
   1415 !! \code{.f90}
   1416 !! integer, intent(in), optional :: nst_in, nend_in
   1417 !! \endcode
   1418 !!
   1419 !! \param [in] <nst_in, nend_in> starting/ending integral index which will be
   1420 !!        included in this format statement
   1421 !!
   1422 subroutine format_data_init (nst_in, nend_in)
   1423 
   1424 integer, intent(in), optional :: nst_in !< starting/ending integral index which will be
   1425 !! included in this format statement
   1426 integer, intent(in), optional :: nend_in !< starting/ending integral index which will be
   1427 !! included in this format statement
   1428 
   1429 !-------------------------------------------------------------------------------
   1430 ! local variables:
   1431 !        i
   1432 !        nc
   1433 !        nst
   1434 !        nend
   1435 !-------------------------------------------------------------------------------
   1436       integer :: i, nc, nst, nend
   1437 
   1438 !-------------------------------------------------------------------------------
   1439 !    define the start of the format, which covers the time stamp of the
   1440 !    integrals. this section is 9 characters long.
   1441 !-------------------------------------------------------------------------------
   1442       nd = 9
   1443       format_data(1:nd) = '(1x,f10.2'
   1444 
   1445 !-------------------------------------------------------------------------------
   1446 !    define the indices of the integrals that are to be written by this
   1447 !    format statement.
   1448 !-------------------------------------------------------------------------------
   1449       if ( present (nst_in) ) then
   1450         nst = nst_in
   1451         nend = nend_in
   1452       else
   1453         nst = 1
   1454         nend = num_field

Page 41          Source Listing                  FORMAT_DATA_INIT
2021-06-01 08:55                                 diag_integral.F90

   1455       endif
   1456 
   1457 !-------------------------------------------------------------------------------
   1458 !    complete the data format. use the format defined for the
   1459 !    particular integral in setting up the format statement.
   1460 !-------------------------------------------------------------------------------
   1461       do i=nst,nend
   1462          nc = len_trim(field_format(i))
   1463          format_data(nd+1:nd+nc+5) =  ',1x,' // field_format(i)(1:nc)
   1464          nd = nd+nc+5
   1465       end do
   1466 
   1467 !-------------------------------------------------------------------------------
   1468 !    close the format statement.
   1469 !-------------------------------------------------------------------------------
   1470       format_data(nd+1:nd+1) = ')'
   1471       nd = nd + 1
   1472 
   1473 end subroutine format_data_init


ENTRY POINTS

  Name                                              
                                                    
 diag_integral_mod_mp_format_data_init_             


SYMBOL CROSS REFERENCE

 Name                       Object Declared Type            Bytes Dimen Elements Attributes       References                        
                                                                                                                                    
 FORMAT_DATA_INIT           Subr   1422                                                                                             
 I                          Local  1436     I(4)            4           scalar                    1461,1462,1463                    
 LEN_TRIM                   Func   1462                                 scalar                    1462                              
 NC                         Local  1436     I(4)            4           scalar                    1462,1463,1464                    
 NEND                       Local  1436     I(4)            4           scalar                    1451,1454,1461                    
 NEND_IN                    Dummy  1422     I(4)            4           scalar   ARG,IN           1451                              
 NST                        Local  1436     I(4)            4           scalar                    1450,1453,1461                    
 NST_IN                     Dummy  1422     I(4)            4           scalar   ARG,IN           1449,1450                         
 PRESENT                    Func   1449                                 scalar                    1449                              

Page 42          Source Listing                  FORMAT_DATA_INIT
2021-06-01 08:55                                 diag_integral.F90

   1474 
   1475 
   1476 
   1477 !###############################################################################
   1478 !> \fn get_axis_time
   1479 !!
   1480 !! \brief Function to convert the time_type input variable into units of
   1481 !!    units and returns it in atime.
   1482 !!
   1483 !! <b> Template: </b>
   1484 !!
   1485 !! \code{.f90}
   1486 !! atime = get_axis_time (Time, units)
   1487 !! \endcode
   1488 !!
   1489 !! <b> Parameters: </b>
   1490 !!
   1491 !! \code{.f90}
   1492 !! type(time_type),  intent(in) :: Time
   1493 !! character(len=*), intent(in) :: units
   1494 !! real                         :: atime
   1495 !! \endcode
   1496 !!
   1497 !! \param [in] <Time> integral time stamp
   1498 !! \param [in] <units> input units of time_type
   1499 !! \param [out] <atime>
   1500 !!
   1501 !! @return real atime
   1502 function get_axis_time (Time, units) result (atime)
   1503 
   1504 type(time_type),  intent(in) :: Time !< integral time stamp
   1505 character(len=*), intent(in) :: units !< input units of time_type
   1506 real                         :: atime
   1507 
   1508 !-------------------------------------------------------------------------------
   1509 ! local variables:
   1510 !-------------------------------------------------------------------------------
   1511       integer      :: sec, day  ! components of time_type variable
   1512 
   1513       call get_time (Time, sec, day)
   1514       if (units(1:3) == 'sec') then
   1515          atime = float(sec) + 86400.*float(day)
   1516       else if (units(1:3) == 'min') then
   1517          atime = float(sec)/60. + 1440.*float(day)
   1518       else if (units(1:3) == 'hou') then
   1519          atime = float(sec)/3600. + 24.*float(day)
   1520       else if (units(1:3) == 'day') then
   1521          atime = float(sec)/86400. + float(day)
   1522       endif
   1523 
   1524 end function get_axis_time

Page 43          Source Listing                  GET_AXIS_TIME
2021-06-01 08:55 Entry Points                    diag_integral.F90



ENTRY POINTS

  Name                                           
                                                 
 diag_integral_mod_mp_get_axis_time_             


SYMBOL CROSS REFERENCE

 Name                       Object Declared Type            Bytes Dimen Elements Attributes       References                        
                                                                                                                                    
 ATIME                      Local  1506     R(8)            8           scalar                    1515,1517,1519,1521               
 DAY                        Local  1511     I(4)            4           scalar                    1513,1515,1517,1519,1521          
 FLOAT                      Func   1515                                 scalar                    1515,1517,1519,1521               
 GET_AXIS_TIME              Func   1502     R(8)            8           scalar                                                      
 GET_TIME                   Subr   1513                                          PRIV             101,1513                          
 SEC                        Local  1511     I(4)            4           scalar                    1513,1515,1517,1519,1521          
 TIME                       Dummy  1502     TIME_TYPE       16          scalar   ARG,IN           1513                              
 UNITS                      Dummy  1502     CHAR                        scalar   ARG,IN           1514,1516,1518,1520               

Page 44          Source Listing                  GET_AXIS_TIME
2021-06-01 08:55                                 diag_integral.F90

   1525 
   1526 
   1527 
   1528 !###############################################################################
   1529 !> \fn diag_integral_alarm
   1530 !!
   1531 !! \brief Function to check if it is time to write integrals.
   1532 !!   if not writing integrals, return.
   1533 !!
   1534 !! <b> Template: </b>
   1535 !!
   1536 !! \code{.f90}
   1537 !! result = diag_integral_alarm (Time)
   1538 !! \endcode
   1539 !!
   1540 !! <b> Parameters: </b>
   1541 !!
   1542 !! \code{.f90}
   1543 !! type (time_type), intent(in) :: Time
   1544 !! logical                      :: answer
   1545 !! \endcode
   1546 !!
   1547 !! \param [in] <Time> current time
   1548 !! \param [out] <answer>
   1549 !!
   1550 !! @return logical answer
   1551 function diag_integral_alarm (Time) result (answer)
   1552 
   1553 type (time_type), intent(in) :: Time !< current time
   1554 logical                      :: answer
   1555 
   1556       answer = .false.
   1557       if (Alarm_interval == Zero_time) return
   1558       if (Time >= Next_alarm_time) answer = .true.
   1559 
   1560 end function diag_integral_alarm

Page 45          Source Listing                  DIAG_INTEGRAL_ALARM
2021-06-01 08:55 Entry Points                    diag_integral.F90



ENTRY POINTS

  Name                                                 
                                                       
 diag_integral_mod_mp_diag_integral_alarm_             


SYMBOL CROSS REFERENCE

 Name                       Object Declared Type            Bytes Dimen Elements Attributes       References                        
                                                                                                                                    
 ANSWER                     Local  1554     L(4)            4           scalar                    1556,1558                         
 DIAG_INTEGRAL_ALARM        Func   1551     L(4)            4           scalar                                                      
 TIME                       Dummy  1551     TIME_TYPE       16          scalar   ARG,IN           1558                              
 TIME_GE                    Func   1558     L(4)            4           scalar   PRIV             1558                              

Page 46          Source Listing                  DIAG_INTEGRAL_ALARM
2021-06-01 08:55                                 diag_integral.F90

   1561 
   1562 
   1563 
   1564 !###############################################################################
   1565 !> \fn vert_diag_integral
   1566 !!
   1567 !! \brief Function to perform a weighted integral in the vertical
   1568 !!        direction of a 3d data field
   1569 !!
   1570 !! <b> Template: </b>
   1571 !!
   1572 !! \code{.f90}
   1573 !! data2 = vert_diag_integral (data, wt)
   1574 !! \endcode
   1575 !!
   1576 !! <b> Parameters: </b>
   1577 !!
   1578 !! \code{.f90}
   1579 !! real, dimension (:,:,:),         intent(in) :: data, wt
   1580 !! real, dimension (size(data,1),size(data,2)) :: data2
   1581 !! \endcode
   1582 !!
   1583 !! \param [in] <data> integral field data arrays
   1584 !! \param [in] <wt> integral field weighting functions
   1585 !! \param [out] <data2>
   1586 !! @return real array data2
   1587 function vert_diag_integral (data, wt) result (data2)
   1588 
   1589 real, dimension (:,:,:),         intent(in) :: data !< integral field data arrays
   1590 real, dimension (:,:,:),         intent(in) :: wt !< integral field weighting functions
   1591 real, dimension (size(data,1),size(data,2)) :: data2
   1592 
   1593 !-------------------------------------------------------------------------------
   1594 ! local variables:
   1595 !       wt2
   1596 !-------------------------------------------------------------------------------
   1597       real, dimension(size(data,1),size(data,2)) :: wt2
   1598 
   1599 !-------------------------------------------------------------------------------
   1600       wt2 = sum(wt,3)
   1601       if (count(wt2 == 0.) > 0)  then
   1602         call error_mesg ('diag_integral_mod',  &
   1603                              'vert sum of weights equals zero', FATAL)
   1604       endif
   1605       data2 = sum(data*wt,3) / wt2
   1606 
   1607 end function vert_diag_integral

Page 47          Source Listing                  VERT_DIAG_INTEGRAL
2021-06-01 08:55 Entry Points                    diag_integral.F90



ENTRY POINTS

  Name                                                
                                                      
 diag_integral_mod_mp_vert_diag_integral_             


SYMBOL CROSS REFERENCE

 Name                       Object Declared Type            Bytes Dimen Elements Attributes       References                        
                                                                                                                                    
 COUNT                      Func   1601                                 scalar                    1601                              
 DATA                       Dummy  1587     R(8)            8     3     1        ARG,IN           1591,1597,1605                    
 DATA2                      Local  1591     R(8)            8     2     0                         1605                              
 SIZE                       Func   1591                                 scalar                    1591,1597                         
 SUM                        Func   1600                                 scalar                    1600,1605                         
 VERT_DIAG_INTEGRAL         Func   1587     R(8)            8     2     0                                                           
 WT                         Dummy  1587     R(8)            8     3     1        ARG,IN           1600,1605                         
 WT2                        Local  1597     R(8)            8     2     0                         1600,1601,1605                    

Page 48          Source Listing                  VERT_DIAG_INTEGRAL
2021-06-01 08:55                                 diag_integral.F90

   1608 
   1609 !> @brief Adds .ens_## to the diag_integral.out file name
   1610 !! @return character array updated_file_name
   1611 function ensemble_file_name(fname) result(updated_file_name)
   1612      character (len=mxch), intent(inout) :: fname
   1613      character (len=mxch) :: updated_file_name
   1614      integer :: ensemble_id_int
   1615      character(len=7) :: ensemble_suffix
   1616      character(len=2) :: ensemble_id_char
   1617      integer :: i
   1618 !> Make sure the file name short enough to handle adding the ensemble number
   1619      if (len(trim(fname)) > mxch-7) call error_mesg ('diag_integral_mod :: ensemble_file_name',  &
   1620           trim(fname)//" is too long and can not support adding ens_XX.  Please shorten the "//&
   1621           "file_name in the diag_integral_nml", FATAL)
   1622 !> Get the ensemble ID and convert it to a string
   1623           ensemble_id_int = get_ensemble_id()
   1624           write(ensemble_id_char,"(I0)") ensemble_id_int
   1625 !> Add a 0 if the ensemble is less than 10 (2 digit)
   1626           if (ensemble_id_int < 10) then
   1627                ensemble_suffix = ".ens_0"//trim(ensemble_id_char)
   1628           elseif (ensemble_id_int >= 10 .and. ensemble_id_int < 100) then
   1629                ensemble_suffix = ".ens_"//trim(ensemble_id_char)
   1630           else
   1631                call error_mesg ('diag_integral_mod',  &
   1632                 ' Does not support ensemble sizes over 99.', FATAL)
   1633           endif
   1634 !> Insert the ens_ string in the correct location
   1635 !> Loop through to find the last period
   1636           do i=len(trim(fname)),2,-1
   1637                if (fname(i:i) == ".") then
   1638                     updated_file_name = fname(1:i-1)//trim(ensemble_suffix)//fname(i:mxch)
   1639                     return
   1640                endif
   1641           enddo
   1642 !> Add to the end if there is no period in the file name
   1643           updated_file_name = trim(fname)//trim(ensemble_suffix)
   1644 end function ensemble_file_name

Page 49          Source Listing                  ENSEMBLE_FILE_NAME
2021-06-01 08:55 Entry Points                    diag_integral.F90



ENTRY POINTS

  Name                                                
                                                      
 diag_integral_mod_mp_ensemble_file_name_             


SYMBOL CROSS REFERENCE

 Name                       Object Declared Type            Bytes Dimen Elements Attributes       References                        
                                                                                                                                    
 ENSEMBLE_FILE_NAME         Func   1611     CHAR            64          scalar                    468                               
 ENSEMBLE_ID_CHAR           Local  1616     CHAR            2           scalar                    1624,1627,1629                    
 ENSEMBLE_ID_INT            Local  1614     I(4)            4           scalar                    1623,1624,1626,1628               
 ENSEMBLE_SUFFIX            Local  1615     CHAR            7           scalar                    1627,1629,1638,1643               
 FNAME                      Dummy  1611     CHAR            64          scalar   ARG,INOUT        1619,1620,1636,1637,1638,1643     
 GET_ENSEMBLE_ID            Func   1623     I(4)            4           scalar   PRIV             116,1623                          
 I                          Local  1617     I(4)            4           scalar                    1636,1637,1638                    
 LEN                        Func   1619                                 scalar                    1619,1636                         
 MXCH                       Param  1612     I(4)            4           scalar                    238,1612,1613,1619,1638           
 TRIM                       Func   1619                                 scalar                    1619,1620,1627,1629,1636,1638,1643
 UPDATED_FILE_NAME          Local  1613     CHAR            64          scalar                    1638,1643                         

Page 50          Source Listing                  ENSEMBLE_FILE_NAME
2021-06-01 08:55                                 diag_integral.F90

   1645 
   1646 
   1647 
   1648                     end module diag_integral_mod


SYMBOL CROSS REFERENCE

 Name                       Object Declared Type            Bytes Dimen Elements Attributes       References                        
                                                                                                                                    
 CONSTANTS_MOD              Module 114                                                            114                               
 DIAG_INTEGRAL_END          Subr   159                                                            159                               
 DIAG_INTEGRAL_FIELD_INIT   Subr   157                                                            157                               
 DIAG_INTEGRAL_INIT         Subr   157                                                            157                               
 DIAG_INTEGRAL_MOD          Module 26                                                                                               
 DIAG_INTEGRAL_OUTPUT       Subr   158                                                            158                               
 DO_FORMAT_DATA             Local  321      L(4)            4           scalar                    321                               
 ENSEMBLE_MANAGER_MOD       Module 116                                                            116                               
 FMS2_IO_MOD                Module 113                                                            113                               
 FMS_MOD                    Module 107                                                            107                               
 GET_UNIT                   Func   106      I(4)            4           scalar   PRIV             106                               
 MPP_MOD                    Module 106                                                            106,115                           
 Operator (+)                      103                                                                                              
 PLATFORM_MOD               Module 100                                                            100                               
 RADIUS                     Param  114      R(8)            8           scalar   PRIV             114                               
 SUM_DIAG_INTEGRAL_FIELD    Local  196                                  scalar                    158                               
 TIME_MANAGER_MOD           Module 101                                                            101                               

Page 51          Source Listing                  ENSEMBLE_FILE_NAME
2021-06-01 08:55 Subprograms/Common Blocks       diag_integral.F90



SUBPROGRAMS/COMMON BLOCKS

 Name                       Object Declared Type            Bytes Dimen Elements Attributes       References                        
                                                                                                                                    
 DIAG_INTEGRAL_ALARM        Func   1551     L(4)            4           scalar                                                      
 DIAG_INTEGRAL_END          Subr   1028                                                                                             
 DIAG_INTEGRAL_FIELD_INIT   Subr   520                                                                                              
 DIAG_INTEGRAL_INIT         Subr   368                                                                                              
 DIAG_INTEGRAL_MOD          Module 26                                                                                               
 DIAG_INTEGRAL_OUTPUT       Subr   980                                                                                              
 ENSEMBLE_FILE_NAME         Func   1611     CHAR            64          scalar                    468                               
 FORMAT_DATA_INIT           Subr   1422                                                                                             
 FORMAT_TEXT_INIT           Subr   1331                                                                                             
 GET_AXIS_TIME              Func   1502     R(8)            8           scalar                                                      
 GET_FIELD_INDEX            Func   1156     I(4)            4           scalar                                                      
 SET_AXIS_TIME              Func   1096     TIME_TYPE       16          scalar                                                      
 SUM_FIELD_2D               Subr   601                                           PRIV                                               
 SUM_FIELD_2D_HEMI          Subr   881                                           PRIV                                               
 SUM_FIELD_3D               Subr   688                                           PRIV                                               
 SUM_FIELD_WGHT_3D          Subr   785                                           PRIV                                               
 VERT_DIAG_INTEGRAL         Func   1587     R(8)            8     2     0                                                           
 WRITE_FIELD_AVERAGES       Subr   1211                                                                                             

COMPILER OPTIONS BEING USED

       -align noall                          -align nonone
       -align nocommons                      -align nodcommons
       -align noqcommons                     -align nozcommons
       -align records                        -align nosequence
       -align norec1byte                     -align norec2byte
       -align norec4byte                     -align norec8byte
       -align norec16byte                    -align norec32byte
       -align norec64byte                    -align noarray8byte
       -align noarray16byte                  -align noarray32byte
       -align noarray64byte                  -align noarray128byte
       -align noarray256byte                 -altparam
       -assume accuracy_sensitive            -assume nobscc
       -assume nobuffered_io                 -assume nobuffered_stdout
       -assume byterecl                      -assume nocontiguous_assumed_shape
       -assume nocontiguous_pointer          -assume cc_omp
       -assume nocstring                     -assume nodummy_aliases
       -assume nofpe_summary                 -assume noieee_fpe_flags
       -assume nominus0                      -assume noold_boz
       -assume old_complex_align             -assume old_unit_star
       -assume old_inquire_recl              -assume old_ldout_format
       -assume old_ldout_zero                -assume noold_logical_assign
       -assume noold_logical_ldio            -assume old_maxminloc
       -assume old_xor                       -assume noprotect_allocates
       -assume protect_constants             -assume noprotect_parens
       -assume split_common                  -assume source_include
       -assume nostd_intent_in               -assume std_minus0_rounding
       -assume nostd_mod_proc_name           -assume std_value
       -assume realloc_lhs                   -assume underscore
       -assume no2underscores                -assume norecursion
       -auto                            no   -auto_scalar

Page 52          Source Listing                  ENSEMBLE_FILE_NAME
2021-06-01 08:55                                 diag_integral.F90

  no   -bintext                              -ccdefault default
       -check noarg_temp_created             -check noassume
       -check nobounds                       -check nocontiguous
       -check noformat                       -check nooutput_conversion
       -check nooverflow                     -check nopointers
       -check noshape                        -check nostack
       -check nouninitialized                -check noudio_iostat
       -coarray-num-procs 0             no   -coarray-config-file
       -convert native                       -cross_reference
       -D __INTEL_COMPILER=1910              -D __INTEL_COMPILER_UPDATE=0
       -D __unix__                           -D __unix
       -D __linux__                          -D __linux
       -D __gnu_linux__                      -D unix
       -D linux                              -D __ELF__
       -D __x86_64                           -D __x86_64__
       -D __amd64                            -D __amd64__
       -D __INTEL_COMPILER_BUILD_DATE=20191121       -D _OPENMP=201611
       -D __INTEL_OFFLOAD                    -D __MMX__
       -D __SSE__                            -D __SSE_MATH__
       -D __SSE2__                           -D __SSE2_MATH__
       -D __pentium4                         -D __pentium4__
       -D __tune_pentium4__                  -D PACKAGE_NAME='"GFDL FMS Library"'
       -D PACKAGE_TARNAME='"FMS"'            -D PACKAGE_VERSION='"2021.02.0"'
       -D PACKAGE_STRING='"GFDL FMS Library 2021.02.0"'       -D PACKAGE_BUGREPORT='"gfdl.climate.model.info@noaa.gov"'
       -D PACKAGE_URL='"https://www.gfdl.noaa.gov/fms"'       -D PACKAGE='"FMS"'
       -D VERSION='"2021.02.0"'              -D STDC_HEADERS=1
       -D HAVE_SYS_TYPES_H=1                 -D HAVE_SYS_STAT_H=1
       -D HAVE_STDLIB_H=1                    -D HAVE_STRING_H=1
       -D HAVE_MEMORY_H=1                    -D HAVE_STRINGS_H=1
       -D HAVE_INTTYPES_H=1                  -D HAVE_STDINT_H=1
       -D HAVE_UNISTD_H=1                    -D HAVE_DLFCN_H=1
       -D LT_OBJDIR='".libs/"'               -D HAVE_MPI_H=1
       -D HAVE_NETCDF_H=1                    -D HAVE_SCHED_GETAFFINITY=1
       -D HAVE_MOD_MPI=1                     -D HAVE_MOD_NETCDF=1
       -D HAVE_CRAY_POINTER=1                -D HAVE_QUAD_PRECISION=1
       -D HAVE_INTERNAL_NML=1                -D use_netCDF=1
       -D use_libMPI=1                       -D INTERNAL_FILE_NML
       -double_size 64                  no   -d_lines
  no   -Qdyncom                              -error_limit 30
  no   -f66                             no   -f77rtl
  no   -fast                                 -fpscomp nofilesfromcmd
       -fpscomp nogeneral                    -fpscomp noioformat
       -fpscomp noldio_spacing               -fpscomp nologicals
  no   -fpconstant                           -fpe3
       -fprm nearest                         -ftz
       -fp_model noprecise                   -fp_model fast
       -fp_model nostrict                    -fp_model nosource
       -fp_model nodouble                    -fp_model noextended
       -fp_model novery_fast                 -fp_model noexcept
       -fp_model nono_except                 -fp_modbits nofp_contract
       -fp_modbits nono_fp_contract          -fp_modbits nofenv_access
       -fp_modbits nono_fenv_access          -fp_modbits nocx_limited_range
       -fp_modbits nono_cx_limited_range       -fp_modbits noprec_div
       -fp_modbits nono_prec_div             -fp_modbits noprec_sqrt
       -fp_modbits nono_prec_sqrt            -fp_modbits ftz
       -fp_modbits nono_ftz                  -fp_modbits nointrin_limited_range
       -fp_modbits nono_intrin_limited_range       -fp_modbits notrunc_compares

Page 53          Source Listing                  ENSEMBLE_FILE_NAME
2021-06-01 08:55                                 diag_integral.F90

       -fp_modbits nono_trunc_compares       -fp_modbits noieee_nan_compares
       -fp_modbits nono_ieee_nan_compares       -fp_modbits honor_f32_conversion
       -fp_modbits nono_honor_f32_conversion       -fp_modbits honor_f64_conversion
       -fp_modbits nono_honor_f64_conversion       -fp_modbits nono_x87_copy
       -fp_modbits nono_no_x87_copy          -fp_modbits noexception_semantics
       -fp_modbits nono_exception_semantics       -fp_modbits noprecise_libm_functions
       -fp_modbits nono_precise_libm_functions       -heap_arrays 0
  no   -threadprivate_compat                 -free
       -g2                                   -iface nomixed_str_len_arg
       -iface nono_mixed_str_len_arg         -init noarrays
       -init nohuge                          -init noinfinity
       -init nominus_huge                    -init nominus_infinity
       -init nominus_tiny                    -init nonan
       -init nosnan                          -init notiny
       -init nozero                     no   -intconstant
       -integer_size 32                 no   -mixed_str_len_arg
       -module ../.mods                      -names lowercase
  no   -noinclude                       no   -o
       -offload-build=host                   -openmp
       -openmp-simd                          -openmp-offload
       -O0                              no   -pad_source
       -real_size 64                    no   -recursive
       -reentrancy threaded                  -vec=simd
       -show nofullpath                      -show noinclude
       -show map                             -show options
  no   -syntax_only                     no   -threadcom
  no   -U                               no   -vms
       -w noall                              -w nonone
       -w noalignments                       -w nodeclarations
       -w noexternals                        -w nogeneral
       -w noignore_bounds                    -w noignore_loc
       -w nointerfaces                       -w noshape
       -w notruncated_source                 -w nouncalled
       -w nouninitialized                    -w nounused
       -w nousage                       no   -wrap-margins

       -includepath : /opt/netcdf/4.6.1/INTEL/include/,/opt/intel/2020/compilers_and_libraries/linux/pstl/include/,
           /opt/intel/2020/compilers_and_libraries_2020.0.166/linux/compiler/include/,.f90,./.f90,./.f90,../include/.f90,
           ./.f90,/opt/netcdf/4.6.1/INTEL/include/.f90,/opt/intel/2020/compilers_and_libraries/linux/mpi/intel64/include/.f90,
           /opt/intel/2020/compilers_and_libraries/linux/mpi/intel64/include/.f90,/opt/intel/2020/compilers_and_libraries/linux/ipp/include/.f90,
           /opt/intel/2020/compilers_and_libraries/linux/mkl/include/.f90,/opt/intel/2020/compilers_and_libraries/linux/pstl/include/.f90,
           /opt/intel/2020/compilers_and_libraries/linux/tbb/include/.f90,/opt/intel/2020/compilers_and_libraries/linux/daal/include/.f90,
           /opt/intel/2020/compilers_and_libraries_2020.0.166/linux/compiler/include/intel64/.f90,/opt/intel/2020/compilers_and_libraries_2020.0.166/linux/compiler/include/icc/.f90,
           /opt/intel/2020/compilers_and_libraries_2020.0.166/linux/compiler/include/.f90,/usr/local/include/.f90,
           /usr/lib/gcc/x86_64-redhat-linux/4.8.5/include/.f90,/usr/include/.f90,/usr/include/.f90,/usr/include/.f90
       -list filename : diag_integral.lst
  no   -o

COMPILER: Intel(R) Fortran 19.1-1555
