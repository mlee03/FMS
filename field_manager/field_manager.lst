Page 1           Source Listing                  FIELD_MANAGER_INIT
2021-06-01 08:55                                 /tmp/ifort7nDeDC.i90

      1 # 1 "field_manager.F90"
      2 !***********************************************************************
      3 !*                   GNU Lesser General Public License
      4 !*
      5 !* This file is part of the GFDL Flexible Modeling System (FMS).
      6 !*
      7 !* FMS is free software: you can redistribute it and/or modify it under
      8 !* the terms of the GNU Lesser General Public License as published by
      9 !* the Free Software Foundation, either version 3 of the License, or (at
     10 !* your option) any later version.
     11 !*
     12 !* FMS is distributed in the hope that it will be useful, but WITHOUT
     13 !* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
     14 !* FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
     15 !* for more details.
     16 !*
     17 !* You should have received a copy of the GNU Lesser General Public
     18 !* License along with FMS.  If not, see <http://www.gnu.org/licenses/>.
     19 !***********************************************************************
     20 
     21 module field_manager_mod
     22 
     23 
     24 
     25 
     26 
     27 
     28 
     29 
     30 !
     31 ! <CONTACT EMAIL="William.Cooke@noaa.gov"> William Cooke
     32 ! </CONTACT>
     33 !
     34 ! <REVIEWER EMAIL="Richard.Slater@noaa.gov"> Richard D. Slater
     35 ! </REVIEWER>
     36 !
     37 ! <REVIEWER EMAIL="Matthew.Harrison@noaa.gov"> Matthew Harrison
     38 ! </REVIEWER>
     39 !
     40 ! <REVIEWER EMAIL="John.Dunne@noaa.gov"> John P. Dunne
     41 ! </REVIEWER>
     42 !
     43 ! <HISTORY
     44 !  SRC="http://www.gfdl.noaa.gov/fms-cgi-bin/cvsweb.cgi/FMS/shared/field_manager/field_manager.F90"/>
     45 
     46 ! <OVERVIEW>
     47 
     48 ! The field manager reads entries from a field table and stores this
     49 ! information along with the type  of field it belongs to. This allows
     50 ! the component models to query the field manager to see if  non-default
     51 ! methods of operation are desired. In essence the field table is a
     52 ! powerful type of namelist. Default values can be provided for all the
     53 ! fields through a namelist, individual fields can be modified  through
     54 ! the field table however.
     55 
     56 !</OVERVIEW>
     57 

Page 2           Source Listing                  FIELD_MANAGER_INIT
2021-06-01 08:55                                 field_manager.F90

     58 ! <DESCRIPTION>
     59 !
     60 ! An example of field table entries could be
     61 ! <PRE>
     62 !"tracer","atmos_mod","sphum"/
     63 !
     64 !"tracer","atmos_mod","sf6"
     65 !"longname","sulf_hex"
     66 !"advection_scheme_horiz","2nd_order"
     67 !"Profile_type","Fixed","surface_value = 0.0E+00"/
     68 !
     69 !"prog_tracers","ocean_mod","age_global"
     70 !horizontal-advection-scheme = mdfl_sweby
     71 !vertical-advection-scheme = mdfl_sweby
     72 !restart_file = ocean_age.res.nc
     73 ! </PRE>
     74 !
     75 ! The field table consists of entries in the following format.
     76 !
     77 ! The first line of an entry should consist of three quoted strings.
     78 !
     79 ! The first quoted string will tell the field manager what type of
     80 ! field it is.
     81 !
     82 ! The second quoted string will tell the field manager which model the
     83 ! field is being applied to.
     84 ! The supported types at present are
     85 !<PRE>
     86 !      "coupler_mod" for the coupler,
     87 !      "atmos_mod" for the atmosphere model,
     88 !      "ocean_mod" for the ocean model,
     89 !      "land_mod" for the land model, and,
     90 !      "ice_mod" for the ice model.
     91 !</PRE>
     92 ! The third quoted string should be a unique name that can be used as a
     93 ! query.
     94 !
     95 ! The second and following lines of each entry are called methods in
     96 ! this context. Methods can be developed within any module and these
     97 ! modules can query the field manager to find any methods that are
     98 ! supplied in the field table.
     99 !
    100 ! These lines can be coded quite flexibly.
    101 !
    102 ! The line can consist of two or three quoted strings or a simple unquoted
    103 ! string.
    104 !
    105 ! If the line consists two or three quoted strings, then the first string will
    106 ! be an identifier that the querying module will ask for.
    107 !
    108 ! The second string will be a name that the querying module can use to
    109 ! set up values for the module.
    110 !
    111 ! The third string, if present, can supply parameters to the calling module that can be
    112 ! parsed and used to further modify values.
    113 !
    114 ! If the line consists of a simple unquoted string then quotes are not allowed

Page 3           Source Listing                  FIELD_MANAGER_INIT
2021-06-01 08:55                                 field_manager.F90

    115 ! in any part of the line.
    116 !
    117 ! An entry is ended with a backslash (/) as the final character in a
    118 ! row.
    119 !
    120 ! Comments can be inserted in the field table by having a # as the
    121 ! first character in the line.
    122 !
    123 ! In the example above we have three field entries.
    124 !
    125 ! The first is a simple declaration of a tracer called "sphum".
    126 !
    127 ! The second is for a tracer called "sf6". In this case a field named
    128 ! "longname" will be given the value "sulf_hex". A field named
    129 ! "advection_scheme_horiz" will be given the value "2nd_order". Finally a field
    130 ! name "Profile_type" will be given a child field called "Fixed", and that field
    131 ! will be given a field called "surface_value" with a real value of 0.0E+00.
    132 !
    133 ! The third entry is an example of a oceanic age tracer. Note that the
    134 ! method lines are formatted differently here. This is the flexibility mentioned
    135 ! above.
    136 !
    137 ! With these formats, a number of restrictions are required.
    138 !
    139 ! The following formats are equally valid.
    140 !<PRE>
    141 !      "longname","sulf_hex"
    142 !      "longname = sulf_hex"
    143 !      longname = sulf_hex
    144 !</PRE>
    145 ! However the following is not valid.
    146 !<PRE>
    147 !      longname = "sulf_hex"
    148 !</PRE>
    149 !
    150 ! In the SF6 example above the last line of the entry could be written in the
    151 ! following ways.
    152 !<PRE>
    153 !      "Profile_type","Fixed","surface_value = 0.0E+00"/
    154 !      Profile_type/Fixed/surface_value = 0.0E+00/
    155 !</PRE>
    156 !
    157 ! Values supplied with fields are converted to the various types with the
    158 ! following assumptions.
    159 !<PRE>
    160 ! Real values : These values contain a decimal point or are in exponential format.
    161 !    These values only support e or E format for exponentials.
    162 !    e.g. 10.0, 1e10 and 1E10 are considered to be real numbers.
    163 !
    164 ! Integer values : These values only contain numbers.
    165 !    e.g 10 is an integer. 10.0 and 1e10 are not.
    166 !
    167 ! Logical values : These values are supplied as one of the following formats.
    168 !    T, .T., TRUE, .TRUE.
    169 !    t, .t., true, .true.
    170 !    F, .F., FALSE, .FALSE.
    171 !    f, .f., false, .false.

Page 4           Source Listing                  FIELD_MANAGER_INIT
2021-06-01 08:55                                 field_manager.F90

    172 !    These will be converted to T or F in a dump of the field.
    173 !
    174 ! Character strings : These values are assumed to be strings if a character
    175 !    other than an e (or E) is in the value. Numbers can be suppled in the value.
    176 !    If the value does not meet the criteria for a real, integer or logical type,
    177 !    it is assumed to be a character type.
    178 !</PRE>
    179 ! The entries within the field table can be designed by the individual
    180 ! authors of code to allow modification of their routines.
    181 !
    182 ! </DESCRIPTION>
    183 
    184 use    mpp_mod, only : mpp_error,   &
    185                        FATAL,       &
    186                        NOTE,        &
    187                        WARNING,     &
    188                        mpp_pe,      &
    189                        mpp_root_pe, &
    190                        stdlog,      &
    191                        stdout,      &
    192                        get_unit
    193 use mpp_io_mod, only : mpp_io_init
    194 use    fms_mod, only : lowercase,   &
    195                        write_version_number
    196 use fms2_io_mod, only: file_exists
    197 
    198 implicit none
    199 private
    200 
    201 ! Include variable "version" to be written to log file.
    202 # 1 "../include/file_version.h" 1 
    203 ! -*-f90-*-
    204 !***********************************************************************
    205 !*                   GNU Lesser General Public License
    206 !*
    207 !* This file is part of the GFDL Flexible Modeling System (FMS).
    208 !*
    209 !* FMS is free software: you can redistribute it and/or modify it under
    210 !* the terms of the GNU Lesser General Public License as published by
    211 !* the Free Software Foundation, either version 3 of the License, or (at
    212 !* your option) any later version.
    213 !*
    214 !* FMS is distributed in the hope that it will be useful, but WITHOUT
    215 !* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
    216 !* FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
    217 !* for more details.
    218 !*
    219 !* You should have received a copy of the GNU Lesser General Public
    220 !* License along with FMS.  If not, see <http://www.gnu.org/licenses/>.
    221 !***********************************************************************
    222 
    223 # 23
    224 
    225   character(len=*), parameter :: version = 'unknown'
    226 
    227 # 202 "field_manager.F90" 2 
    228 logical            :: module_is_initialized  = .false.

Page 5           Source Listing                  FIELD_MANAGER_INIT
2021-06-01 08:55                                 field_manager.F90

    229 
    230 !+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    231 !        Public routines
    232 !        Interface definitions (optional arguments are in [brackets]):
    233 !+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    234 public :: field_manager_init   ! (nfields, [table_name]) returns number of fields
    235 public :: field_manager_end    ! ()
    236 public :: find_field_index     ! (model, field_name) or (list_path)
    237 public :: find_field_index_old ! (model, field_name) returns index of field_name in
    238 public :: find_field_index_new ! (list_path) returns index of field_name in
    239 ! component model model
    240 public :: get_field_info       ! (n,fld_type,fld_name,model,num_methods)
    241 ! Returns parameters relating to field n.
    242 public :: get_field_method     ! (n, m, method) Returns the m-th method of field n
    243 public :: get_field_methods    ! (n, methods) Returns the methods related to field n
    244 public :: parse                ! (text, label, values) Overloaded function to parse integer,
    245 ! real or character. Parse returns the number of values
    246 ! decoded (> 1 => an array of values)
    247 public :: fm_change_list       ! (list) return success
    248 public :: fm_change_root       ! (list) return success
    249 public :: fm_dump_list         ! (list [, recursive]) return success
    250 public :: fm_exists            ! (field) return success
    251 public :: fm_get_index         ! (field) return index
    252 public :: fm_get_current_list  ! () return path
    253 public :: fm_get_length        ! (list) return length
    254 public :: fm_get_type          ! (field) return string
    255 public :: fm_get_value         ! (entry, value [, index]) return success !! generic
    256 public :: fm_get_value_integer !   as above (overloaded function)
    257 public :: fm_get_value_logical !   as above (overloaded function)
    258 public :: fm_get_value_real    !   as above (overloaded function)
    259 public :: fm_get_value_string  !   as above (overloaded function)
    260 public :: fm_intersection      ! (lists, num_lists) return fm_array_list pointer
    261 public :: fm_init_loop         ! (list, iter)
    262 public :: fm_loop_over_list    ! (list, name, type, index) return success
    263 ! (iter, name, type, index) return success
    264 public :: fm_new_list          ! (list [, create] [, keep]) return index
    265 public :: fm_new_value         ! (entry, value [, create] [, index]) return index !! generic
    266 public :: fm_new_value_integer !   as above (overloaded function)
    267 public :: fm_new_value_logical !   as above (overloaded function)
    268 public :: fm_new_value_real    !   as above (overloaded function)
    269 public :: fm_new_value_string  !   as above (overloaded function)
    270 public :: fm_reset_loop        ! ()
    271 public :: fm_return_root       ! () return success
    272 public :: fm_modify_name       ! (oldname, newname) return success
    273 public :: fm_query_method      ! (name, method_name, method_control) return success and
    274 ! name and control strings
    275 public :: fm_find_methods      ! (list, methods, control) return success and name and
    276 ! control strings.
    277 public :: fm_copy_list         ! (list, suffix, [create]) return index
    278 public :: fm_set_verbosity     ! ([verbosity])
    279 
    280 !+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    281 !   Private routines
    282 !   Interface definitions (optional arguments are in [brackets]):
    283 !+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    284 
    285 private :: create_field        ! (list_p, name) return field pointer

Page 6           Source Listing                  FIELD_MANAGER_INIT
2021-06-01 08:55                                 field_manager.F90

    286 private :: dump_list           ! (list_p, recursive, depth) return success
    287 private :: find_base           ! (field, path, base)
    288 private :: find_field          ! (field, list_p) return field pointer
    289 private :: find_head           ! (field, head, rest)
    290 private :: find_list           ! (list, list_p, create) return field pointer
    291 private :: get_field           ! (field, list_p) return field pointer
    292 private :: initialize          ! ()
    293 private :: make_list           ! (list_p, name) return field pointer
    294 
    295 !+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    296 !        Public parameters
    297 !+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    298 integer, parameter, public :: fm_field_name_len = 48
    299 ! <DATA NAME="fm_field_name_len" TYPE="integer, parameter" DEFAULT="48">
    300 !   The length of a character string representing the field name.
    301 ! </DATA>
    302 integer, parameter, public :: fm_path_name_len  = 512
    303 ! <DATA NAME="fm_path_name_len" TYPE="integer, parameter" DEFAULT="512">
    304 !   The length of a character string representing the field path.
    305 ! </DATA>
    306 integer, parameter, public :: fm_string_len     = 128
    307 ! <DATA NAME="fm_string_len" TYPE="integer, parameter" DEFAULT="128">
    308 !   The length of a character string representing character values for the field.
    309 ! </DATA>
    310 integer, parameter, public :: fm_type_name_len  = 8
    311 ! <DATA NAME="fm_type_name_len" TYPE="integer, parameter" DEFAULT="8">
    312 !   The length of a character string representing the various types that the values of the field can take.
    313 ! </DATA>
    314 integer, parameter, public :: NUM_MODELS        = 5
    315 ! <DATA NAME="NUM_MODELS" TYPE="integer, parameter" DEFAULT="5">
    316 !   Number of models (ATMOS, OCEAN, LAND, ICE, COUPLER).
    317 ! </DATA>
    318 integer, parameter, public :: NO_FIELD          = -1
    319 ! <DATA NAME="NO_FIELD" TYPE="integer, parameter" DEFAULT="-1">
    320 !   The value returned if a field is not defined.
    321 ! </DATA>!
    322 integer, parameter, public :: MODEL_ATMOS       = 1
    323 ! <DATA NAME="MODEL_ATMOS" TYPE="integer, parameter" DEFAULT="1">
    324 !   Atmospheric model.
    325 ! </DATA>!
    326 integer, parameter, public :: MODEL_OCEAN       = 2
    327 ! <DATA NAME="MODEL_OCEAN" TYPE="integer, parameter" DEFAULT="2">
    328 !   Ocean model.
    329 ! </DATA>
    330 integer, parameter, public :: MODEL_LAND        = 3
    331 ! <DATA NAME="MODEL_LAND" TYPE="integer, parameter" DEFAULT="3">
    332 !   Land model.
    333 ! </DATA>
    334 integer, parameter, public :: MODEL_ICE         = 4
    335 ! <DATA NAME="MODEL_ICE" TYPE="integer, parameter" DEFAULT="4">
    336 !   Ice model.
    337 ! </DATA>
    338 integer, parameter, public :: MODEL_COUPLER     = 5
    339 ! <DATA NAME="MODEL_COUPLER" TYPE="integer, parameter" DEFAULT="5">
    340 !   Ice model.
    341 ! </DATA>
    342 character(len=11), parameter, public, dimension(NUM_MODELS) :: &

Page 7           Source Listing                  FIELD_MANAGER_INIT
2021-06-01 08:55                                 field_manager.F90

    343    MODEL_NAMES=(/'atmospheric','oceanic    ','land       ','ice        ','coupler    '/)
    344 ! <DATA NAME="MODEL_NAMES" TYPE="character(len=11), parameter">
    345 !   Model names, e.g. MODEL_NAMES(MODEL_OCEAN) is 'oceanic'
    346 ! </DATA>
    347 
    348 !+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    349 !        Public type definitions
    350 !+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    351 
    352 type, public :: fm_array_list_def  !{
    353   character (len=fm_field_name_len), dimension(:), pointer :: names => NULL()
    354   integer                                                  :: length
    355 end type  fm_array_list_def  !}
    356 
    357 !
    358 ! <TYPE NAME="method_type">
    359 ! <DESCRIPTION>
    360 
    361 ! This method_type is a way to allow a component module to alter the parameters it needs
    362 ! for various tracers. In essence this is a way to modify a namelist. A namelist can supply
    363 ! default parameters for all tracers. This  method will allow the user to modify these
    364 ! default parameters for an individual tracer. An example could be that  the user wishes to
    365 ! use second order advection on a tracer and also use fourth order advection on a second
    366 ! tracer  within the same model run. The default advection could be second order and the
    367 ! field table would then indicate  that the second tracer requires fourth order advection.
    368 ! This would be parsed by the advection routine.
    369 
    370 !
    371 ! </DESCRIPTION>
    372 type, public :: method_type
    373 
    374 ! <DATA NAME="method_type :: method_type" TYPE="character" DIM="(128)">
    375 !
    376 !   This string represents a tag that a module using this method can
    377 !   key on. Typically this should contain some reference to the module
    378 !   that is calling it.
    379 ! </DATA>
    380 !
    381 ! <DATA NAME="method_type :: method_name" TYPE="character" DIM="(128)">
    382 !   This is the name of a method which the module can parse and use
    383 !   to assign different default values to a field method.
    384 ! </DATA>
    385 !
    386 ! <DATA NAME="method_type :: method_control" TYPE="character" DIM="(256)">
    387 !   This is the string containing parameters that the module can use
    388 !   as values  for a field method. These should override default
    389 !   values within the module.
    390 ! </DATA>
    391   character(len=fm_string_len) :: method_type
    392   character(len=fm_string_len) :: method_name
    393   character(len=fm_string_len) :: method_control
    394 end type
    395 ! </TYPE> NAME="method_type"
    396 
    397 ! <TYPE NAME="method_type_short">
    398 ! <DESCRIPTION>
    399 !   This method_type is the same as method_type except that the

Page 8           Source Listing                  FIELD_MANAGER_INIT
2021-06-01 08:55                                 field_manager.F90

    400 !   method_control string is not present. This is used when you wish to
    401 !   change to a scheme within a module but do not need to pass
    402 !   parameters.
    403 ! </DESCRIPTION>
    404 type, public :: method_type_short
    405 ! <DATA NAME="method_type_short :: method_type" TYPE="character" DIM="(128)">
    406 !   see method_type :: method_type above.
    407 ! </DATA>
    408 !
    409 ! <DATA NAME="method_type_short :: method_name" TYPE="character" DIM="(128)">
    410 !   see method_type :: method_name above.
    411 ! </DATA>
    412   character(len=fm_string_len) :: method_type
    413   character(len=fm_string_len) :: method_name
    414 end type
    415 ! </TYPE> NAME="method_type_short"
    416 
    417 ! <TYPE NAME="method_type_very_short">
    418 ! <DESCRIPTION>
    419 !   This method_type is the same as method_type except that the
    420 !   method_control and method_name strings are not present. This is used
    421 !   when you wish to change to a scheme within a module but do not need
    422 !   to pass  parameters.
    423 ! </DESCRIPTION>
    424 type, public :: method_type_very_short
    425 ! <DATA NAME="method_type_short :: method_type" TYPE="character" DIM="(128)">
    426 !   see method_type :: method_type above.
    427 ! </DATA>
    428   character(len=fm_string_len) :: method_type
    429 end type
    430 ! </TYPE> NAME="method_type_very_short"
    431 
    432 ! iterator over the field manager list
    433 type, public :: fm_list_iter_type
    434    type(field_def), pointer    :: ptr => NULL()  ! pointer to the current field
    435 end type fm_list_iter_type
    436 
    437 
    438 !+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    439 !        Public types
    440 !+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    441 
    442 type(method_type), public :: default_method
    443 
    444 
    445 !+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    446 !        Public variables
    447 !+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    448 
    449 !+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    450 !        Interface definitions for overloaded routines
    451 !+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    452 
    453 interface find_field_index
    454   module procedure  find_field_index_old
    455   module procedure  find_field_index_new
    456 end interface

Page 9           Source Listing                  FIELD_MANAGER_INIT
2021-06-01 08:55                                 field_manager.F90

    457 
    458 interface parse
    459   module procedure  parse_real
    460   module procedure  parse_reals
    461   module procedure  parse_integer
    462   module procedure  parse_integers
    463   module procedure  parse_string
    464   module procedure  parse_strings
    465 end interface
    466 
    467 interface  fm_new_value  !{
    468   module procedure  fm_new_value_integer
    469   module procedure  fm_new_value_logical
    470   module procedure  fm_new_value_real
    471   module procedure  fm_new_value_string
    472 end interface  !}
    473 
    474 interface  fm_get_value  !{
    475   module procedure  fm_get_value_integer
    476   module procedure  fm_get_value_logical
    477   module procedure  fm_get_value_real
    478   module procedure  fm_get_value_string
    479 end interface  !}
    480 
    481 interface fm_loop_over_list
    482   module procedure  fm_loop_over_list_new
    483   module procedure  fm_loop_over_list_old
    484 end interface
    485 
    486 !+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    487 !        Private parameters
    488 !+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    489 
    490 character(len=17), parameter :: module_name       = 'field_manager_mod'
    491 character(len=1),  parameter :: bracket_left      = '['
    492 character(len=1),  parameter :: bracket_right     = ']'
    493 character(len=1),  parameter :: comma             = ","
    494 character(len=1),  parameter :: comment           = '#'
    495 character(len=1),  parameter :: dquote            = '"'
    496 character(len=1),  parameter :: equal             = '='
    497 character(len=1),  parameter :: list_sep          = '/'
    498 character(len=1),  parameter :: space             = ' '
    499 character(len=1),  parameter :: squote            = "'"
    500 character(len=1),  parameter :: tab               = char(9) ! ASCII
    501 
    502 integer,           parameter :: null_type         = 0
    503 integer,           parameter :: integer_type      = 1
    504 integer,           parameter :: list_type         = 2
    505 integer,           parameter :: logical_type      = 3
    506 integer,           parameter :: real_type         = 4
    507 integer,           parameter :: string_type       = 5
    508 integer,           parameter :: num_types         = 5
    509 integer,           parameter :: line_len          = 256
    510 integer,           parameter :: array_increment   = 10
    511 integer,           parameter :: MAX_FIELDS        = 250
    512 integer,           parameter :: MAX_FIELD_METHODS = 250
    513 

Page 10          Source Listing                  FIELD_MANAGER_INIT
2021-06-01 08:55                                 field_manager.F90

    514 
    515 !+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    516 !        Private type definitions
    517 !+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    518 
    519 type, private :: field_mgr_type !{
    520   character(len=fm_field_name_len)                    :: field_type
    521   character(len=fm_string_len)                    :: field_name
    522   integer                                             :: model, num_methods
    523   type(method_type)                                   :: methods(MAX_FIELD_METHODS)
    524 end type field_mgr_type !}
    525 
    526 type, private :: field_names_type !{
    527   character(len=fm_field_name_len)                    :: fld_type
    528   character(len=fm_field_name_len)                    :: mod_name
    529   character(len=fm_string_len)                    :: fld_name
    530 end  type field_names_type !}
    531 
    532 type, private :: field_names_type_short !{
    533   character(len=fm_field_name_len)                    :: fld_type
    534   character(len=fm_field_name_len)                    :: mod_name
    535 end type field_names_type_short !}
    536 
    537 type, private :: field_def  !{
    538   character (len=fm_field_name_len)                   :: name
    539   integer                                             :: index
    540   type (field_def), pointer                           :: parent => NULL()
    541   integer                                             :: field_type
    542   integer                                             :: length
    543   integer                                             :: array_dim
    544   integer                                             :: max_index
    545   type (field_def), pointer                           :: first_field => NULL()
    546   type (field_def), pointer                           :: last_field => NULL()
    547   integer, pointer, dimension(:)                      :: i_value => NULL()
    548   logical, pointer, dimension(:)                      :: l_value => NULL()
    549   real, pointer, dimension(:)                         :: r_value => NULL()
    550   character(len=fm_string_len), pointer, dimension(:) :: s_value => NULL()
    551   type (field_def), pointer                           :: next => NULL()
    552   type (field_def), pointer                           :: prev => NULL()
    553 end type field_def  !}
    554 
    555 !+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    556 !        Private types
    557 !+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    558 
    559 type(field_mgr_type), private :: fields(MAX_FIELDS)
    560 
    561 
    562 !+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    563 !        Private variables
    564 !+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    565 
    566 character(len=fm_path_name_len)  :: loop_list
    567 character(len=fm_type_name_len)  :: field_type_name(num_types)
    568 character(len=fm_field_name_len) :: save_root_name
    569 ! The string set is the set of characters.
    570 character(len=52)                :: set = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"

Page 11          Source Listing                  FIELD_MANAGER_INIT
2021-06-01 08:55                                 field_manager.F90

    571 ! If a character in the string being parsed matches a character within
    572 ! the string set_nonexp then the string being parsed cannot be a number.
    573 character(len=50)                :: set_nonexp = "ABCDFGHIJKLMNOPQRSTUVWXYZabcdfghijklmnopqrstuvwxyz"
    574 ! If a character in the string being parsed matches a character within
    575 ! the string setnum then the string may be a number.
    576 character(len=13)                :: setnum     = "0123456789+-."
    577 integer                          :: num_fields         = 0
    578 integer                          :: verb               = 0
    579 integer                          :: verb_level_warn    = 0
    580 integer                          :: verb_level_note    = 0
    581 integer                          :: default_verbosity  = 0
    582 integer                          :: max_verbosity      = 1
    583 type (field_def), pointer        :: loop_list_p        => NULL()
    584 type (field_def), pointer        :: current_list_p     => NULL()
    585 type (field_def), pointer        :: root_p             => NULL()
    586 type (field_def), pointer        :: save_root_parent_p => NULL()
    587 type (field_def), target, save   :: root
    588 
    589 contains
    590 
    591 ! <SUBROUTINE NAME="field_manager_init">
    592 !   <OVERVIEW>
    593 !     Routine to initialize the field manager.
    594 !   </OVERVIEW>
    595 !   <DESCRIPTION>
    596 !     This routine reads from a file containing formatted strings.
    597 !     These formatted strings contain information on which schemes are
    598 !     needed within various modules. The field manager does not
    599 !     initialize any of those schemes however. It simply holds the
    600 !     information and is queried by the appropriate  module.
    601 !   </DESCRIPTION>
    602 !   <TEMPLATE>
    603 !     call field_manager_init(nfields, table_name)
    604 !   </TEMPLATE>
    605 
    606 subroutine field_manager_init(nfields, table_name)
    607 
    608 ! <OUT NAME="nfields" TYPE="integer">
    609 !   The number of fields.
    610 ! </OUT>
    611 
    612 integer,                      intent(out), optional :: nfields
    613 
    614 ! <IN NAME="table_name" TYPE="character, optional"
    615 !     DIM="(len=128)" DEFAULT="field_table">
    616 !   The name of the field table. The default name is field_table.
    617 ! </IN>
    618 
    619 character(len=fm_string_len), intent(in), optional :: table_name
    620 
    621 !+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    622 !        local parameters
    623 !+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    624 character(len=18), parameter :: sub_name     = 'field_manager_init'
    625 character(len=64), parameter :: error_header = '==>Error from ' // trim(module_name)   //  &
    626                                                '(' // trim(sub_name) // '): '
    627 character(len=64), parameter :: warn_header  = '==>Warning from ' // trim(module_name) //  &

Page 12          Source Listing                  FIELD_MANAGER_INIT
2021-06-01 08:55                                 field_manager.F90

    628                                                '(' // trim(sub_name) // '): '
    629 character(len=64), parameter :: note_header  = '==>Note from ' // trim(module_name)    //  &
    630                                                '(' // trim(sub_name) // '): '
    631 
    632 !+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    633 !        local variables
    634 !+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    635 character(len=1024)              :: record
    636 character(len=fm_path_name_len)  :: control_str
    637 character(len=fm_path_name_len)  :: list_name
    638 character(len=fm_path_name_len)  :: method_name
    639 character(len=fm_path_name_len)  :: name_str
    640 character(len=fm_path_name_len)  :: type_str
    641 character(len=fm_path_name_len)  :: val_name
    642 character(len=fm_string_len)     :: tbl_name
    643 integer                          :: control_array(MAX_FIELDS,3)
    644 integer                          :: endcont
    645 integer                          :: icount
    646 integer                          :: index_list_name
    647 integer                          :: iunit
    648 integer                          :: l
    649 integer                          :: log_unit
    650 integer                          :: ltrec
    651 integer                          :: m
    652 integer                          :: midcont
    653 integer                          :: model
    654 integer                          :: startcont
    655 integer                          :: io_status
    656 logical                          :: flag_method
    657 logical                          :: fm_success
    658 type(field_names_type_short)     :: text_names_short
    659 type(field_names_type)           :: text_names
    660 type(method_type_short)          :: text_method_short
    661 type(method_type)                :: text_method
    662 type(method_type_very_short)     :: text_method_very_short
    663 
    664 
    665 
    666 if (module_is_initialized) then
    667    if(present(nfields)) nfields = num_fields
    668    return
    669 endif
    670 
    671 # 652
    672 
    673 
    674 num_fields = 0
    675 call initialize
    676 
    677 call mpp_io_init()
    678 
    679 if (.not.PRESENT(table_name)) then
    680    tbl_name = 'field_table'
    681 else
    682    tbl_name = trim(table_name)
    683 endif
    684 if (.not. file_exists(trim(tbl_name))) then

Page 13          Source Listing                  FIELD_MANAGER_INIT
2021-06-01 08:55                                 field_manager.F90

    685 !   <ERROR MSG="No field table available, so no fields are being registered." STATUS="NOTE">
    686 !      The field table does not exist.
    687 !   </ERROR>
    688   if (mpp_pe() == mpp_root_pe()) then
    689     if (verb .gt. verb_level_warn) then
    690       call mpp_error(NOTE, trim(warn_header)//                       &
    691          'No field table ('//trim(tbl_name)//') available, so no fields are being registered.')
    692     endif
    693   endif
    694 if(present(nfields)) nfields = 0
    695   return
    696 endif
    697 
    698 iunit = get_unit()
    699 open(iunit, file=trim(tbl_name), action='READ', iostat=io_status)
    700 if(io_status/=0) call mpp_error(FATAL, 'field_manager_mod: Error in opening file '//trim(tbl_name))
    701 !write_version_number should precede all writes to stdlog from field_manager
    702 call write_version_number("FIELD_MANAGER_MOD", version)
    703 log_unit = stdlog()
    704 do while (.TRUE.)
    705    read(iunit,'(a)',end=89,err=99) record
    706    write( log_unit,'(a)' )record
    707    if (record(1:1) == "#" ) cycle
    708    ltrec =  LEN_TRIM(record)
    709    if (ltrec .le. 0 ) cycle ! Blank line
    710 
    711 
    712          icount = 0
    713          do l= 1, ltrec
    714             if (record(l:l) == '"' ) then
    715                icount = icount + 1
    716             endif
    717          enddo
    718 !     <ERROR MSG="Too many fields in field table header entry." STATUS="FATAL">
    719 !       There are more that 3 fields in the field table header entry.
    720 !       The entry should look like <BR/>
    721 !       "Field_Type","Model_Type","Field_Name" <BR/>
    722 !        or<BR/>
    723 !       "Field_Type","Model_Type"
    724 !     </ERROR>
    725       if (icount > 6 ) then
    726         call mpp_error(FATAL,trim(error_header)//'Too many fields in field table header entry.'//trim(record))
    727       endif
    728 
    729          select case (icount)
    730            case (6)
    731              read(record,*,end=79,err=79) text_names
    732              text_names%fld_type = lowercase(trim(text_names%fld_type))
    733              text_names%mod_name = lowercase(trim(text_names%mod_name))
    734              text_names%fld_name = lowercase(trim(text_names%fld_name))
    735            case(4)
    736 ! If there is no control string then the last string can be omitted and there are only 4 '"' in the record.
    737              read(record,*,end=79,err=79) text_names_short
    738              text_names%fld_type = lowercase(trim(text_names_short%fld_type))
    739              text_names%mod_name = lowercase(trim(text_names_short%mod_name))
    740              text_names%fld_name = lowercase(trim(text_names_short%mod_name))
    741            case(2)

Page 14          Source Listing                  FIELD_MANAGER_INIT
2021-06-01 08:55                                 field_manager.F90

    742 ! If there is only the method_type string then the last 2 strings need to be blank and there are only 2 '"' in the record.
    743              read(record,*,end=79,err=79) text_names_short
    744              text_names%fld_type = lowercase(trim(text_names_short%fld_type))
    745              text_names%mod_name = lowercase(trim(text_names_short%mod_name))
    746              text_names%fld_name = lowercase(trim(text_names_short%mod_name))
    747            case default
    748 !     <ERROR MSG="Unterminated field in field table header entry." STATUS="FATAL">
    749 !       There is an unterminated or unquoted string in the field table entry.
    750              text_names%fld_type = " "
    751              text_names%mod_name = lowercase(trim(record))
    752              text_names%fld_name = " "
    753 !             call mpp_error(FATAL,trim(error_header)//'Unterminated field in field_table header entry.'//trim(record))
    754 !     </ERROR>
    755          end select
    756 
    757 ! Create a list with Rick Slaters field manager code
    758 
    759    list_name = list_sep//trim(text_names%mod_name)//list_sep//trim(text_names%fld_type)//&
    760                list_sep//trim(text_names%fld_name)
    761    if (mpp_pe() == mpp_root_pe() ) then
    762      if (verb .gt. verb_level_note) then
    763 !   <ERROR MSG="Creating list name = list_name." STATUS="NOTE">
    764 !      A field is being created called list_name.
    765 !   </ERROR>
    766        call mpp_error(NOTE, trim(note_header)//'Creating list name = '//trim(list_name))
    767      endif
    768    endif
    769 
    770    index_list_name = fm_new_list(list_name, create = .true.)
    771 !   <ERROR MSG="Could not set field list for list_name." STATUS="FATAL">
    772 !      A field called list_name could not be created.
    773 !   </ERROR>
    774    if ( index_list_name == NO_FIELD ) &
    775      call mpp_error(FATAL, trim(error_header)//'Could not set field list for '//trim(list_name))
    776 
    777    fm_success = fm_change_list(list_name)
    778    select case (text_names%mod_name)
    779    case ('coupler_mod')
    780       model = MODEL_COUPLER
    781    case ('atmos_mod')
    782       model = MODEL_ATMOS
    783    case ('ocean_mod')
    784       model = MODEL_OCEAN
    785    case ('land_mod')
    786       model = MODEL_LAND
    787    case ('ice_mod')
    788       model = MODEL_ICE
    789    case default
    790 !   <ERROR MSG="The model name is unrecognised : model_name" STATUS="FATAL">
    791 !      The model name being supplied in the field entry is unrecognised.
    792 !      This should be the second string in the first line of the field entry.
    793 !      Recognised names are atmos_mod, ice_mod, land_mod and ocean_mod.
    794 !   </ERROR>
    795      call mpp_error(FATAL, trim(error_header)//'The model name is unrecognised : '//trim(text_names%mod_name))
    796    end select
    797    if (find_field_index(list_name) > 0) then
    798       num_fields = num_fields + 1

Page 15          Source Listing                  FIELD_MANAGER_INIT
2021-06-01 08:55                                 field_manager.F90

    799 
    800 
    801 !     <ERROR MSG="max fields exceeded" STATUS="FATAL">
    802 !       Maximum number of fields for this module has been exceeded.
    803 !     </ERROR>
    804       if (num_fields > MAX_FIELDS) call mpp_error(FATAL,trim(error_header)//'max fields exceeded')
    805       fields(num_fields)%model       = model
    806       fields(num_fields)%field_name  = lowercase(trim(text_names%fld_name))
    807       fields(num_fields)%field_type  = lowercase(trim(text_names%fld_type))
    808       fields(num_fields)%num_methods = 0
    809       call check_for_name_duplication
    810 
    811 ! Check to see that the first line is not the only line
    812       if ( record(LEN_TRIM(record):LEN_TRIM(record)) == list_sep) cycle
    813 
    814       flag_method = .TRUE.
    815       m = 1
    816       do while (flag_method)
    817          read(iunit,'(a)',end=99,err=99) record
    818 ! If the line is blank then fetch the next line.
    819          if (LEN_TRIM(record) .le. 0) cycle
    820 ! If the last character in the line is / then this is the end of the field methods
    821          if ( record(LEN_TRIM(record):LEN_TRIM(record)) == list_sep) then
    822             flag_method = .FALSE.
    823             if (LEN_TRIM(record) == 1) cycle
    824             record = record(:LEN_TRIM(record)-1) ! Remove the end of field method marker
    825          endif
    826 ! If the line is now blank, after removing the field separator marker, then fetch the next line.
    827          if (LEN_TRIM(record) .le. 0) cycle
    828 ! If the first character in the line is # then it is treated as a comment
    829          if (record(1:1) == comment ) cycle
    830 
    831          icount = 0
    832          do l= 1, LEN_TRIM(record)
    833             if (record(l:l) == dquote ) then
    834                icount = icount + 1
    835             endif
    836          enddo
    837 !     <ERROR MSG="Too many fields in field entry." STATUS="FATAL">
    838 !       There are more that 3 fields in the tracer entry. This is probably due
    839 !       to separating the parameters entry into multiple strings.
    840 !       The entry should look like <BR/>
    841 !       "Type","Name","Control1=XXX,Control2=YYY" <BR/>
    842 !        and not like<BR/>
    843 !       "Type","Name","Control1=XXX","Control2=YYY"
    844 !     </ERROR>
    845       if (icount > 6 ) call mpp_error(FATAL,trim(error_header)//'Too many fields in field entry.'//trim(record))
    846 
    847       if (.not. fm_change_list ( list_name)) &
    848          call mpp_error(FATAL, trim(error_header)//'Could not change to '//trim(list_name)//' list')
    849 
    850       select case (icount)
    851         case (6)
    852           read(record,*,end=99,err=99) text_method
    853           fields(num_fields)%methods(m)%method_type = lowercase(trim(text_method%method_type))
    854           fields(num_fields)%methods(m)%method_name = lowercase(trim(text_method%method_name))
    855           fields(num_fields)%methods(m)%method_control = lowercase(trim(text_method%method_control))

Page 16          Source Listing                  FIELD_MANAGER_INIT
2021-06-01 08:55                                 field_manager.F90

    856 
    857           type_str    = text_method%method_type
    858           name_str    = text_method%method_name
    859           control_str = text_method%method_control
    860 
    861         case(4)
    862 ! If there is no control string then the last string can be omitted and there are only 4 '"' in the record.
    863           read(record,*,end=99,err=99) text_method_short
    864           fields(num_fields)%methods(m)%method_type =&
    865                & lowercase(trim(text_method_short%method_type))
    866 # 856
    867 
    868           fields(num_fields)%methods(m)%method_name =&
    869                & lowercase(trim(text_method_short%method_name))
    870 
    871           fields(num_fields)%methods(m)%method_control = " "
    872 
    873           type_str    = text_method_short%method_type
    874           name_str    = ""
    875           control_str = text_method_short%method_name
    876 
    877         case(2)
    878 ! If there is only the method_type string then the last 2 strings need to be blank and there are only 2 '"' in the record.
    879           read(record,*,end=99,err=99) text_method_very_short
    880           fields(num_fields)%methods(m)%method_type = lowercase(trim(text_method_very_short%method_type))
    881           fields(num_fields)%methods(m)%method_name = " "
    882           fields(num_fields)%methods(m)%method_control = " "
    883 
    884           type_str    = ""
    885           name_str    = ""
    886           control_str = text_method_very_short%method_type
    887 
    888         case(0)
    889           read(record,'(A)',end=99,err=99) control_str
    890           type_str = ""
    891           name_str = ""
    892 
    893         case default
    894 !     <ERROR MSG="Unterminated field in field entry." STATUS="FATAL">
    895 !       There is an unterminated or unquoted string in the field table entry.
    896           call mpp_error(FATAL,trim(error_header)//'Unterminated field in field entry.'//trim(record))
    897 !     </ERROR>
    898       end select
    899 
    900 ! This section of code breaks the control string into separate strings.
    901 ! The array control_array contains the following parameters.
    902 ! control_array(:,1) = index within control_str of the first character of the name.
    903 ! control_array(:,2) = index within control_str of the equal sign
    904 ! control_array(:,3) = index within control_str of the last character of the value.
    905 !
    906 ! control_array(:,1)   -> control_array(:,2) -1 = name of the parameter.
    907 ! control_array(:,2)+1 -> control_array(:,3)    = value of the parameter.
    908 
    909       ltrec= len_trim(control_str)
    910       control_array(:,1) = 1
    911       control_array(:,2:3) = ltrec
    912       icount = 0

Page 17          Source Listing                  FIELD_MANAGER_INIT
2021-06-01 08:55                                 field_manager.F90

    913       do l= 1, ltrec
    914          if (control_str(l:l) == equal ) then
    915             icount = icount + 1
    916             control_array(icount,2) = l ! Middle of string
    917          elseif (control_str(l:l) == comma ) then
    918             if (icount .eq. 0) then
    919 
    920 !     <ERROR MSG="Unterminated field in field entry." STATUS="FATAL">
    921 !       Bad format for field entry (comma without equals sign)
    922               call mpp_error(FATAL,trim(error_header) //                                &
    923                    ' Bad format for field entry (comma without equals sign): ''' //     &
    924                    trim(control_str) // '''')
    925 !     </ERROR>
    926 
    927             elseif (icount .gt. MAX_FIELDS) then
    928 
    929 !     <ERROR MSG="Unterminated field in field entry." STATUS="FATAL">
    930 !       Too many fields in field entry
    931               call mpp_error(FATAL,trim(error_header) //        &
    932                    ' Too many fields in field entry: ''' //     &
    933                    trim(control_str) // '''')
    934 !     </ERROR>
    935 
    936             else
    937 
    938               control_array(icount,3) = l-1   !End of previous string
    939               control_array(min(MAX_FIELDS,icount+1),1) = l+1 !Start of next string
    940 
    941             endif
    942          endif
    943       enddo
    944 
    945 ! Make sure that we point to the end of the string (minus any trailing comma)
    946 ! for the last set of values. This fixes the case where the last set of values
    947 ! is a comma separated list
    948 
    949       if (control_str(ltrec:ltrec) .ne. comma) then
    950         control_array(max(1,icount),3) = ltrec
    951       endif
    952 
    953 
    954       if ( icount == 0 ) then
    955         method_name = type_str
    956         if (len_trim(method_name) > 0 ) then
    957           method_name = trim(method_name)//list_sep// trim(name_str)
    958         else
    959           method_name = trim(name_str)
    960         endif
    961         val_name = control_str
    962 
    963         call new_name(list_name, method_name, val_name )
    964 
    965       else
    966 
    967         do l = 1,icount
    968           startcont = control_array(l,1)
    969           midcont   = control_array(l,2)

Page 18          Source Listing                  FIELD_MANAGER_INIT
2021-06-01 08:55                                 field_manager.F90

    970           endcont   = control_array(l,3)
    971 
    972           method_name = trim(type_str)
    973           if (len_trim(method_name) > 0 ) then
    974             method_name = trim(method_name)//list_sep// trim(name_str)
    975           else
    976             method_name = trim(name_str)
    977           endif
    978 
    979           if (len_trim(method_name) > 0 ) then
    980             method_name = trim(method_name)//list_sep//&
    981                           trim(control_str(startcont:midcont-1))
    982           else
    983             method_name = trim(control_str(startcont:midcont-1))
    984           endif
    985           val_name =    trim(control_str(midcont+1:endcont))
    986 
    987           call new_name(list_name, method_name, val_name )
    988         enddo
    989 
    990       endif
    991 
    992       fields(num_fields)%num_methods = fields(num_fields)%num_methods + 1
    993 !     <ERROR MSG="Maximum number of methods for field exceeded" STATUS="FATAL">
    994 !       Maximum number of methods allowed for entries in the field table has been exceeded.
    995 !     </ERROR>
    996       if (fields(num_fields)%num_methods > MAX_FIELD_METHODS) &
    997          call mpp_error(FATAL,trim(error_header)//'Maximum number of methods for field exceeded')
    998          m = m + 1
    999       enddo
   1000    else
   1001 
   1002 !     <ERROR MSG="Field with identical name and model name duplicate found, skipping" STATUS="NOTE">
   1003 !       The name of the field and the model name are identical. Skipping that field.
   1004 !     </ERROR>
   1005       if (mpp_pe() == 0) then
   1006          if (verb .gt. verb_level_warn) then
   1007            call mpp_error(WARNING, trim(warn_header)//                              &
   1008                 'Field with identical name and model name duplicate found, skipping')
   1009           endif
   1010       endif
   1011       flag_method = .TRUE.
   1012       do while (flag_method)
   1013          read(iunit,'(A)',end=99,err=99) record
   1014          if ( record(LEN_TRIM(record):LEN_TRIM(record)) == list_sep) then
   1015             flag_method = .FALSE.
   1016          endif
   1017       enddo
   1018    endif
   1019 79 continue
   1020 enddo
   1021 
   1022 89 continue
   1023 close(iunit, iostat=io_status)
   1024 if(io_status/=0) call mpp_error(FATAL, 'field_manager_mod: Error in closing file '//trim(tbl_name))
   1025 
   1026 

Page 19          Source Listing                  FIELD_MANAGER_INIT
2021-06-01 08:55                                 field_manager.F90

   1027 if(present(nfields)) nfields = num_fields
   1028 if (verb .gt. verb_level_warn) &
   1029   fm_success= fm_dump_list("/", .true.)
   1030 
   1031 default_method%method_type = 'none'
   1032 default_method%method_name = 'none'
   1033 default_method%method_control = 'none'
   1034 return
   1035 
   1036 99 continue
   1037 
   1038 !     <ERROR MSG="error reading field table" STATUS="FATAL">
   1039 !       There is an error in reading the field table.
   1040 !     </ERROR>
   1041 call mpp_error(FATAL,trim(error_header)//' Error reading field table. Record = '//trim(record))
   1042 
   1043 end subroutine field_manager_init


ENTRY POINTS

  Name                                                
                                                      
 field_manager_mod_mp_field_manager_init_             


SYMBOL CROSS REFERENCE

 Name                       Object Declared Type            Bytes Dimen Elements Attributes       References                        
                                                                                                                                    
 79                         Label  1019                                                           731,737,743                       
 89                         Label  1022                                                           705                               
 99                         Label  1036                                                           705,817,852,863,879,889,1013      
 COMMA                      Param  917      CHAR            1           scalar                    917,949,1143,5990,5994,5998,6001,6
                                                                                                  003,6447                          
 COMMENT                    Param  829      CHAR            1           scalar                    829                               
 CONTROL_ARRAY              Local  643      I(4)            4     2     750                       910,911,916,938,939,950,968,969,97
                                                                                                  0                                 
 CONTROL_STR                Local  636      CHAR            512         scalar                    859,875,886,889,909,914,917,924,93
                                                                                                  3,949,961,981,983,985             
 DEFAULT_METHOD             Local  1031     METHOD_TYPE     384         scalar                    442,1031,1032,1033,1632           
 DQUOTE                     Param  833      CHAR            1           scalar                    833,1208,1216                     
 ENDCONT                    Local  644      I(4)            4           scalar                    970,985                           
 EQUAL                      Param  914      CHAR            1           scalar                    914                               
 ERROR_HEADER               Param  625      CHAR            64          scalar                    726,775,795,804,845,848,896,922,93
                                                                                                  1,997,1041                        
 FATAL                      Param  700      I(4)            4           scalar   PRIV             185,700,726,775,795,804,845,848,89
                                                                                                  6,922,931,997,1024,1041,1158,1163,
                                                                                                  1171,1181,1209,1212,1218,1223,1285
                                                                                                  ,1290,1295,1300,1303,1517,1567,157
                                                                                                  3,1624,1630,1746,1825,1903,6031,61
                                                                                                  66,6173,6180,6187                 
 FIELDS                     Local  805      RECORD          96184 1     250      PRIV             559,805,806,807,808,853,854,855,86
                                                                                                  4,868,871,880,881,882,992,996,1051
                                                                                                  ,1052,1053,1055,1056,1057,1434,151
                                                                                                  9,1520,1521,1522,1573,1575,1629,16
                                                                                                  33                                

Page 20          Source Listing                  FIELD_MANAGER_INIT
2021-06-01 08:55 Symbol Table                    field_manager.F90

 Name                       Object Declared Type            Bytes Dimen Elements Attributes       References                        
                                                                                                                                    
 FIELD_MANAGER_INIT         Subr   606                                                                                              
 FIELD_NAMES_TYPE           Type   659                      224         scalar   PRIV             530,659                           
 FIELD_NAMES_TYPE_SHORT     Type   658                      96          scalar   PRIV             535,658                           
 FILE_EXISTS                Func   684      L(4)            4           scalar   PRIV             196,684                           
 FIND_FIELD_INDEX           Local  797                                  scalar                    236,797                           
 FIND_FIELD_INDEX_NEW       Func   797      I(4)            4           scalar                    238,797,1459,1461                 
 FIND_FIELD_INDEX_NEW@0     Local  797      I(4)            4           scalar                                                      
 FLAG_METHOD                Local  656      L(4)            4           scalar                    814,816,822,1011,1012,1015        
 FM_CHANGE_LIST             Func   777      L(4)            4           scalar                    247,777,847                       
 FM_DUMP_LIST               Func   1029     L(4)            4           scalar                    249,1029                          
 FM_NEW_LIST                Func   770      I(4)            4           scalar                    264,770,6157                      
 FM_PATH_NAME_LEN           Param  636      I(4)            4           scalar                    302,566,636,637,638,639,640,641,16
                                                                                                  16,1617,2569,2570,3100,4316,4470,4
                                                                                                  701,4941,5173,5511,5580,5836,5837,
                                                                                                  5838,6362                         
 FM_STRING_LEN              Param  619      I(4)            4           scalar                    306,391,392,393,412,413,428,521,52
                                                                                                  9,550,619,642,1111,1112,1113,5172,
                                                                                                  6091,6092,6093,6094,6095,6096     
 FM_SUCCESS                 Local  657      L(4)            4           scalar                    777,1029                          
 GET_UNIT                   Func   698      I(4)            4           scalar   PRIV             192,698                           
 ICOUNT                     Local  645      I(4)            4           scalar                    712,715,725,729,831,834,845,850,91
                                                                                                  2,915,916,918,927,938,939,950,954,
                                                                                                  967                               
 INDEX_LIST_NAME            Local  646      I(4)            4           scalar                    770,774                           
 INITIALIZE                 Subr   675                                           PRIV             292,675,2724,2797,2908,2977,3041,3
                                                                                                  113,3209,3302,3401,3524,3650,3779,
                                                                                                  3946,4142,4228,4249,4326,4481,4716
                                                                                                  ,4952,5187,5410,5451,5853,6121,626
                                                                                                  6                                 
 IO_STATUS                  Local  655      I(4)            4           scalar                    699,700,1023,1024                 
 IUNIT                      Local  647      I(4)            4           scalar                    698,699,705,817,1013,1023         
 L                          Local  648      I(4)            4           scalar                    713,714,832,833,913,914,916,917,93
                                                                                                  8,939,967,968,969,970             
 LEN_TRIM                   Func   708                                  scalar                    708,812,819,821,823,824,827,832,90
                                                                                                  9,956,973,979,1014                
 LIST_NAME                  Local  637      CHAR            512         scalar                    759,766,770,775,777,797,847,848,96
                                                                                                  3,987                             
 LIST_SEP                   Param  759      CHAR            1           scalar                    759,760,812,821,957,974,980,1014,1
                                                                                                  243,2147,2166,2306,2323,2473,2479,
                                                                                                  2592,2619,3133,3151,4043,6157,6159
                                                                                                  ,6163,6164,6170,6171,6177,6178,618
                                                                                                  4,6185,6402,6405,6408             
 LOG_UNIT                   Local  649      I(4)            4           scalar                    703,706                           
 LOWERCASE                  Func   732      CHAR                        scalar   TGT,PRIV         194,732,733,734,738,739,740,744,74
                                                                                                  5,746,751,806,807,853,854,855,865,
                                                                                                  869,880,1271,1275,1434,5854       
 LTREC                      Local  650      I(4)            4           scalar                    708,709,713,909,911,913,949,950   
 M                          Local  651      I(4)            4           scalar                    815,853,854,855,864,868,871,880,88
                                                                                                  1,882,998                         
 MAX                        Func   950                                  scalar                    950                               
 MAX_FIELDS                 Param  643      I(4)            4           scalar                    559,643,804,927,939,1114,1115     
 MAX_FIELD_METHODS          Param  996      I(4)            4           scalar                    523,996,6091,6092,6155            
 METHOD_NAME                Local  638      CHAR            512         scalar                    955,956,957,959,963,972,973,974,97
                                                                                                  6,979,980,983,987                 
 METHOD_TYPE                Type   661                      384         scalar                    442,523,661,1554,1604             

Page 21          Source Listing                  FIELD_MANAGER_INIT
2021-06-01 08:55 Symbol Table                    field_manager.F90

 Name                       Object Declared Type            Bytes Dimen Elements Attributes       References                        
                                                                                                                                    
 METHOD_TYPE_SHORT          Type   660                      256         scalar                    660                               
 METHOD_TYPE_VERY_SHORT     Type   662                      128         scalar                    662                               
 MIDCONT                    Local  652      I(4)            4           scalar                    969,981,983,985                   
 MIN                        Func   939                                  scalar                    939                               
 MODEL                      Local  653      I(4)            4           scalar                    780,782,784,786,788,805           
 MODEL_ATMOS                Param  782      I(4)            4           scalar                    322,782                           
 MODEL_COUPLER              Param  780      I(4)            4           scalar                    338,780                           
 MODEL_ICE                  Param  788      I(4)            4           scalar                    334,788                           
 MODEL_LAND                 Param  786      I(4)            4           scalar                    330,786                           
 MODEL_OCEAN                Param  784      I(4)            4           scalar                    326,784                           
 MODULE_IS_INITIALIZED      Local  666      L(4)            4           scalar                    228,666,1353,2723,2796,2908,2976,3
                                                                                                  040,3112,3208,3301,3400,3523,3649,
                                                                                                  3778,3945,4141,4228,4249,4325,4480
                                                                                                  ,4715,4951,5186,5409,5450,5643,567
                                                                                                  9,5853,6120,6265                  
 MODULE_NAME                Param  625      CHAR            17          scalar                    625,627,629,1101,1103,1105,1340,15
                                                                                                  10,1560,1610,1995,1997,2123,2562,2
                                                                                                  564,2786,2893,3028,3196,3289,3387,
                                                                                                  3510,3636,3765,3919,3921,4129,4309
                                                                                                  ,4461,4696,4931,5166,5728,5831,594
                                                                                                  6,6084,6086,6245,6357,6503        
 MPP_ERROR                  Local  690                                  scalar   PRIV             184,690,700,726,766,775,795,804,84
                                                                                                  5,848,896,922,931,997,1007,1024,10
                                                                                                  41,1055,1158,1163,1171,1181,1209,1
                                                                                                  212,1218,1223,1241,1243,1285,1290,
                                                                                                  1295,1300,1303,1517,1567,1573,1624
                                                                                                  ,1630,1746,1825,1903,6031,6166,617
                                                                                                  3,6180,6187                       
 MPP_ERROR_BASIC            Subr   690                                           PRIV             690,700,726,766,775,795,804,845,84
                                                                                                  8,896,922,931,997,1007,1024,1041,1
                                                                                                  055,1158,1163,1171,1181,1209,1212,
                                                                                                  1218,1223,1241,1243,1285,1290,1295
                                                                                                  ,1300,1303,1517,1567,1573,1624,163
                                                                                                  0,1746,1825,1903,6031,6166,6173,61
                                                                                                  80,6187                           
 MPP_IO_INIT                Subr   677                                           PRIV             193,677                           
 MPP_PE                     Func   688      I(4)            4           scalar   PRIV             188,688,761,1005,1054,1308,1346   
 MPP_ROOT_PE                Func   688      I(4)            4           scalar   PRIV             189,688,761,1054,1308,1346        
 NAME_STR                   Local  639      CHAR            512         scalar                    858,874,885,891,957,959,974,976   
 NFIELDS                    Dummy  606      I(4)            4           scalar   ARG,OUT          667,694,1027                      
 NOTE                       Param  690      I(4)            4           scalar   PRIV             186,690,766                       
 NOTE_HEADER                Param  629      CHAR            64          scalar                    766                               
 NO_FIELD                   Param  774      I(4)            4           scalar                    318,774,1431,1459,3050,3069,4335,4
                                                                                                  381,4393,4490,4511,4530,4596,4610,
                                                                                                  4657,4669,4725,4745,4765,4825,4839
                                                                                                  ,4892,4904,4961,4981,5001,5071,508
                                                                                                  4,5128,5139,5196,5217,5236,5297,53
                                                                                                  12,5365,5376                      
 NUM_FIELDS                 Local  667      I(4)            4           scalar                    577,667,674,798,804,805,806,807,80
                                                                                                  8,853,854,855,864,868,871,880,881,
                                                                                                  882,992,996,1027,1050,1051,1052,10
                                                                                                  53,1433,1517,1567,1623            
 PRESENT                    Func   667                                  scalar                    667,679,694,1027                  
 RECORD                     Local  635      CHAR            1024        scalar                    705,706,707,708,714,726,731,737,74
                                                                                                  3,751,812,817,819,821,823,824,827,

Page 22          Source Listing                  FIELD_MANAGER_INIT
2021-06-01 08:55 Symbol Table                    field_manager.F90

 Name                       Object Declared Type            Bytes Dimen Elements Attributes       References                        
                                                                                                                                    
                                                                                                  829,832,833,845,852,863,879,889,89
                                                                                                  6,1013,1014,1041                  
 STARTCONT                  Local  654      I(4)            4           scalar                    968,981,983                       
 STDLOG                     Func   703      I(4)            4           scalar   PRIV             190,703,1347                      
 SUB_NAME                   Param  624      CHAR            18          scalar                    626,628,630                       
 TABLE_NAME                 Dummy  606      CHAR            128         scalar   ARG,IN           679,682                           
 TBL_NAME                   Local  642      CHAR            128         scalar                    680,682,684,691,699,700,1024      
 TEXT_METHOD                Local  661      METHOD_TYPE     384         scalar                    852,853,854,855,857,858,859       
 TEXT_METHOD_SHORT          Local  660      METHOD_TYPE_SHORT                                                                       
                                                            256         scalar                    863,865,869,873,875               
 TEXT_METHOD_VERY_SHORT     Local  662      METHOD_TYPE_VERY_SHORT                                                                  
                                                            128         scalar                    879,880,886                       
 TEXT_NAMES                 Local  659      FIELD_NAMES_TYPE                                                                        
                                                            224         scalar                    731,732,733,734,738,739,740,744,74
                                                                                                  5,746,750,751,752,759,760,778,795,
                                                                                                  806,807                           
 TEXT_NAMES_SHORT           Local  658      FIELD_NAMES_TYPE_SHORT                                                                  
                                                            96          scalar                    737,738,739,740,743,744,745,746   
 TRIM                       Func   625                                  scalar                    625,626,627,628,629,630,682,684,69
                                                                                                  0,691,699,700,726,732,733,734,738,
                                                                                                  739,740,744,745,746,751,759,760,76
                                                                                                  6,775,795,804,806,807,845,848,853,
                                                                                                  854,855,865,869,880,896,922,924,93
                                                                                                  1,933,957,959,972,974,976,980,981,
                                                                                                  983,985,997,1007,1024,1041        
 TYPE_STR                   Local  640      CHAR            512         scalar                    857,873,884,890,955,972           
 VAL_NAME                   Local  641      CHAR            512         scalar                    961,963,985,987                   
 VERB                       Local  689      I(4)            4           scalar                    578,689,762,1006,1028,1237,1309,20
                                                                                                  10,2019,2136,2139,2232,2635,2648,2
                                                                                                  664,2804,2848,2921,3047,3066,3215,
                                                                                                  3240,3308,3329,3407,3437,3449,3468
                                                                                                  ,3480,3530,3561,3574,3594,3606,365
                                                                                                  6,3688,3702,3723,3735,3785,3815,38
                                                                                                  28,3851,3863,3952,3977,4172,4332,4
                                                                                                  377,4389,4487,4507,4525,4564,4592,
                                                                                                  4605,4652,4664,4722,4741,4760,4793
                                                                                                  ,4821,4835,4887,4899,4958,4977,499
                                                                                                  6,5042,5067,5079,5124,5135,5193,52
                                                                                                  13,5231,5265,5293,5307,5360,5372,5
                                                                                                  748,5762,5887,5958,5963,6007,6141,
                                                                                                  6286,6376,6381,6453,6519,6521,6523
                                                                                                  ,6528,6529,6531,6538              
 VERB_LEVEL_NOTE            Local  762      I(4)            4           scalar                    580,762,1309,2648                 
 VERB_LEVEL_WARN            Local  689      I(4)            4           scalar                    579,689,1006,1028,1237,2010,2019,2
                                                                                                  136,2139,2232,2635,2664,2804,2848,
                                                                                                  2921,3047,3066,3215,3240,3308,3329
                                                                                                  ,3407,3437,3449,3468,3480,3530,356
                                                                                                  1,3574,3594,3606,3656,3688,3702,37
                                                                                                  23,3735,3785,3815,3828,3851,3863,3
                                                                                                  952,3977,4172,4332,4377,4389,4487,
                                                                                                  4507,4525,4564,4592,4605,4652,4664
                                                                                                  ,4722,4741,4760,4793,4821,4835,488
                                                                                                  7,4899,4958,4977,4996,5042,5067,50
                                                                                                  79,5124,5135,5193,5213,5231,5265,5
                                                                                                  293,5307,5360,5372,5748,5762,5887,

Page 23          Source Listing                  FIELD_MANAGER_INIT
2021-06-01 08:55 Symbol Table                    field_manager.F90

 Name                       Object Declared Type            Bytes Dimen Elements Attributes       References                        
                                                                                                                                    
                                                                                                  5958,5963,6007,6141,6286,6376,6381
                                                                                                  ,6453                             
 VERSION                    Param  702      CHAR            7           scalar                    702,1345                          
 WARNING                    Param  1007     I(4)            4           scalar   PRIV             187,1007,1055,1241,1243           
 WARN_HEADER                Param  627      CHAR            64          scalar                    690,1007                          
 WRITE_VERSION_NUMBER       Subr   702                                           PRIV             195,702,1345                      


TYPE COMPONENTS/COMMON VARIABLES

 Name                       Type            Bytes Offset   Dimen Elements Attributes       References                         
                                                                                                                              
 FIELD_MGR_TYPE.FIELD_NAME  CHAR            128   48             scalar                    806,1053,1057,1434,1520            
 FIELD_MGR_TYPE.FIELD_TYPE  CHAR            48    0              scalar                    807,1051,1055,1519                 
 FIELD_MGR_TYPE.METHODS     RECORD          384   184      1     250                       853,854,855,864,868,871,880,881,88 
                                                                                           2,1575,1633                        
 FIELD_MGR_TYPE.MODEL       I(4)            4     176            scalar                    805,1052,1056,1434,1521            
 FIELD_MGR_TYPE.NUM_METHODS I(4)            4     180            scalar                    808,992,996,1522,1573,1629,1633    
 FIELD_NAMES_TYPE.FLD_NAME  CHAR            128   96             scalar                    734,740,746,752,760,806            
 FIELD_NAMES_TYPE.FLD_TYPE  CHAR            48    0              scalar                    732,738,744,750,759,807            
 FIELD_NAMES_TYPE.MOD_NAME  CHAR            48    48             scalar                    733,739,745,751,759,778,795        
 FIELD_NAMES_TYPE_SHORT.FLD_TYPE                                                                                           ...
                            CHAR            48    0              scalar                    738,744                            
 FIELD_NAMES_TYPE_SHORT.MOD_NAME                                                                                           ...
                            CHAR            48    48             scalar                    739,740,745,746                    
 METHOD_TYPE.METHOD_CONTROL CHAR            128   256            scalar                    855,859,871,882,1033               
 METHOD_TYPE.METHOD_NAME    CHAR            128   128            scalar                    854,858,868,881,1032               
 METHOD_TYPE.METHOD_TYPE    CHAR            128   0              scalar                    853,857,864,880,1031               
 METHOD_TYPE_SHORT.METHOD_NAME                                                                                             ...
                            CHAR            128   128            scalar                    869,875                            
 METHOD_TYPE_SHORT.METHOD_TYPE                                                                                             ...
                            CHAR            128   0              scalar                    865,873                            
 METHOD_TYPE_VERY_SHORT.METHOD_TYPE                                                                                        ...
                            CHAR            128   0              scalar                    880,886                            

Page 24          Source Listing                  FIELD_MANAGER_INIT
2021-06-01 08:55                                 field_manager.F90

   1044 ! </SUBROUTINE>
   1045 
   1046 subroutine check_for_name_duplication
   1047 integer :: i
   1048 
   1049 ! Check that name is unique amoung fields of the same field_type and model.
   1050 do i=1,num_fields-1
   1051   if ( fields(i)%field_type == fields(num_fields)%field_type .and. &
   1052        fields(i)%model      == fields(num_fields)%model      .and. &
   1053        fields(i)%field_name == fields(num_fields)%field_name ) then
   1054     if (mpp_pe() .eq. mpp_root_pe()) then
   1055       call mpp_error(WARNING,'Error in field_manager_mod. Duplicate field name: Field type='//trim(fields(i)%field_type)// &
   1056          ',  Model='//trim(MODEL_NAMES(fields(i)%model))// &
   1057          ',  Duplicated name='//trim(fields(i)%field_name))
   1058     endif
   1059   endif
   1060 enddo
   1061 
   1062 end subroutine check_for_name_duplication


ENTRY POINTS

  Name                                                        
                                                              
 field_manager_mod_mp_check_for_name_duplication_             


SYMBOL CROSS REFERENCE

 Name                       Object Declared Type            Bytes Dimen Elements Attributes       References                        
                                                                                                                                    
 CHECK_FOR_NAME_DUPLICATION Subr   1046                                                           809                               
 I                          Local  1047     I(4)            4           scalar                    1050,1051,1052,1053,1055,1056,1057
 MODEL_NAMES                Param  1056     CHAR            11    1     5                         343,1056                          
 TRIM                       Func   1055                                 scalar                    1055,1056,1057                    

Page 25          Source Listing                  CHECK_FOR_NAME_DUPLICATION
2021-06-01 08:55                                 field_manager.F90

   1063 
   1064 !#######################################################################
   1065 !#######################################################################
   1066 
   1067 ! <PRIVATE><SUBROUTINE NAME="new_name">
   1068 !   <OVERVIEW>
   1069 !     Subroutine to add new values to list parameters.
   1070 !   </OVERVIEW>
   1071 !   <DESCRIPTION>
   1072 !     This subroutine uses input strings list_name, method_name
   1073 !     and val_name_in to add new values to the list. Given
   1074 !     list_name a new list item is created that is named
   1075 !     method_name and is given the value or values in
   1076 !     val_name_in. If there is more than 1 value in
   1077 !     val_name_in, these values should be  comma-separated.
   1078 !   </DESCRIPTION>
   1079 !   <TEMPLATE>
   1080 !     call new_name ( list_name, method_name , val_name_in)
   1081 !   </TEMPLATE>
   1082 subroutine new_name ( list_name, method_name_in , val_name_in)
   1083 !   <IN NAME="list_name" TYPE="character(len=*)">
   1084 !     The name of the field that is of interest here.
   1085 !   </IN>
   1086 !   <IN NAME="method_name" TYPE="character(len=*)">
   1087 !     The name of the method that values are being supplied for.
   1088 !   </IN>
   1089 character(len=*), intent(in)    :: list_name
   1090 character(len=*), intent(in)    :: method_name_in
   1091 !   <INOUT NAME="val_name_in" TYPE="character(len=*)">
   1092 !     The value or values that will be parsed and used as the value when
   1093 !     creating a new field or fields.
   1094 !   </INOUT>
   1095 character(len=*), intent(inout) :: val_name_in
   1096 
   1097 !+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   1098 !        local parameters
   1099 !+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   1100 character(len=8),  parameter :: sub_name     = 'new_name'
   1101 character(len=64), parameter :: error_header = '==>Error from ' // trim(module_name)   //  &
   1102                                                '(' // trim(sub_name) // '): '
   1103 character(len=64), parameter :: warn_header  = '==>Warning from ' // trim(module_name) //  &
   1104                                                '(' // trim(sub_name) // '): '
   1105 character(len=64), parameter :: note_header  = '==>Note from ' // trim(module_name)    //  &
   1106                                                '(' // trim(sub_name) // '): '
   1107 
   1108 !+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   1109 !        local variables
   1110 !+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   1111 character(len=fm_string_len)   :: method_name
   1112 character(len=fm_string_len)   :: val_list
   1113 character(len=fm_string_len)   :: val_name
   1114 integer, dimension(MAX_FIELDS) :: end_val
   1115 integer, dimension(MAX_FIELDS) :: start_val
   1116 integer                        :: i
   1117 integer                        :: index_t
   1118 integer                        :: left_br
   1119 integer                        :: num_elem

Page 26          Source Listing                  NEW_NAME
2021-06-01 08:55                                 field_manager.F90

   1120 integer                        :: out_unit
   1121 integer                        :: right_br
   1122 integer                        :: val_int
   1123 integer                        :: val_type
   1124 logical                        :: append_new
   1125 logical                        :: val_logic
   1126 real                           :: val_real
   1127 integer                        :: length
   1128 
   1129 call strip_front_blanks(val_name_in)
   1130 method_name = trim (method_name_in)
   1131 call strip_front_blanks(method_name)
   1132 
   1133 index_t  = 1
   1134 num_elem = 1
   1135 append_new = .false.
   1136 start_val(1) = 1
   1137 end_val(:) = len_trim(val_name_in)
   1138 
   1139 ! If the array of values being passed in is a comma delimited list then count
   1140 ! the number of elements.
   1141 
   1142 do i = 1, len_trim(val_name_in)
   1143   if ( val_name_in(i:i) == comma ) then
   1144     end_val(num_elem) = i-1
   1145     start_val(num_elem+1) = i+1
   1146     num_elem = num_elem + 1
   1147   endif
   1148 enddo
   1149 
   1150 ! Check to see if this is an array element of form array[x] = value
   1151 left_br  = scan(method_name,'[')
   1152 right_br = scan(method_name,']')
   1153 if ( num_elem .eq. 1 ) then
   1154 !     <ERROR MSG="Left bracket present without right bracket in method_name" STATUS="FATAL">
   1155 !       When using an array element an unpaired bracket was found.
   1156 !     </ERROR>
   1157   if ( left_br > 0 .and. right_br == 0 ) &
   1158     call mpp_error(FATAL, trim(error_header)//"Left bracket present without right bracket in "//trim(method_name))
   1159 !     <ERROR MSG="Right bracket present without left bracket in method_name" STATUS="FATAL">
   1160 !       When using an array element an unpaired bracket was found.
   1161 !     </ERROR>
   1162   if ( left_br== 0 .and. right_br > 0 ) &
   1163     call mpp_error(FATAL, trim(error_header)//"Right bracket present without left bracket in "//trim(method_name))
   1164 
   1165 
   1166   if ( left_br > 0 .and. right_br > 0 ) then
   1167 !     <ERROR MSG="Using a non-numeric value for index in method_name" STATUS="FATAL">
   1168 !       An array assignment was requested but a non-numeric value was found. i.e. array[a] = 1
   1169 !     </ERROR>
   1170     if ( scan( method_name(left_br+1:right_br -1), set ) > 0 ) &
   1171        call mpp_error(FATAL, trim(error_header)//"Using a non-numeric value for index in "//trim(method_name))
   1172     read(method_name(left_br+1:right_br -1), *) index_t
   1173     method_name = method_name(:left_br -1)
   1174   endif
   1175 else
   1176 ! If there are multiple values then there cannot be a bracket in method_name.

Page 27          Source Listing                  NEW_NAME
2021-06-01 08:55                                 field_manager.F90

   1177 !     <ERROR MSG="Using a comma delimited list with an indexed array element in method_name" STATUS="FATAL">
   1178 !       When supplying multiple values an index was found. i.e array[3] = 4,5,6 is invalid.
   1179 !     </ERROR>
   1180   if ( left_br > 0 .or. right_br > 0 ) &
   1181     call mpp_error(FATAL, &
   1182       trim(error_header)//"Using a comma delimited list with an indexed array element in "//trim(method_name))
   1183 
   1184 endif
   1185 
   1186 do i = 1, num_elem
   1187 
   1188   if ( i .gt. 1 .or. index_t .eq. 0 ) then
   1189     append_new = .true.
   1190     index_t = 0 ! If append is true then index must be <= 0
   1191   endif
   1192   val_type = string_type  ! Assume it is a string
   1193   val_name = val_name_in(start_val(i):end_val(i))
   1194   call strip_front_blanks(val_name)
   1195 
   1196 
   1197 !
   1198 !       if the string starts and ends with matching single quotes, then this is a string
   1199 !       if there are quotes which do not match, then this is an error
   1200 !
   1201 
   1202   length = len_trim(val_name)
   1203   if (val_name(1:1) .eq. squote) then  !{
   1204 
   1205     if (val_name(length:length) .eq. squote) then
   1206       val_name = val_name(2:length-1)//repeat(" ",len(val_name)-length+2)
   1207       val_type = string_type
   1208     elseif (val_name(length:length) .eq. dquote) then
   1209       call mpp_error(FATAL, trim(error_header) // ' Quotes do not match in ' // trim(val_name) //       &
   1210            ' for ' // trim(method_name) // ' of ' // trim(list_name))
   1211     else
   1212       call mpp_error(FATAL, trim(error_header) // ' No trailing quote in ' // trim(val_name) //         &
   1213            ' for ' // trim(method_name) // ' of ' // trim(list_name))
   1214     endif
   1215 
   1216   elseif (val_name(1:1) .eq. dquote .or. val_name(length:length) .eq. dquote) then  !}{
   1217 
   1218     call mpp_error(FATAL, trim(error_header) // ' Double quotes not allowed in ' // trim(val_name) //   &
   1219          ' for ' // trim(method_name) // ' of ' // trim(list_name))
   1220 
   1221   elseif (val_name(length:length) .eq. squote) then  !}{
   1222 
   1223     call mpp_error(FATAL, trim(error_header) // ' No leading quote in ' // trim(val_name) //            &
   1224          ' for ' // trim(method_name) // ' of ' // trim(list_name))
   1225 
   1226   else  !}{
   1227 ! If the string to be parsed is a real then all the characters must be numeric,
   1228 ! be a plus/minus, be a decimal point or, for exponentials, be e or E.
   1229 
   1230 ! If a string is an integer, then all the characters must be numeric.
   1231 
   1232   if ( scan(val_name(1:1), setnum ) > 0 ) then
   1233 

Page 28          Source Listing                  NEW_NAME
2021-06-01 08:55                                 field_manager.F90

   1234 ! If there is a letter in the name it may only be e or E
   1235 
   1236       if ( scan(val_name, set_nonexp ) > 0 ) then
   1237         if (verb .gt. verb_level_warn) then
   1238 !     <ERROR MSG="First character of value is numerical but the value does not appear to be numerical." STATUS="WARNING">
   1239 !       The value may not be numerical. This is a warning as the user may wish to use a value of 2nd_order.
   1240 !     </ERROR>
   1241           call mpp_error(WARNING, trim(warn_header)//                                  &
   1242                'First character of value is numerical but the value does not appear to be numerical.')
   1243           call mpp_error(WARNING, 'Name = '// trim(list_name)// list_sep//                &
   1244                trim(method_name)// ' Value = '// trim(val_name))
   1245         endif
   1246 
   1247       else
   1248 ! It is real if there is a . in the name or the value appears exponential
   1249         if ( scan(val_name, '.') > 0 .or. scan(val_name, 'e') > 0 .or. scan(val_name, 'E') > 0) then
   1250           read(val_name, *) val_real
   1251           val_type = real_type
   1252         else
   1253           read(val_name, *) val_int
   1254           val_type = integer_type
   1255         endif
   1256       endif
   1257 
   1258     endif
   1259 
   1260 ! If val_name is t/T or f/F then this is a logical flag.
   1261     if ( len_trim(val_name) == 1 .or. len_trim(val_name) == 3) then
   1262        if ( val_name == 't' .or. val_name == 'T' .or. val_name == '.t.' .or. val_name == '.T.' ) then
   1263          val_logic = .TRUE.
   1264          val_type = logical_type
   1265        endif
   1266        if ( val_name == 'f' .or. val_name == 'F' .or. val_name == '.f.' .or. val_name == '.F.' ) then
   1267          val_logic = .FALSE.
   1268          val_type = logical_type
   1269        endif
   1270     endif
   1271     if ( trim(lowercase(val_name)) == 'true' .or. trim(lowercase(val_name)) == '.true.' ) then
   1272       val_logic = .TRUE.
   1273       val_type = logical_type
   1274     endif
   1275     if ( trim(lowercase(val_name)) == 'false' .or. trim(lowercase(val_name)) == '.false.' ) then
   1276       val_logic = .FALSE.
   1277       val_type = logical_type
   1278     endif
   1279   endif  !}
   1280 
   1281   select case(val_type)
   1282 
   1283     case (integer_type)
   1284       if ( fm_new_value( method_name, val_int, create = .true., index = index_t, append = append_new ) < 0 ) &
   1285         call mpp_error(FATAL, trim(error_header)//'Could not set "' // trim(val_name) // '" for '//trim(method_name)//&
   1286                               ' (I) for '//trim(list_name))
   1287 
   1288     case (logical_type)
   1289       if ( fm_new_value( method_name, val_logic, create = .true., index = index_t, append = append_new) < 0 ) &
   1290         call mpp_error(FATAL, trim(error_header)//'Could not set "' // trim(val_name) // '" for '//trim(method_name)//&

Page 29          Source Listing                  NEW_NAME
2021-06-01 08:55                                 field_manager.F90

   1291                               ' (L) for '//trim(list_name))
   1292 
   1293     case (real_type)
   1294       if ( fm_new_value( method_name, val_real, create = .true., index = index_t, append = append_new) < 0 ) &
   1295         call mpp_error(FATAL, trim(error_header)//'Could not set "' // trim(val_name) // '" for '//trim(method_name)//&
   1296                               ' (R) for '//trim(list_name))
   1297 
   1298     case (string_type)
   1299       if ( fm_new_value( method_name, val_name, create = .true., index = index_t, append = append_new) < 0 ) &
   1300         call mpp_error(FATAL, trim(error_header)//'Could not set "' // trim(val_name) // '" for '//trim(method_name)//&
   1301                               ' (S) for '//trim(list_name))
   1302     case default
   1303       call mpp_error(FATAL, trim(error_header)//'Could not find a valid type to set the '//trim(method_name)//&
   1304                             ' for '//trim(list_name))
   1305 
   1306   end select
   1307 
   1308   if (mpp_pe() == mpp_root_pe() ) then
   1309     if (verb .gt. verb_level_note) then
   1310       out_unit = stdout()
   1311       write (out_unit,*) trim(note_header), 'Creating new value = ', trim(method_name), ' ', trim(val_name)
   1312     endif
   1313   endif
   1314 
   1315 enddo
   1316 
   1317 end subroutine new_name


ENTRY POINTS

  Name                                      
                                            
 field_manager_mod_mp_new_name_             

Page 30          Source Listing                  NEW_NAME
2021-06-01 08:55 Symbol Table                    field_manager.F90



SYMBOL CROSS REFERENCE

 Name                       Object Declared Type            Bytes Dimen Elements Attributes       References                        
                                                                                                                                    
 APPEND_NEW                 Local  1124     L(4)            4           scalar                    1135,1189,1284,1289,1294,1299     
 END_VAL                    Local  1114     I(4)            4     1     250                       1137,1144,1193                    
 ERROR_HEADER               Param  1101     CHAR            64          scalar                    1158,1163,1171,1182,1209,1212,1218
                                                                                                  ,1223,1285,1290,1295,1300,1303    
 FM_NEW_VALUE               Local  1284                                 scalar                    265,1284,1289,1294,1299,6164,6171,
                                                                                                  6178,6185                         
 FM_NEW_VALUE_INTEGER       Func   1284     I(4)            4           scalar                    266,1284,6164                     
 FM_NEW_VALUE_LOGICAL       Func   1289     I(4)            4           scalar                    267,1289,6171                     
 FM_NEW_VALUE_REAL          Func   1294     I(4)            4           scalar                    268,1294,4557,6178                
 FM_NEW_VALUE_STRING        Func   1299     I(4)            4           scalar                    269,1299,6185                     
 I                          Local  1116     I(4)            4           scalar                    1142,1143,1144,1145,1186,1188,1193
 INDEX_T                    Local  1117     I(4)            4           scalar                    1133,1172,1188,1190,1284,1289,1294
                                                                                                  ,1299                             
 INTEGER_TYPE               Param  1254     I(4)            4           scalar                    1254,1283,2169,3431,4559,4568,4575
                                                                                                  ,5027,5646,5988,6162,6412         
 LEFT_BR                    Local  1118     I(4)            4           scalar                    1151,1157,1162,1166,1170,1172,1173
                                                                                                  ,1180                             
 LEN                        Func   1206                                 scalar                    1206                              
 LENGTH                     Local  1127     I(4)            4           scalar                    1202,1205,1206,1208,1216,1221     
 LEN_TRIM                   Func   1137                                 scalar                    1137,1142,1202,1261               
 LIST_NAME                  Dummy  1082     CHAR                        scalar   ARG,IN           1210,1213,1219,1224,1243,1286,1291
                                                                                                  ,1296,1301,1304                   
 LOGICAL_TYPE               Param  1264     I(4)            4           scalar                    1264,1268,1273,1277,1288,2185,3554
                                                                                                  ,4790,4797,4804,5648,5992,6169,642
                                                                                                  2                                 
 METHOD_NAME                Local  1111     CHAR            128         scalar                    1130,1131,1151,1152,1158,1163,1170
                                                                                                  ,1171,1172,1173,1182,1210,1213,121
                                                                                                  9,1224,1244,1284,1285,1289,1290,12
                                                                                                  94,1295,1299,1300,1303,1311       
 METHOD_NAME_IN             Dummy  1082     CHAR                        scalar   ARG,IN           1130                              
 NEW_NAME                   Subr   1082                                                           963,987                           
 NOTE_HEADER                Param  1105     CHAR            64          scalar                    1311                              
 NUM_ELEM                   Local  1119     I(4)            4           scalar                    1134,1144,1145,1146,1153,1186     
 OUT_UNIT                   Local  1120     I(4)            4           scalar                    1310,1311                         
 REAL_TYPE                  Param  1251     I(4)            4           scalar                    1251,1293,2201,3680,4555,5033,5035
                                                                                                  ,5046,5053,5649,5996,6176,6430    
 REPEAT                     Func   1206                                 scalar                    1206                              
 RIGHT_BR                   Local  1121     I(4)            4           scalar                    1152,1157,1162,1166,1170,1172,1180
 SCAN                       Func   1151                                 scalar                    1151,1152,1170,1232,1236,1249     
 SET                        Local  1170     CHAR            52          scalar                    570,1170                          
 SETNUM                     Local  1232     CHAR            13          scalar                    576,1232                          
 SET_NONEXP                 Local  1236     CHAR            50          scalar                    573,1236                          
 SQUOTE                     Param  1203     CHAR            1           scalar                    1203,1205,1221                    
 START_VAL                  Local  1115     I(4)            4     1     250                       1136,1145,1193                    
 STDOUT                     Func   1310     I(4)            4           scalar   PRIV             191,1310,1349,2007,2577,2799,2903,
                                                                                                  3036,3204,3297,3396,3519,3645,3774
                                                                                                  ,3939,4137,4321,4476,4711,4947,518
                                                                                                  2,5737,5845,5954,6110,6255,6371,65
                                                                                                  10                                
 STRING_TYPE                Param  1192     I(4)            4           scalar                    1192,1207,1298,2217,3809,5262,5269
                                                                                                  ,5276,5650,6000,6183,6441         

Page 31          Source Listing                  NEW_NAME
2021-06-01 08:55 Symbol Table                    field_manager.F90

 Name                       Object Declared Type            Bytes Dimen Elements Attributes       References                        
                                                                                                                                    
 SUB_NAME                   Param  1100     CHAR            8           scalar                    1102,1104,1106                    
 TRIM                       Func   1101                                 scalar                    1101,1102,1103,1104,1105,1106,1130
                                                                                                  ,1158,1163,1171,1182,1209,1210,121
                                                                                                  2,1213,1218,1219,1223,1224,1241,12
                                                                                                  43,1244,1271,1275,1285,1286,1290,1
                                                                                                  291,1295,1296,1300,1301,1303,1304,
                                                                                                  1311                              
 VAL_INT                    Local  1122     I(4)            4           scalar                    1253,1284                         
 VAL_LIST                   Local  1112     CHAR            128         scalar                                                      
 VAL_LOGIC                  Local  1125     L(4)            4           scalar                    1263,1267,1272,1276,1289          
 VAL_NAME                   Local  1113     CHAR            128         scalar                    1193,1194,1202,1203,1205,1206,1208
                                                                                                  ,1209,1212,1216,1218,1221,1223,123
                                                                                                  2,1236,1244,1249,1250,1253,1261,12
                                                                                                  62,1266,1271,1275,1285,1290,1295,1
                                                                                                  299,1300,1311                     
 VAL_NAME_IN                Dummy  1082     CHAR                        scalar   ARG,INOUT        1129,1137,1142,1143,1193          
 VAL_REAL                   Local  1126     R(8)            8           scalar                    1250,1294                         
 VAL_TYPE                   Local  1123     I(4)            4           scalar                    1192,1207,1251,1254,1264,1268,1273
                                                                                                  ,1277,1281                        
 WARN_HEADER                Param  1103     CHAR            64          scalar                    1241                              

Page 32          Source Listing                  NEW_NAME
2021-06-01 08:55                                 field_manager.F90

   1318 !</SUBROUTINE>
   1319 !</PRIVATE>
   1320 !#######################################################################
   1321 !#######################################################################
   1322 
   1323 ! <SUBROUTINE NAME="field_manager_end">
   1324 !   <OVERVIEW>
   1325 !     Destructor for field manager.
   1326 !   </OVERVIEW>
   1327 !   <DESCRIPTION>
   1328 !     This subroutine writes to the logfile that the user is exiting field_manager and
   1329 !     changes the initialized flag to false.
   1330 !   </DESCRIPTION>
   1331 !   <TEMPLATE>
   1332 !     call field_manager_end
   1333 !   </TEMPLATE>
   1334 subroutine field_manager_end
   1335 
   1336 !+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   1337 !        local parameters
   1338 !+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   1339 character(len=17), parameter :: sub_name     = 'field_manager_end'
   1340 character(len=64), parameter :: note_header  = '==>Note from ' // trim(module_name)    //  &
   1341                                                '(' // trim(sub_name) // '): '
   1342 
   1343 integer :: unit
   1344 
   1345 call write_version_number("FIELD_MANAGER_MOD", version)
   1346 if ( mpp_pe() == mpp_root_pe() ) then
   1347    unit = stdlog()
   1348    write (unit,'(/,(a))') trim(note_header), 'Exiting field_manager, have a nice day ...'
   1349    unit = stdout()
   1350    write (unit,'(/,(a))') trim(note_header), 'Exiting field_manager, have a nice day ...'
   1351 endif
   1352 
   1353 module_is_initialized = .false.
   1354 
   1355 end subroutine field_manager_end

Page 33          Source Listing                  FIELD_MANAGER_END
2021-06-01 08:55 Entry Points                    field_manager.F90



ENTRY POINTS

  Name                                               
                                                     
 field_manager_mod_mp_field_manager_end_             


SYMBOL CROSS REFERENCE

 Name                       Object Declared Type            Bytes Dimen Elements Attributes       References                        
                                                                                                                                    
 FIELD_MANAGER_END          Subr   1334                                                                                             
 NOTE_HEADER                Param  1340     CHAR            64          scalar                    1348,1350                         
 SUB_NAME                   Param  1339     CHAR            17          scalar                    1341                              
 TRIM                       Func   1340                                 scalar                    1340,1341,1348,1350               
 UNIT                       Local  1343     I(4)            4           scalar                    1347,1348,1349,1350               

Page 34          Source Listing                  FIELD_MANAGER_END
2021-06-01 08:55                                 field_manager.F90

   1356 ! </SUBROUTINE>
   1357 
   1358 !#######################################################################
   1359 !#######################################################################
   1360 
   1361 ! <SUBROUTINE NAME="strip_front_blanks">
   1362 !   <OVERVIEW>
   1363 !     A routine to strip whitespace from the start of character strings.
   1364 !   </OVERVIEW>
   1365 !   <DESCRIPTION>
   1366 !     This subroutine removes spaces and tabs from the start of a character string.
   1367 !   </DESCRIPTION>
   1368 !   <TEMPLATE>
   1369 !     call strip_front_blanks(name)
   1370 !   </TEMPLATE>
   1371 subroutine strip_front_blanks(name)
   1372 
   1373 character(len=*), intent(inout) :: name
   1374 
   1375 !+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   1376 !        local parameters
   1377 !+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   1378 
   1379 integer :: i, j
   1380 
   1381 j = 1
   1382 do i = 1,len_trim(name) !{
   1383    if ( .not. (name(i:i) .eq. space .or.                        &
   1384                name(i:i) .eq. tab)) then  !{
   1385     j = i
   1386     exit
   1387   endif !}
   1388 enddo !}
   1389 name = name(j:)
   1390 end subroutine strip_front_blanks

Page 35          Source Listing                  STRIP_FRONT_BLANKS
2021-06-01 08:55 Entry Points                    field_manager.F90



ENTRY POINTS

  Name                                                
                                                      
 field_manager_mod_mp_strip_front_blanks_             


SYMBOL CROSS REFERENCE

 Name                       Object Declared Type            Bytes Dimen Elements Attributes       References                        
                                                                                                                                    
 I                          Local  1379     I(4)            4           scalar                    1382,1383,1384,1385               
 J                          Local  1379     I(4)            4           scalar                    1381,1385,1389                    
 LEN_TRIM                   Func   1382                                 scalar                    1382                              
 NAME                       Dummy  1371     CHAR                        scalar   ARG,INOUT        1382,1383,1384,1389               
 SPACE                      Param  1383     CHAR            1           scalar                    1383                              
 STRIP_FRONT_BLANKS         Subr   1371                                                           1129,1131,1194,6414,6433          
 TAB                        Param  1384     CHAR            1           scalar                    1384                              

Page 36          Source Listing                  STRIP_FRONT_BLANKS
2021-06-01 08:55                                 field_manager.F90

   1391 !</SUBROUTINE>
   1392 
   1393 !#######################################################################
   1394 !#######################################################################
   1395 
   1396 ! <FUNCTION NAME="find_field_index">
   1397 !   <OVERVIEW>
   1398 !     Function to return the index of the field.
   1399 !   </OVERVIEW>
   1400 !   <DESCRIPTION>
   1401 !     This function when passed a model number and a field name will
   1402 !     return the index of the field within the field manager. This index
   1403 !     can be used to access other information from the field manager.
   1404 !   </DESCRIPTION>
   1405 !   <TEMPLATE>
   1406 !     value=find_field_index( model, field_name )
   1407 !     value=find_field_index( field_name )
   1408 !   </TEMPLATE>
   1409 
   1410 function find_field_index_old(model, field_name)
   1411 !
   1412 !   <IN NAME="model" TYPE="integer">
   1413 !     The number indicating which model is used.
   1414 !   </IN>
   1415 !   <IN NAME="field_name" TYPE="character">
   1416 !     The name of the field that an index is being requested for.
   1417 !   </IN>
   1418 !   <OUT NAME="find_field_index" TYPE="integer">
   1419 !     The index of the field corresponding to field_name.
   1420 !   </OUT>
   1421 
   1422 integer                      :: find_field_index_old
   1423 integer,          intent(in) :: model
   1424 character(len=*), intent(in) :: field_name
   1425 
   1426 !+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   1427 !        local parameters
   1428 !+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   1429 integer :: i
   1430 
   1431 find_field_index_old = NO_FIELD
   1432 
   1433 do i=1,num_fields
   1434    if (fields(i)%model == model .and. fields(i)%field_name == lowercase(field_name)) then
   1435       find_field_index_old = i
   1436       return
   1437    endif
   1438 enddo
   1439 
   1440 end function find_field_index_old

Page 37          Source Listing                  FIND_FIELD_INDEX_OLD
2021-06-01 08:55 Entry Points                    field_manager.F90



ENTRY POINTS

  Name                                                  
                                                        
 field_manager_mod_mp_find_field_index_old_             


SYMBOL CROSS REFERENCE

 Name                       Object Declared Type            Bytes Dimen Elements Attributes       References                        
                                                                                                                                    
 FIELD_NAME                 Dummy  1410     CHAR                        scalar   ARG,IN           1434                              
 FIND_FIELD_INDEX_OLD       Func   1410     I(4)            4           scalar                                                      
 I                          Local  1429     I(4)            4           scalar                    1433,1434,1435                    
 MODEL                      Dummy  1410     I(4)            4           scalar   ARG,IN           1434                              

Page 38          Source Listing                  FIND_FIELD_INDEX_OLD
2021-06-01 08:55                                 field_manager.F90

   1441 
   1442 function find_field_index_new(field_name)
   1443 !
   1444 !   <IN NAME="field_name" TYPE="character">
   1445 !     The path to the name of the field that an index is being requested for.
   1446 !   </IN>
   1447 !   <OUT NAME="find_field_index" TYPE="integer">
   1448 !     The index of the field corresponding to field_name.
   1449 !   </OUT>
   1450 
   1451 integer                      :: find_field_index_new
   1452 character(len=*), intent(in) :: field_name
   1453 
   1454 !+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   1455 !        local parameters
   1456 !+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   1457 integer :: i
   1458 
   1459 find_field_index_new = NO_FIELD
   1460 
   1461 find_field_index_new = fm_get_index(field_name)
   1462 
   1463 end function find_field_index_new


ENTRY POINTS

  Name                                                  
                                                        
 field_manager_mod_mp_find_field_index_new_             

Page 39          Source Listing                  FIND_FIELD_INDEX_NEW
2021-06-01 08:55 Symbol Table                    field_manager.F90



SYMBOL CROSS REFERENCE

 Name                       Object Declared Type            Bytes Dimen Elements Attributes       References                        
                                                                                                                                    
 FIELD_NAME                 Dummy  1442     CHAR                        scalar   ARG,IN           1461                              
 FIND_FIELD_INDEX_NEW       Func   1442     I(4)            4           scalar                                                      
 FM_GET_INDEX               Func   1461     I(4)            4           scalar                    251,1461                          
 I                          Local  1457     I(4)            4           scalar                                                      

Page 40          Source Listing                  FIND_FIELD_INDEX_NEW
2021-06-01 08:55                                 field_manager.F90

   1464 ! </FUNCTION>
   1465 
   1466 !#######################################################################
   1467 !#######################################################################
   1468 
   1469 ! <SUBROUTINE NAME="get_field_info">
   1470 !   <OVERVIEW>
   1471 !     This routine allows access to field information given an index.
   1472 !   </OVERVIEW>
   1473 !   <DESCRIPTION>
   1474 !     When passed an index, this routine will return the type of field,
   1475 !     the name of the field, the model which the field is associated and
   1476 !     the number of methods associated with the field.
   1477 !   </DESCRIPTION>
   1478 !   <TEMPLATE>
   1479 !     call get_field_info( n,fld_type,fld_name,model,num_methods )
   1480 !   </TEMPLATE>
   1481 subroutine get_field_info(n,fld_type,fld_name,model,num_methods)
   1482 !
   1483 !   <IN NAME="n" TYPE="integer">
   1484 !     The field index.
   1485 !   </IN>
   1486 integer,          intent(in)  :: n
   1487 
   1488 !   <OUT NAME="fld_type" TYPE="character" DIM="(*)">
   1489 !     The field type.
   1490 !   </OUT>
   1491 
   1492 !   <OUT NAME="fld_name" TYPE="character" DIM="(*)">
   1493 !     The name of the field.
   1494 !   </OUT>
   1495 
   1496 !   <OUT NAME="model" TYPE="integer">
   1497 !     The number indicating which model is used.
   1498 !   </OUT>
   1499 
   1500 !   <OUT NAME="num_methods" TYPE="integer">
   1501 !     The number of methods.
   1502 !   </OUT>
   1503 character (len=*),intent(out) :: fld_type, fld_name
   1504 integer, intent(out) :: model, num_methods
   1505 
   1506 !+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   1507 !        local parameters
   1508 !+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   1509 character(len=14), parameter :: sub_name     = 'get_field_info'
   1510 character(len=64), parameter :: error_header = '==>Error from ' // trim(module_name)   //  &
   1511                                                '(' // trim(sub_name) // '): '
   1512 
   1513 !   <ERROR MSG="invalid field index" STATUS="FATAL">
   1514 !     The field index is invalid because it is less than 1 or greater than the
   1515 !     number of fields.
   1516 !   </ERROR>
   1517 if (n < 1 .or. n > num_fields) call mpp_error(FATAL,trim(error_header)//'Invalid field index')
   1518 
   1519 fld_type    = fields(n)%field_type
   1520 fld_name    = fields(n)%field_name

Page 41          Source Listing                  GET_FIELD_INFO
2021-06-01 08:55                                 field_manager.F90

   1521 model       = fields(n)%model
   1522 num_methods = fields(n)%num_methods
   1523 
   1524 end subroutine get_field_info


ENTRY POINTS

  Name                                            
                                                  
 field_manager_mod_mp_get_field_info_             


SYMBOL CROSS REFERENCE

 Name                       Object Declared Type            Bytes Dimen Elements Attributes       References                        
                                                                                                                                    
 ERROR_HEADER               Param  1510     CHAR            64          scalar                    1517                              
 FLD_NAME                   Dummy  1481     CHAR                        scalar   ARG,OUT          1520                              
 FLD_TYPE                   Dummy  1481     CHAR                        scalar   ARG,OUT          1519                              
 GET_FIELD_INFO             Subr   1481                                                                                             
 MODEL                      Dummy  1481     I(4)            4           scalar   ARG,OUT          1521                              
 N                          Dummy  1481     I(4)            4           scalar   ARG,IN           1517,1519,1520,1521,1522          
 NUM_METHODS                Dummy  1481     I(4)            4           scalar   ARG,OUT          1522                              
 SUB_NAME                   Param  1509     CHAR            14          scalar                    1511                              
 TRIM                       Func   1510                                 scalar                    1510,1511,1517                    

Page 42          Source Listing                  GET_FIELD_INFO
2021-06-01 08:55                                 field_manager.F90

   1525 ! </SUBROUTINE>
   1526 
   1527 !#######################################################################
   1528 !#######################################################################
   1529 
   1530 ! <SUBROUTINE NAME="get_field_method">
   1531 !   <OVERVIEW>
   1532 !     A routine to get a specified method.
   1533 !   </OVERVIEW>
   1534 !   <DESCRIPTION>
   1535 !     This routine, when passed a field index and a method index will
   1536 !     return the method text associated with the field(n) method(m).
   1537 !   </DESCRIPTION>
   1538 !   <TEMPLATE>
   1539 !     call get_field_method( n,m,method )
   1540 !   </TEMPLATE>
   1541 subroutine get_field_method(n,m,method)
   1542 !
   1543 !   <IN NAME="n" TYPE="integer">
   1544 !     The field index.
   1545 !   </IN>
   1546 !   <IN NAME="m" TYPE="integer">
   1547 !     The method index.
   1548 !   </IN>
   1549 !   <OUT NAME="method" TYPE="type(method_type)">
   1550 !     The m-th method of field with index n.
   1551 !   </OUT>
   1552 integer,           intent(in)    :: n
   1553 integer,           intent(in)    :: m
   1554 type(method_type) ,intent(inout) :: method
   1555 
   1556 !+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   1557 !        local parameters
   1558 !+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   1559 character(len=16), parameter :: sub_name     = 'get_field_method'
   1560 character(len=64), parameter :: error_header = '==>Error from ' // trim(module_name)   //  &
   1561                                                '(' // trim(sub_name) // '): '
   1562 
   1563 !   <ERROR MSG="invalid field index" STATUS="FATAL">
   1564 !     The field index is invalid because it is less than 1 or greater than the
   1565 !     number of fields.
   1566 !   </ERROR>
   1567 if (n < 1 .or. n > num_fields) call mpp_error(FATAL,trim(error_header)//'Invalid field index')
   1568 
   1569 !   <ERROR MSG="invalid method index" STATUS="FATAL">
   1570 !     The method index is invalid because it is less than 1 or greater than
   1571 !     the number of methods.
   1572 !   </ERROR>
   1573 if (m < 1 .or. m > fields(n)%num_methods) call mpp_error(FATAL,trim(error_header)//'Invalid method index')
   1574 
   1575   method = fields(n)%methods(m)
   1576 
   1577 end subroutine get_field_method

Page 43          Source Listing                  GET_FIELD_METHOD
2021-06-01 08:55 Entry Points                    field_manager.F90



ENTRY POINTS

  Name                                              
                                                    
 field_manager_mod_mp_get_field_method_             


SYMBOL CROSS REFERENCE

 Name                       Object Declared Type            Bytes Dimen Elements Attributes       References                        
                                                                                                                                    
 ERROR_HEADER               Param  1560     CHAR            64          scalar                    1567,1573                         
 GET_FIELD_METHOD           Subr   1541                                                                                             
 M                          Dummy  1541     I(4)            4           scalar   ARG,IN           1573,1575                         
 METHOD                     Dummy  1541     METHOD_TYPE     384         scalar   ARG,INOUT        1575                              
 N                          Dummy  1541     I(4)            4           scalar   ARG,IN           1567,1573,1575                    
 SUB_NAME                   Param  1559     CHAR            16          scalar                    1561                              
 TRIM                       Func   1560                                 scalar                    1560,1561,1567,1573               

Page 44          Source Listing                  GET_FIELD_METHOD
2021-06-01 08:55                                 field_manager.F90

   1578 ! </SUBROUTINE>
   1579 
   1580 !#######################################################################
   1581 !#######################################################################
   1582 
   1583 ! <SUBROUTINE NAME="get_field_methods">
   1584 !   <OVERVIEW>
   1585 !     A routine to obtain all the methods associated with a field.
   1586 !   </OVERVIEW>
   1587 !   <DESCRIPTION>
   1588 !     When passed a field index, this routine will return the text
   1589 !     associated with all the methods attached to the field.
   1590 !   </DESCRIPTION>
   1591 !   <TEMPLATE>
   1592 !     call get_field_methods( n,methods )
   1593 !   </TEMPLATE>
   1594 subroutine get_field_methods(n,methods)
   1595 !
   1596 !   <IN NAME="n" TYPE="integer">
   1597 !     The field index.
   1598 !   </IN>
   1599 !   <OUT NAME="method" TYPE="type(method_type)" DIM="(:)">
   1600 !     An array of methods for field with index n.
   1601 !   </OUT>
   1602 integer,          intent(in)  :: n
   1603 
   1604 type(method_type),intent(inout) :: methods(:)
   1605 
   1606 !+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   1607 !        local parameters
   1608 !+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   1609 character(len=17), parameter :: sub_name     = 'get_field_methods'
   1610 character(len=64), parameter :: error_header = '==>Error from ' // trim(module_name)   //  &
   1611                                                '(' // trim(sub_name) // '): '
   1612 
   1613 !+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   1614 !        local variables
   1615 !+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   1616 character(len=fm_path_name_len), dimension(size(methods(:))) :: control
   1617 character(len=fm_path_name_len), dimension(size(methods(:))) :: method
   1618 logical                                                   :: found_methods
   1619 !   <ERROR MSG="invalid field index" STATUS="FATAL">
   1620 !     The field index is invalid because it is less than 1 or greater than the
   1621 !     number of fields.
   1622 !   </ERROR>
   1623   if (n < 1 .or. n > num_fields) &
   1624     call mpp_error(FATAL,trim(error_header)//'Invalid field index')
   1625 
   1626 !   <ERROR MSG="method array too small" STATUS="FATAL">
   1627 !     The method array is smaller than the number of methods.
   1628 !   </ERROR>
   1629   if (size(methods(:)) <  fields(n)%num_methods) &
   1630     call mpp_error(FATAL,trim(error_header)//'Method array too small')
   1631 
   1632   methods = default_method
   1633   methods(1:fields(n)%num_methods) = fields(n)%methods(1:fields(n)%num_methods)
   1634 

Page 45          Source Listing                  GET_FIELD_METHODS
2021-06-01 08:55                                 field_manager.F90

   1635 end subroutine get_field_methods


ENTRY POINTS

  Name                                               
                                                     
 field_manager_mod_mp_get_field_methods_             


SYMBOL CROSS REFERENCE

 Name                       Object Declared Type            Bytes Dimen Elements Attributes       References                        
                                                                                                                                    
 CONTROL                    Local  1616     CHAR            512   1     0                                                           
 ERROR_HEADER               Param  1610     CHAR            64          scalar                    1624,1630                         
 FOUND_METHODS              Local  1618     L(4)            4           scalar                                                      
 GET_FIELD_METHODS          Subr   1594                                                                                             
 METHOD                     Local  1617     CHAR            512   1     0                                                           
 METHODS                    Dummy  1594     RECORD          384   1     1        ARG,INOUT        1616,1617,1629,1632,1633          
 N                          Dummy  1594     I(4)            4           scalar   ARG,IN           1623,1629,1633                    
 SIZE                       Func   1616                                 scalar                    1616,1617,1629                    
 SUB_NAME                   Param  1609     CHAR            17          scalar                    1611                              
 TRIM                       Func   1610                                 scalar                    1610,1611,1624,1630               

Page 46          Source Listing                  GET_FIELD_METHODS
2021-06-01 08:55                                 field_manager.F90

   1636 ! </SUBROUTINE>
   1637 
   1638 !#######################################################################
   1639 !#######################################################################
   1640 
   1641 ! <FUNCTION NAME="parse">
   1642 !   <OVERVIEW>
   1643 !     A function to parse an integer or an array of integers,
   1644 !     a real or an array of reals, a string or an array of strings.
   1645 !   </OVERVIEW>
   1646 !   <DESCRIPTION>
   1647 !  Parse is an integer function that decodes values from a text string.
   1648 !  The text string has the form: "label=list" where "label" is an
   1649 !  arbitrary user defined label describing the values being decoded,
   1650 !  and "list" is a list of one or more values separated by commas.
   1651 !  The values may be integer, real, or character.
   1652 !  Parse returns the number of values decoded.
   1653 !   </DESCRIPTION>
   1654 !   <TEMPLATE>
   1655 !     number = parse(text, label, value)
   1656 !   </TEMPLATE>
   1657 
   1658 
   1659 function parse_reals ( text, label, values ) result (parse)
   1660 !
   1661 !   <IN NAME="text" TYPE="character(len=*)">
   1662 !     The text string from which the values will be parsed.
   1663 !   </IN>
   1664 !   <IN NAME="label" TYPE="character(len=*)">
   1665 !     A label which describes the values being decoded.
   1666 !   </IN>
   1667 !   <OUT NAME="value" TYPE="integer, real, character(len=*)">
   1668 !     The value or values that have been decoded.
   1669 !   </OUT>
   1670 !   <OUT NAME="parse" TYPE="integer">
   1671 !     The number of values that have been decoded. This allows
   1672 !     a user to define a large array and fill it partially with
   1673 !     values from a list. This should be the size of the value array.
   1674 !   </OUT>
   1675 character(len=*), intent(in)  :: text, label
   1676 real,             intent(out) :: values(:)
   1677 
   1678 include 'parse.inc'
   1747 end function parse_reals

Page 47          Source Listing                  PARSE_REALS
2021-06-01 08:55 Entry Points                    field_manager.F90



ENTRY POINTS

  Name                                         
                                               
 field_manager_mod_mp_parse_reals_             


SYMBOL CROSS REFERENCE

 Name                       Object Declared Type            Bytes Dimen Elements Attributes       References                        
                                                                                                                                    
 99                         Label  1745                                                           1736                              
 DELIM                      Param  1700     CHAR            2           scalar                    1715                              
 I                          Local  1703     I(4)            4           scalar                    1707,1708,1710,1719,1722          
 ID                         Local  1702     I(4)            4           scalar                    1726,1727,1730,1740               
 IE                         Local  1702     I(4)            4           scalar                    1710,1711,1714,1717,1728,1730,1736
                                                                                                  ,1739                             
 IS                         Local  1702     I(4)            4           scalar                    1714,1715,1717,1722,1726,1730,1736
                                                                                                  ,1740,1741                        
 K                          Local  1702     I(4)            4           scalar                    1723,1736                         
 LABEL                      Dummy  1659     CHAR                        scalar   ARG,IN           1717,1746                         
 LAST                       Local  1703     I(4)            4           scalar                    1705,1707,1726,1728,1739,1741     
 LEN_TRIM                   Func   1705                                 scalar                    1705                              
 PARSE                      Local  1701     I(4)            4           scalar                    1705,1737                         
 PARSE_REALS                Func   1659     I(4)            4           scalar   PRIV             1918                              
 SCAN                       Func   1707                                 scalar                    1707,1711,1715,1726               
 SIZE                       Func   1723                                 scalar                    1723                              
 SPACE                      Param  1699     CHAR            1           scalar                    1700,1711                         
 TEXT                       Dummy  1659     CHAR                        scalar   ARG,IN           1705,1707,1711,1715,1717,1726,1736
                                                                                                  ,1746                             
 TRIM                       Func   1717                                 scalar                    1717,1746                         
 TS                         Local  1703     I(4)            4           scalar                    1705,1707,1710,1714,1719,1722     
 VALUES                     Dummy  1659     R(8)            8     1     1        ARG,OUT          1723,1736                         

Page 48          Source Listing                  PARSE_REALS
2021-06-01 08:55                                 field_manager.F90

   1748 ! </FUNCTION>
   1749 
   1750 !#######################################################################
   1751 !#######################################################################
   1752 
   1753 function parse_integers ( text, label, values ) result (parse)
   1754 character(len=*), intent(in)  :: text, label
   1755 integer,          intent(out) :: values(:)
   1756 
   1757 include 'parse.inc'
   1826 end function parse_integers


ENTRY POINTS

  Name                                            
                                                  
 field_manager_mod_mp_parse_integers_             


SYMBOL CROSS REFERENCE

 Name                       Object Declared Type            Bytes Dimen Elements Attributes       References                        
                                                                                                                                    
 99                         Label  1824                                                           1815                              
 DELIM                      Param  1779     CHAR            2           scalar                    1794                              
 I                          Local  1782     I(4)            4           scalar                    1786,1787,1789,1798,1801          
 ID                         Local  1781     I(4)            4           scalar                    1805,1806,1809,1819               
 IE                         Local  1781     I(4)            4           scalar                    1789,1790,1793,1796,1807,1809,1815
                                                                                                  ,1818                             
 IS                         Local  1781     I(4)            4           scalar                    1793,1794,1796,1801,1805,1809,1815
                                                                                                  ,1819,1820                        
 K                          Local  1781     I(4)            4           scalar                    1802,1815                         
 LABEL                      Dummy  1753     CHAR                        scalar   ARG,IN           1796,1825                         
 LAST                       Local  1782     I(4)            4           scalar                    1784,1786,1805,1807,1818,1820     
 LEN_TRIM                   Func   1784                                 scalar                    1784                              
 PARSE                      Local  1780     I(4)            4           scalar                    1784,1816                         
 PARSE_INTEGERS             Func   1753     I(4)            4           scalar   PRIV             1932                              
 SCAN                       Func   1786                                 scalar                    1786,1790,1794,1805               
 SIZE                       Func   1802                                 scalar                    1802                              
 SPACE                      Param  1778     CHAR            1           scalar                    1779,1790                         
 TEXT                       Dummy  1753     CHAR                        scalar   ARG,IN           1784,1786,1790,1794,1796,1805,1815
                                                                                                  ,1825                             
 TRIM                       Func   1796                                 scalar                    1796,1825                         
 TS                         Local  1782     I(4)            4           scalar                    1784,1786,1789,1793,1798,1801     
 VALUES                     Dummy  1753     I(4)            4     1     1        ARG,OUT          1802,1815                         

Page 49          Source Listing                  PARSE_INTEGERS
2021-06-01 08:55                                 field_manager.F90

   1827 
   1828 !#######################################################################
   1829 !#######################################################################
   1830 
   1831 function parse_strings ( text, label, values ) result (parse)
   1832 character(len=*), intent(in)  :: text, label
   1833 character(len=*), intent(out) :: values(:)
   1834 
   1835 include 'parse.inc'
   1904 end function parse_strings


ENTRY POINTS

  Name                                           
                                                 
 field_manager_mod_mp_parse_strings_             


SYMBOL CROSS REFERENCE

 Name                       Object Declared Type            Bytes Dimen Elements Attributes       References                        
                                                                                                                                    
 99                         Label  1902                                                           1893                              
 DELIM                      Param  1857     CHAR            2           scalar                    1872                              
 I                          Local  1860     I(4)            4           scalar                    1864,1865,1867,1876,1879          
 ID                         Local  1859     I(4)            4           scalar                    1883,1884,1887,1897               
 IE                         Local  1859     I(4)            4           scalar                    1867,1868,1871,1874,1885,1887,1893
                                                                                                  ,1896                             
 IS                         Local  1859     I(4)            4           scalar                    1871,1872,1874,1879,1883,1887,1893
                                                                                                  ,1897,1898                        
 K                          Local  1859     I(4)            4           scalar                    1880,1893                         
 LABEL                      Dummy  1831     CHAR                        scalar   ARG,IN           1874,1903                         
 LAST                       Local  1860     I(4)            4           scalar                    1862,1864,1883,1885,1896,1898     
 LEN_TRIM                   Func   1862                                 scalar                    1862                              
 PARSE                      Local  1858     I(4)            4           scalar                    1862,1894                         
 PARSE_STRINGS              Func   1831     I(4)            4           scalar   PRIV             1946                              
 SCAN                       Func   1864                                 scalar                    1864,1868,1872,1883               
 SIZE                       Func   1880                                 scalar                    1880                              
 SPACE                      Param  1856     CHAR            1           scalar                    1857,1868                         
 TEXT                       Dummy  1831     CHAR                        scalar   ARG,IN           1862,1864,1868,1872,1874,1883,1893
                                                                                                  ,1903                             
 TRIM                       Func   1874                                 scalar                    1874,1903                         
 TS                         Local  1860     I(4)            4           scalar                    1862,1864,1867,1871,1876,1879     
 VALUES                     Dummy  1831     CHAR                  1     1        ARG,OUT          1880,1893                         

Page 50          Source Listing                  PARSE_STRINGS
2021-06-01 08:55                                 field_manager.F90

   1905 
   1906 !#######################################################################
   1907 !#######################################################################
   1908 
   1909 !---- scalar overloads -----
   1910 
   1911 function parse_real ( text, label, value ) result (parse)
   1912 character(len=*), intent(in)  :: text, label
   1913 real,             intent(out) :: value
   1914 integer :: parse
   1915 
   1916 real :: values(1)
   1917 
   1918    parse = parse_reals ( text, label, values )
   1919    if (parse > 0) value = values(1)
   1920 end function parse_real


ENTRY POINTS

  Name                                        
                                              
 field_manager_mod_mp_parse_real_             


SYMBOL CROSS REFERENCE

 Name                       Object Declared Type            Bytes Dimen Elements Attributes       References                        
                                                                                                                                    
 LABEL                      Dummy  1911     CHAR                        scalar   ARG,IN           1918                              
 PARSE                      Local  1914     I(4)            4           scalar                    1918,1919                         
 PARSE_REAL                 Func   1911     I(4)            4           scalar   PRIV                                               
 TEXT                       Dummy  1911     CHAR                        scalar   ARG,IN           1918                              
 VALUE                      Dummy  1911     R(8)            8           scalar   ARG,OUT          1919                              
 VALUES                     Local  1916     R(8)            8     1     1        TGT              1918,1919                         

Page 51          Source Listing                  PARSE_REAL
2021-06-01 08:55                                 field_manager.F90

   1921 
   1922 !#######################################################################
   1923 !#######################################################################
   1924 
   1925 function parse_integer ( text, label, value ) result (parse)
   1926 character(len=*), intent(in)  :: text, label
   1927 integer,          intent(out) :: value
   1928 integer :: parse
   1929 
   1930 integer :: values(1)
   1931 
   1932    parse = parse_integers ( text, label, values )
   1933    if (parse > 0) value = values(1)
   1934 end function parse_integer


ENTRY POINTS

  Name                                           
                                                 
 field_manager_mod_mp_parse_integer_             


SYMBOL CROSS REFERENCE

 Name                       Object Declared Type            Bytes Dimen Elements Attributes       References                        
                                                                                                                                    
 LABEL                      Dummy  1925     CHAR                        scalar   ARG,IN           1932                              
 PARSE                      Local  1928     I(4)            4           scalar                    1932,1933                         
 PARSE_INTEGER              Func   1925     I(4)            4           scalar   PRIV                                               
 TEXT                       Dummy  1925     CHAR                        scalar   ARG,IN           1932                              
 VALUE                      Dummy  1925     I(4)            4           scalar   ARG,OUT          1933                              
 VALUES                     Local  1930     I(4)            4     1     1        TGT              1932,1933                         

Page 52          Source Listing                  PARSE_INTEGER
2021-06-01 08:55                                 field_manager.F90

   1935 
   1936 !#######################################################################
   1937 !#######################################################################
   1938 
   1939 function parse_string ( text, label, value ) result (parse)
   1940 character(len=*), intent(in)  :: text, label
   1941 character(len=*), intent(out) :: value
   1942 integer :: parse
   1943 
   1944 character(len=len(value)) :: values(1)
   1945 
   1946    parse = parse_strings ( text, label, values )
   1947    if (parse > 0) value = values(1)
   1948 end function parse_string


ENTRY POINTS

  Name                                          
                                                
 field_manager_mod_mp_parse_string_             


SYMBOL CROSS REFERENCE

 Name                       Object Declared Type            Bytes Dimen Elements Attributes       References                        
                                                                                                                                    
 LABEL                      Dummy  1939     CHAR                        scalar   ARG,IN           1946                              
 LEN                        Func   1944                                 scalar                    1944                              
 PARSE                      Local  1942     I(4)            4           scalar                    1946,1947                         
 PARSE_STRING               Func   1939     I(4)            4           scalar   PRIV                                               
 TEXT                       Dummy  1939     CHAR                        scalar   ARG,IN           1946                              
 VALUE                      Dummy  1939     CHAR                        scalar   ARG,OUT          1944,1947                         
 VALUES                     Local  1944     CHAR                  1     1        TGT              1946,1947                         

Page 53          Source Listing                  PARSE_STRING
2021-06-01 08:55                                 field_manager.F90

   1949 
   1950 !#######################################################################
   1951 !#######################################################################
   1952 
   1953 ! <PRIVATE><FUNCTION NAME="create_field">
   1954 !
   1955 ! <OVERVIEW>
   1956 !    A function to create a field as a child of parent_p. This will return
   1957 !    a pointer to a field_def type.
   1958 ! </OVERVIEW>
   1959 ! <DESCRIPTION>
   1960 !    Allocate and initialize a new field in parent_p list.
   1961 !    Return a pointer to the field on success, or a null pointer
   1962 !    on failure.
   1963 ! </DESCRIPTION>
   1964 !   <TEMPLATE>
   1965 !     list_p => create_field(parent_p, name)
   1966 !   </TEMPLATE>
   1967 !
   1968 !
   1969 function  create_field(parent_p, name)                        &
   1970           result (list_p)  !{
   1971 !
   1972 !   <IN NAME="parent_p" TYPE="type(field_def), pointer">
   1973 !     A pointer to the parent of the field that is to be created.
   1974 !   </IN>
   1975 !   <IN NAME="name" TYPE="character">
   1976 !     The name of the field that is to be created.
   1977 !   </IN>
   1978 !   <OUT NAME="list_p" TYPE="type(field_def), pointer">
   1979 !     A pointer to the field that has been created.
   1980 !   </OUT>
   1981 !
   1982 !        Function definition
   1983 !
   1984 type (field_def), pointer    :: list_p
   1985 !
   1986 !        arguments
   1987 !
   1988 type (field_def), pointer    :: parent_p
   1989 character(len=*), intent(in) :: name
   1990 
   1991 !+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   1992 !        local parameters
   1993 !+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   1994 character(len=12), parameter :: sub_name     = 'create_field'
   1995 character(len=64), parameter :: error_header = '==>Error from ' // trim(module_name)   //  &
   1996                                                '(' // trim(sub_name) // '): '
   1997 character(len=64), parameter :: warn_header  = '==>Warning from ' // trim(module_name) //  &
   1998                                                '(' // trim(sub_name) // '): '
   1999 integer                      :: ier
   2000 !+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   2001 !        local variables
   2002 !+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   2003 integer                      :: error, out_unit
   2004 !
   2005 !        Check for fatal errors which should never arise

Page 54          Source Listing                  CREATE_FIELD
2021-06-01 08:55                                 field_manager.F90

   2006 !
   2007 out_unit = stdout()
   2008 if (.not. associated(parent_p)) then  !{
   2009 
   2010   if (verb .gt. verb_level_warn) then  !{
   2011     write (out_unit,*) trim(warn_header), 'Unnassociated pointer'  &
   2012                    , ' for ', trim(name)
   2013   endif  !}
   2014   nullify(list_p)
   2015   return
   2016 endif  !}
   2017 
   2018 if (name .eq. ' ') then  !{
   2019   if (verb .gt. verb_level_warn) then  !{
   2020     write (out_unit,*) trim(warn_header), 'Empty name for '        &
   2021                    , trim(name)
   2022   endif  !}
   2023   nullify(list_p)
   2024   return
   2025 endif  !}
   2026 !
   2027 !        Allocate space for the new list
   2028 !
   2029 allocate(list_p, stat = error)
   2030 if (error .ne. 0) then !{
   2031   write (out_unit,*) trim(error_header), 'Error ', error,       &
   2032        ' allocating memory for list ', trim(name)
   2033   nullify(list_p)
   2034   return
   2035 endif  !}
   2036 !
   2037 !        Initialize the new field
   2038 !
   2039 list_p%name = name
   2040 
   2041 nullify(list_p%next)
   2042 list_p%prev => parent_p%last_field
   2043 nullify(list_p%first_field)
   2044 nullify(list_p%last_field)
   2045 list_p%length = 0
   2046 list_p%field_type = null_type
   2047 list_p%max_index = 0
   2048 list_p%array_dim = 0
   2049 if (associated(list_p%i_value)) deallocate(list_p%i_value)
   2050 if (associated(list_p%l_value)) deallocate(list_p%l_value)
   2051 if (associated(list_p%r_value)) deallocate(list_p%r_value)
   2052 if (associated(list_p%s_value)) deallocate(list_p%s_value)
   2053 !
   2054 !        If this is the first field in the parent, then set the pointer
   2055 !        to it, otherwise, update the "next" pointer for the last list
   2056 !
   2057 if (parent_p%length .le. 0) then  !{
   2058   parent_p%first_field => list_p
   2059 else  !}{
   2060   parent_p%last_field%next => list_p
   2061 endif  !}
   2062 !

Page 55          Source Listing                  CREATE_FIELD
2021-06-01 08:55                                 field_manager.F90

   2063 !        Update the pointer for the last list in the parent
   2064 !
   2065 parent_p%last_field => list_p
   2066 !
   2067 !        Update the length for the parent
   2068 !
   2069 parent_p%length = parent_p%length + 1
   2070 !
   2071 !        Set the new index as the return value
   2072 !
   2073 list_p%index = parent_p%length
   2074 !
   2075 !        set the pointer to the parent list
   2076 !
   2077 list_p%parent => parent_p
   2078 
   2079 end function  create_field  !}


ENTRY POINTS

  Name                                          
                                                
 field_manager_mod_mp_create_field_             


SYMBOL CROSS REFERENCE

 Name                       Object Declared Type            Bytes Dimen Elements Attributes       References                        
                                                                                                                                    
 ASSOCIATED                 Func   2008                                 scalar                    2008,2049,2050,2051,2052          
 CREATE_FIELD               Func   1969     FIELD_DEF       400         scalar   PTR                                                
 ERROR                      Local  2003     I(4)            4           scalar                    2029,2030,2031                    
 ERROR_HEADER               Param  1995     CHAR            64          scalar                    2031                              
 FIELD_DEF                  Type   1984                     400         scalar   PRIV             434,540,545,546,551,552,553,583,58
                                                                                                  4,585,586,587,1984,1988,2117,2128,
                                                                                                  2378,2383,2388,2550,2555,2573,2574
                                                                                                  ,2719,2791,2897,2972,3033,3108,320
                                                                                                  1,3294,3393,3516,3642,3771,3936,41
                                                                                                  34,4318,4472,4473,4707,4708,4943,4
                                                                                                  944,5178,5179,5502,5507,5513,5582,
                                                                                                  5583,5718,5722,5734,5840,5841,5842
                                                                                                  ,5939,5951,6106,6107,6252,6348,636
                                                                                                  8                                 
 IER                        Local  1999     I(4)            4           scalar                                                      
 LIST_P                     Local  1984     FIELD_DEF       400         scalar   PTR,TGT          2014,2023,2029,2033,2039,2041,2042
                                                                                                  ,2043,2044,2045,2046,2047,2048,204
                                                                                                  9,2050,2051,2052,2058,2060,2065,20
                                                                                                  73,2077                           
 NAME                       Dummy  1969     CHAR                        scalar   ARG,IN           2012,2018,2021,2032,2039          
 NULL_TYPE                  Param  2046     I(4)            4           scalar                    2046,4563,4792,5041,5264          
 OUT_UNIT                   Local  2003     I(4)            4           scalar                    2007,2011,2020,2031               
 PARENT_P                   Dummy  1969     FIELD_DEF       400         scalar   ARG,PTR,TGT      2008,2042,2057,2058,2060,2065,2069
                                                                                 INOUT            ,2073,2077                        
 SUB_NAME                   Param  1994     CHAR            12          scalar                    1996,1998                         
 TRIM                       Func   1995                                 scalar                    1995,1996,1997,1998,2011,2012,2020
                                                                                                  ,2021,2031,2032                   

Page 56          Source Listing                  CREATE_FIELD
2021-06-01 08:55 Symbol Table                    field_manager.F90

 Name                       Object Declared Type            Bytes Dimen Elements Attributes       References                        
                                                                                                                                    
 WARN_HEADER                Param  1997     CHAR            64          scalar                    2011,2020                         


TYPE COMPONENTS/COMMON VARIABLES

 Name                       Type            Bytes Offset   Dimen Elements Attributes       References                         
                                                                                                                              
 FIELD_DEF.ARRAY_DIM        I(4)            4     72             scalar                    2048,4620,4621,4626,4627,4851,4853 
                                                                                           ,4859,4860,5093,5094,5099,5100,532 
                                                                                           4,5326,5332,5333,5662              
 FIELD_DEF.FIELD_TYPE       I(4)            4     64             scalar                    2046,2138,2158,2660,3230,3323,3431 
                                                                                           ,3554,3680,3809,4204,4252,4555,455 
                                                                                           9,4563,4567,4575,4790,4792,4796,48 
                                                                                           04,5027,5033,5035,5041,5045,5053,5 
                                                                                           262,5264,5268,5276,5656,5773,5962, 
                                                                                           5975,6161,6380,6394                
 FIELD_DEF.FIRST_FIELD      FIELD_DEF       400   80             scalar   PTR,TGT          2043,2058,2154,2408,4156,4165,4231 
                                                                                           ,4234,5659,5869,5972,6391          
 FIELD_DEF.INDEX            I(4)            4     48             scalar                    2073,3061,4205,4253,4371,4645,4881 
                                                                                           ,5118,5354,5653                    
 FIELD_DEF.I_VALUE          I(4)            4     96       1     1        PTR              2049,2173,2178,3460,4613,4618,4629 
                                                                                           ,4631,4632,4640,5029,5030,5031,503 
                                                                                           4,5663,5774,5989,6413              
 FIELD_DEF.LAST_FIELD       FIELD_DEF       400   88             scalar   PTR,TGT          2042,2044,2060,2065,5660           
 FIELD_DEF.LENGTH           I(4)            4     68             scalar                    2045,2057,2069,2073,3231,3968,3971 
                                                                                           ,3972,5658,5772,6399,6400          
 FIELD_DEF.L_VALUE          L(4)            4     168      1     1        PTR              2050,2189,2194,3586,4842,4849,4862 
                                                                                           ,4864,4865,4876,5664,5775,5993,642 
                                                                                           7                                  
 FIELD_DEF.MAX_INDEX        I(4)            4     76             scalar                    2047,2170,2172,2177,2186,2188,2193 
                                                                                           ,2202,2204,2209,2218,2220,2224,323 
                                                                                           3,3444,3452,3569,3577,3696,3705,38 
                                                                                           23,3831,4562,4582,4586,4600,4619,4 
                                                                                           628,4633,4641,4642,4791,4811,4815, 
                                                                                           4829,4850,4861,4866,4877,4878,5040 
                                                                                           ,5059,5062,5074,5092,5101,5106,511 
                                                                                           4,5115,5263,5283,5287,5301,5323,53 
                                                                                           34,5339,5350,5351,5661,6002,6446   
 FIELD_DEF.NAME             CHAR            48    0              scalar                    2039,2139,2147,2166,2171,2174,2180 
                                                                                           ,2187,2190,2196,2203,2206,2212,221 
                                                                                           9,2221,2226,2233,2415,2820,2830,28 
                                                                                           35,3127,3133,4203,4251,5456,5597,5 
                                                                                           606,5652,5872,5964,5979,5983,5990, 
                                                                                           5994,5998,6001,6008,6382,6402,6405 
                                                                                           ,6408,6416,6425,6435,6443,6454     
 FIELD_DEF.NEXT             FIELD_DEF       400   384            scalar   PTR,TGT          2041,2060,2240,2420,4149,4255,5668 
                                                                                           ,5880,6014,6461                    
 FIELD_DEF.PARENT           FIELD_DEF       400   56             scalar   PTR,TGT          2077,2403,2821,2831,2836,3137,5457 
                                                                                           ,5654                              
 FIELD_DEF.PREV             FIELD_DEF       400   392            scalar   PTR              2042,5669                          
 FIELD_DEF.R_VALUE          R(8)            8     240      1     1        PTR              2051,2205,2210,3715,5029,5031,5086 
                                                                                           ,5091,5102,5104,5105,5113,5665,577 
                                                                                           6,5997,6432                        
 FIELD_DEF.S_VALUE          CHAR            128   312      1     1        PTR              2052,2222,2227,3839,5315,5322,5335 
                                                                                           ,5337,5338,5349,5666,5777,5873,600 

Page 57          Source Listing                  CREATE_FIELD
2021-06-01 08:55 Symbol Table                    field_manager.F90

 Name                       Type            Bytes Offset   Dimen Elements Attributes       References                         
                                                                                                                              
                                                                                           1,6003,6445,6447                   

Page 58          Source Listing                  CREATE_FIELD
2021-06-01 08:55                                 field_manager.F90

   2080 ! </FUNCTION> NAME="create_field"
   2081 !</PRIVATE>
   2082 !#######################################################################
   2083 !#######################################################################
   2084 
   2085 ! <PRIVATE><FUNCTION NAME="dump_list">
   2086 !
   2087 ! <OVERVIEW>
   2088 !    This is a function that lists the parameters of a field.
   2089 ! </OVERVIEW>
   2090 ! <DESCRIPTION>
   2091 !    Given a pointer to a list, this function prints out the fields, and
   2092 !    subfields, if recursive is true, associated with the list.
   2093 !
   2094 !    This is most likely to be used through fm_dump_list.
   2095 ! </DESCRIPTION>
   2096 !   <TEMPLATE>
   2097 !     success = dump_list(list_p, recursive= .true., depth=0)
   2098 !   </TEMPLATE>
   2099 !
   2100 logical recursive function dump_list(list_p, recursive, depth, out_unit) result(success)
   2101 !
   2102 !   <IN NAME="list_p" TYPE="type(field_def), pointer">
   2103 !     A pointer to the field, the contents of which will be printed out.
   2104 !   </IN>
   2105 !   <IN NAME="recursive" TYPE="logical">
   2106 !     A flag to make the function recursively print all the sub-fields
   2107 !     of the field pointed to by list_p.
   2108 !   </IN>
   2109 !   <IN NAME="depth" TYPE="integer">
   2110 !     The listing will be padded so that 'depth' spaces appear before
   2111 !     the field being printed.
   2112 !   </IN>
   2113 !   <OUT NAME="success" TYPE="logical">
   2114 !     A flag to indicate whether the function operated with (FALSE) or
   2115 !     without (TRUE) errors.
   2116 !   </OUT>
   2117   type (field_def), pointer :: list_p
   2118   logical, intent(in)       :: recursive
   2119   integer, intent(in)       :: depth
   2120   integer, intent(in)       :: out_unit
   2121 
   2122 ! ---- local constants
   2123   character(len=64), parameter :: warn_header  = '==>Warning from ' // trim(module_name) // '(dump_list): '
   2124 ! ---- local variables
   2125   integer                             :: depthp1
   2126   integer                             :: j
   2127   character(len=fm_field_name_len)    :: num, scratch
   2128   type (field_def), pointer           :: this_field_p
   2129   character(len=depth+fm_field_name_len) :: blank
   2130 
   2131   blank = ' ' ! initialize blank string
   2132 
   2133 ! Check for a valid list
   2134   success = .false.
   2135   if (.not. associated(list_p)) then
   2136     if (verb > verb_level_warn) write (out_unit,*) trim(warn_header), 'Invalid list pointer'

Page 59          Source Listing                  DUMP_LIST
2021-06-01 08:55                                 field_manager.F90

   2137     return
   2138   elseif (list_p%field_type .ne. list_type) then
   2139     if (verb > verb_level_warn) write (out_unit,*) trim(warn_header), trim(list_p%name), ' is not a list'
   2140     return
   2141   endif
   2142 
   2143 ! set the default return value
   2144   success = .true.
   2145 
   2146 ! Print the name of this list
   2147   write (out_unit,'(a,a,a)') blank(1:depth), trim(list_p%name), list_sep
   2148 
   2149 !  Increment the indentation depth
   2150 ! The following max function is to work around an error in the IBM compiler for len_trim
   2151 ! depthp1 = depth + max(len_trim(list_p%name),0) + len_trim(list_sep)
   2152   depthp1 = depth + 6
   2153 
   2154   this_field_p => list_p%first_field
   2155 
   2156   do while (associated(this_field_p))
   2157 
   2158      select case(this_field_p%field_type)
   2159      case(list_type)
   2160 ! If this is a list, then call dump_list
   2161        if (recursive) then
   2162 ! If recursive is true, then this routine will find and dump sub-fields.
   2163           success =  dump_list(this_field_p, .true., depthp1, out_unit)
   2164           if (.not.success) exit ! quit immediately in case of error
   2165        else ! Otherwise it will print out the name of this field.
   2166           write (out_unit,'(a,a,a)') blank(1:depthp1), trim(this_field_p%name), list_sep
   2167        endif
   2168 
   2169      case(integer_type)
   2170          if (this_field_p%max_index .eq. 0) then
   2171             write (out_unit,'(a,a,a)') blank(1:depthp1),  trim(this_field_p%name), ' = NULL'
   2172          elseif (this_field_p%max_index .eq. 1) then
   2173             write (scratch,*) this_field_p%i_value(1)
   2174             write (out_unit,'(a,a,a,a)') blank(1:depthp1), trim(this_field_p%name), ' = ', &
   2175                    trim(adjustl(scratch))
   2176          else  ! Write out the array of values for this field.
   2177             do j = 1, this_field_p%max_index
   2178                write (scratch,*) this_field_p%i_value(j)
   2179                write (num,*) j
   2180                write (out_unit,'(a,a,a,a,a,a)') blank(1:depthp1), trim(this_field_p%name), &
   2181                       '[', trim(adjustl(num)), '] = ', trim(adjustl(scratch))
   2182            enddo
   2183          endif
   2184 
   2185      case(logical_type)
   2186          if (this_field_p%max_index .eq. 0) then
   2187             write (out_unit,'(a,a,a)') blank(1:depthp1),  trim(this_field_p%name), ' = NULL'
   2188          elseif (this_field_p%max_index .eq. 1) then
   2189             write (scratch,'(l1)') this_field_p%l_value(1)
   2190             write (out_unit,'(a,a,a,a)') blank(1:depthp1), trim(this_field_p%name), ' = ', &
   2191                    trim(adjustl(scratch))
   2192          else  ! Write out the array of values for this field.
   2193             do j = 1, this_field_p%max_index

Page 60          Source Listing                  DUMP_LIST
2021-06-01 08:55                                 field_manager.F90

   2194                write (scratch,'(l1)') this_field_p%l_value(j)
   2195                write (num,*) j
   2196                write (out_unit,'(a,a,a,a,a,a)') blank(1:depthp1), trim(this_field_p%name), &
   2197                       '[', trim(adjustl(num)), '] = ', trim(adjustl(scratch))
   2198             enddo
   2199          endif
   2200 
   2201      case(real_type)
   2202          if (this_field_p%max_index .eq. 0) then
   2203             write (out_unit,'(a,a,a)') blank(1:depthp1),  trim(this_field_p%name), ' = NULL'
   2204          elseif (this_field_p%max_index .eq. 1) then
   2205             write (scratch,*) this_field_p%r_value(1)
   2206             write (out_unit,'(a,a,a,a)') blank(1:depthp1), trim(this_field_p%name), ' = ', &
   2207                    trim(adjustl(scratch))
   2208          else  ! Write out the array of values for this field.
   2209             do j = 1, this_field_p%max_index
   2210                write (scratch,*) this_field_p%r_value(j)
   2211                write (num,*) j
   2212                write (out_unit,'(a,a,a,a,a,a)') blank(1:depthp1), trim(this_field_p%name), &
   2213                       '[', trim(adjustl(num)), '] = ', trim(adjustl(scratch))
   2214             enddo
   2215          endif
   2216 
   2217      case(string_type)
   2218          if (this_field_p%max_index .eq. 0) then
   2219             write (out_unit,'(a,a,a)') blank(1:depthp1),  trim(this_field_p%name), ' = NULL'
   2220          elseif (this_field_p%max_index .eq. 1) then
   2221             write (out_unit,'(a,a,a,a)') blank(1:depthp1), trim(this_field_p%name), ' = ', &
   2222                    ''''//trim(this_field_p%s_value(1))//''''
   2223          else  ! Write out the array of values for this field.
   2224             do j = 1, this_field_p%max_index
   2225                write (num,*) j
   2226                write (out_unit,'(a,a,a,a,a,a)') blank(1:depthp1), trim(this_field_p%name), &
   2227                       '[', trim(adjustl(num)), '] = ', ''''//trim(this_field_p%s_value(j))//''''
   2228             enddo
   2229          endif
   2230 
   2231      case default
   2232          if (verb .gt. verb_level_warn) then
   2233             write (out_unit,*) trim(warn_header), 'Undefined type for ', trim(this_field_p%name)
   2234          endif
   2235          success = .false.
   2236          exit
   2237 
   2238      end select
   2239 
   2240      this_field_p => this_field_p%next
   2241   enddo
   2242 
   2243 end function dump_list

Page 61          Source Listing                  DUMP_LIST
2021-06-01 08:55 Entry Points                    field_manager.F90



ENTRY POINTS

  Name                                       
                                             
 field_manager_mod_mp_dump_list_             


SYMBOL CROSS REFERENCE

 Name                       Object Declared Type            Bytes Dimen Elements Attributes       References                        
                                                                                                                                    
 ADJUSTL                    Func   2175                                 scalar                    2175,2181,2191,2197,2207,2213,2227
 ASSOCIATED                 Func   2135                                 scalar                    2135,2156                         
 BLANK                      Local  2129     CHAR                        scalar                    2131,2147,2166,2171,2174,2180,2187
                                                                                                  ,2190,2196,2203,2206,2212,2219,222
                                                                                                  1,2226                            
 DEPTH                      Dummy  2100     I(4)            4           scalar   ARG,IN           2129,2147,2152                    
 DEPTHP1                    Local  2125     I(4)            4           scalar                    2152,2163,2166,2171,2174,2180,2187
                                                                                                  ,2190,2196,2203,2206,2212,2219,222
                                                                                                  1,2226                            
 DUMP_LIST                  Func   2100     L(4)            4           scalar                                                      
 DUMP_LIST                  Func   2163     L(4)            4           scalar   PRIV             286,2163,2929                     
 FM_FIELD_NAME_LEN          Param  2127     I(4)            4           scalar                    298,353,520,527,528,533,534,538,56
                                                                                                  8,2127,2129,2571,3926,3927,4317,44
                                                                                                  71,4702,4942,5174,5512,5581       
 J                          Local  2126     I(4)            4           scalar                    2177,2178,2179,2193,2194,2195,2209
                                                                                                  ,2210,2211,2224,2225,2227         
 LIST_P                     Dummy  2100     FIELD_DEF       400         scalar   ARG,PTR,INOUT    2135,2138,2139,2147,2154          
 LIST_TYPE                  Param  2138     I(4)            4           scalar                    2138,2159,2660,3230,5647,5656,5773
                                                                                                  ,5962,5976,6380,6395              
 NUM                        Local  2127     CHAR            48          scalar                    2179,2181,2195,2197,2211,2213,2225
                                                                                                  ,2227                             
 OUT_UNIT                   Dummy  2100     I(4)            4           scalar   ARG,IN           2136,2139,2147,2163,2166,2171,2174
                                                                                                  ,2180,2187,2190,2196,2203,2206,221
                                                                                                  2,2219,2221,2226,2233             
 RECURSIVE                  Dummy  2100     L(4)            4           scalar   ARG,IN           2161                              
 SCRATCH                    Local  2127     CHAR            48          scalar                    2173,2175,2178,2181,2189,2191,2194
                                                                                                  ,2197,2205,2207,2210,2213         
 SUCCESS                    Result 2100     L(4)            4           scalar                    2134,2144,2163,2164,2235          
 THIS_FIELD_P               Local  2128     FIELD_DEF       400         scalar   PTR              2154,2156,2158,2163,2166,2170,2171
                                                                                                  ,2172,2173,2174,2177,2178,2180,218
                                                                                                  6,2187,2188,2189,2190,2193,2194,21
                                                                                                  96,2202,2203,2204,2205,2206,2209,2
                                                                                                  210,2212,2218,2219,2220,2221,2222,
                                                                                                  2224,2226,2227,2233,2240          
 TRIM                       Func   2123                                 scalar                    2123,2136,2139,2147,2166,2171,2174
                                                                                                  ,2175,2180,2181,2187,2190,2191,219
                                                                                                  6,2197,2203,2206,2207,2212,2213,22
                                                                                                  19,2221,2222,2226,2227,2233       
 WARN_HEADER                Param  2123     CHAR            64          scalar                    2136,2139,2233                    

Page 62          Source Listing                  DUMP_LIST
2021-06-01 08:55                                 field_manager.F90

   2244 ! </FUNCTION> NAME="dump_list"
   2245 !</PRIVATE>
   2246 
   2247 !#######################################################################
   2248 !#######################################################################
   2249 
   2250 ! <PRIVATE><SUBROUTINE NAME="find_base">
   2251 !
   2252 ! <OVERVIEW>
   2253 !    A subroutine that splits a listname into a path and a base.
   2254 ! </OVERVIEW>
   2255 ! <DESCRIPTION>
   2256 !    Find the base name for a list by splitting the list name into
   2257 !    a path and base. The base is the last field within name, while the
   2258 !    path is the preceding section of name. The base string can then be
   2259 !    used to query for values associated with name.
   2260 ! </DESCRIPTION>
   2261 !   <TEMPLATE>
   2262 !     call find_base(name, path, base)
   2263 !   </TEMPLATE>
   2264 !
   2265 subroutine find_base(name, path, base)  !{
   2266 !
   2267 !   <IN NAME="name" TYPE="character(len=*)">
   2268 !   </IN>
   2269 !   <OUT NAME="path" TYPE="character(len=*)">
   2270 !      A string containing the path of the base field.
   2271 !   </OUT>
   2272 !   <OUT NAME="base" TYPE="character(len=*)">
   2273 !      A string which can be used to query for values associated with name.
   2274 !   </OUT>
   2275 !
   2276 !        arguments
   2277 !
   2278 character(len=*), intent(in)  :: name
   2279 character(len=*), intent(out) :: path
   2280 character(len=*), intent(out) :: base
   2281 
   2282 !+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   2283 !        local variables
   2284 !+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   2285 
   2286 integer :: i
   2287 integer :: length
   2288 
   2289 !
   2290 !        Check for the last occurrence of the list separator in name
   2291 !
   2292 ! The following max function is to work around an error in the IBM compiler for len_trim
   2293 length = max(len_trim(name),0)
   2294 
   2295 if (length .eq. 0) then  !{
   2296 
   2297 !
   2298 !       Empty name, so return empty path and base
   2299 !
   2300    path = ' '

Page 63          Source Listing                  FIND_BASE
2021-06-01 08:55                                 field_manager.F90

   2301    base = ' '
   2302 else  !}{
   2303 !
   2304 !       Remove trailing list separators
   2305 !
   2306    do while (name(length:length) .eq. list_sep)  !{
   2307       length = length - 1
   2308       if (length .eq. 0) then  !{
   2309          exit
   2310       endif  !}
   2311    enddo  !}
   2312    if (length .eq. 0) then  !{
   2313 
   2314 !
   2315 !       Name only list separators, so return empty path and base
   2316 !
   2317       path = ' '
   2318       base = ' '
   2319    else  !}{
   2320 !
   2321 !       Check for the last occurrence of the list separator in name
   2322 !
   2323       i = index(name(1:length), list_sep, back = .true.)
   2324       if (i .eq. 0) then  !{
   2325 !
   2326 !       no list separators in the path, so return an empty path
   2327 !       and name as the base
   2328 !
   2329          path = ' '
   2330          base = name(1:length)
   2331       else  !}{
   2332 !
   2333 !       Found a list separator, so return the part up to the last
   2334 !       list separator in path, and the remainder in base
   2335 !
   2336          path = name(1:i)
   2337          base = name(i+1:length)
   2338       endif  !}
   2339    endif  !}
   2340 endif  !}
   2341 
   2342 end subroutine find_base  !}

Page 64          Source Listing                  FIND_BASE
2021-06-01 08:55 Entry Points                    field_manager.F90



ENTRY POINTS

  Name                                       
                                             
 field_manager_mod_mp_find_base_             


SYMBOL CROSS REFERENCE

 Name                       Object Declared Type            Bytes Dimen Elements Attributes       References                        
                                                                                                                                    
 BASE                       Dummy  2265     CHAR                        scalar   ARG,OUT          2301,2318,2330,2337               
 FIND_BASE                  Subr   2265                                                                                             
 I                          Local  2286     I(4)            4           scalar                    2323,2324,2336,2337               
 INDEX                      Func   2323                                 scalar                    2323                              
 LENGTH                     Local  2287     I(4)            4           scalar                    2293,2295,2306,2307,2308,2312,2323
                                                                                                  ,2330,2337                        
 LEN_TRIM                   Func   2293                                 scalar                    2293                              
 MAX                        Func   2293                                 scalar                    2293                              
 NAME                       Dummy  2265     CHAR                        scalar   ARG,IN           2293,2306,2323,2330,2336,2337     
 PATH                       Dummy  2265     CHAR                        scalar   ARG,OUT          2300,2317,2329,2336               

Page 65          Source Listing                  FIND_BASE
2021-06-01 08:55                                 field_manager.F90

   2343 ! </SUBROUTINE> NAME="find_base"
   2344 !</PRIVATE>
   2345 !#######################################################################
   2346 !#######################################################################
   2347 
   2348 ! <PRIVATE><FUNCTION NAME="find_field">
   2349 !
   2350 ! <OVERVIEW>
   2351 !    Find and return a pointer to the field in the specified
   2352 !    list. Return a null pointer on error.
   2353 ! </OVERVIEW>
   2354 ! <DESCRIPTION>
   2355 !    Find and return a pointer to the field in the specified
   2356 !    list. Return a null pointer on error. Given a pointer to a field,
   2357 !    this function searchs for "name" as a sub field.
   2358 ! </DESCRIPTION>
   2359 !   <TEMPLATE>
   2360 !     field_p => find_field(name, this_list_p)
   2361 !   </TEMPLATE>
   2362 !
   2363 function find_field(name, this_list_p)                                &
   2364         result (field_p)  !{
   2365 !  <OUT NAME="field_p" TYPE="type(field_def), pointer">
   2366 !    A pointer to the field corresponding to "name" or an unassociated
   2367 !    pointer if the field name does not exist.
   2368 !  </OUT>
   2369 !  <IN NAME="name" TYPE="character(len=*)">
   2370 !    The name of a field that the user wishes to find.
   2371 !  </IN>
   2372 !  <IN NAME="this_list_p" TYPE="type(field_def), pointer">
   2373 !    A pointer to a list which the user wishes to search for a field "name".
   2374 !  </IN>
   2375 !
   2376 !        Function definition
   2377 !
   2378 type (field_def), pointer    :: field_p
   2379 !
   2380 !        arguments
   2381 !
   2382 character(len=*), intent(in) :: name
   2383 type (field_def), pointer    :: this_list_p
   2384 
   2385 !+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   2386 !        local variables
   2387 !+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   2388 type (field_def), pointer, save    :: temp_p
   2389 
   2390 
   2391 nullify (field_p)
   2392 
   2393 if (name .eq. '.') then  !{
   2394 
   2395 !
   2396 !        If the field is '.' then return this list
   2397 !
   2398   field_p => this_list_p
   2399 elseif (name .eq. '..') then  !}{

Page 66          Source Listing                  FIND_FIELD
2021-06-01 08:55                                 field_manager.F90

   2400 !
   2401 !        If the field is '..' then return the parent list
   2402 !
   2403   field_p => this_list_p%parent
   2404 else  !}{
   2405 !
   2406 !        Loop over each field in this list
   2407 !
   2408   temp_p => this_list_p%first_field
   2409 
   2410   do while (associated(temp_p))  !{
   2411 !
   2412 !        If the name matches, then set the return pointer and exit
   2413 !        the loop
   2414 !
   2415     if (temp_p%name .eq. name) then  !{
   2416       field_p => temp_p
   2417       exit
   2418     endif  !}
   2419 
   2420     temp_p => temp_p%next
   2421 
   2422   enddo  !}
   2423 endif  !}
   2424 
   2425 end function find_field  !}


ENTRY POINTS

  Name                                        
                                              
 field_manager_mod_mp_find_field_             

Page 67          Source Listing                  FIND_FIELD
2021-06-01 08:55 Symbol Table                    field_manager.F90



SYMBOL CROSS REFERENCE

 Name                       Object Declared Type            Bytes Dimen Elements Attributes       References                        
                                                                                                                                    
 ASSOCIATED                 Func   2410                                 scalar                    2410                              
 FIELD_P                    Local  2378     FIELD_DEF       400         scalar   PTR              2391,2398,2403,2416               
 FIND_FIELD                 Func   2363     FIELD_DEF       400         scalar   PTR                                                
 NAME                       Dummy  2363     CHAR                        scalar   ARG,IN           2393,2399,2415                    
 TEMP_P                     Local  2388     FIELD_DEF       400         scalar   PTR,TGT,SAVE     2408,2410,2415,2416,2420          
 THIS_LIST_P                Dummy  2363     FIELD_DEF       400         scalar   ARG,PTR,TGT      2398,2403,2408                    
                                                                                 INOUT                                              

Page 68          Source Listing                  FIND_FIELD
2021-06-01 08:55                                 field_manager.F90

   2426 ! </FUNCTION> NAME="find_field"
   2427 !</PRIVATE>
   2428 
   2429 !#######################################################################
   2430 !#######################################################################
   2431 
   2432 ! <PRIVATE><SUBROUTINE NAME="find_head">
   2433 !
   2434 ! <OVERVIEW>
   2435 !    Find the first list for a name by splitting the name into
   2436 !    a head and the rest.
   2437 ! </OVERVIEW>
   2438 ! <DESCRIPTION>
   2439 !   Find the first list for a name by splitting the name into a head and the
   2440 ! rest. The head is the first field within name, while rest is the remaining
   2441 ! section of name. The head string can then be used to find other fields that
   2442 ! may be associated with name.
   2443 ! </DESCRIPTION>
   2444 !   <TEMPLATE>
   2445 !     call find_head(name, head, rest)
   2446 !   </TEMPLATE>
   2447 !
   2448 subroutine find_head(name, head, rest)  !{
   2449 !
   2450 !   <IN NAME="name" TYPE="character(len=*)">
   2451 !      The name of a field of interest.
   2452 !   </IN>
   2453 !   <OUT NAME="head" TYPE="character(len=*)">
   2454 !      head is the first field within name.
   2455 !   </OUT>
   2456 !   <OUT NAME="rest" TYPE="character(len=*)">
   2457 !      rest is the remaining section of name.
   2458 !   </OUT>
   2459 !
   2460 !        arguments
   2461 !
   2462 character(len=*), intent(in)  :: name
   2463 character(len=*), intent(out) :: head
   2464 character(len=*), intent(out) :: rest
   2465 
   2466 !+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   2467 !        local variables
   2468 !+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   2469 integer        :: i
   2470 !
   2471 !        Check for the first occurrence of the list separator in name
   2472 !
   2473 i = index(name, list_sep)
   2474 !
   2475 !        Check for additional consecutive list separators and return
   2476 !        those also
   2477 !
   2478 do while (i .le. len(name))  !{
   2479   if (name(i+1:i+1) .eq. list_sep) then  !{
   2480     i = i + 1
   2481   else  !}{
   2482     exit

Page 69          Source Listing                  FIND_HEAD
2021-06-01 08:55                                 field_manager.F90

   2483   endif  !}
   2484 enddo  !}
   2485 
   2486 if (i .eq. 0) then  !{
   2487 !
   2488 !        no list separators in the path, so return an empty head and
   2489 !        name as the rest
   2490 !
   2491   head = ' '
   2492   rest = name
   2493 elseif (i .eq. len(name)) then  !}{
   2494 !
   2495 !        The last character in name is a list separator, so return name
   2496 !        as head and an empty rest
   2497 !
   2498   head = name
   2499   rest = ' '
   2500 else  !}{
   2501 !
   2502 !        Found a list separator, so return the part up to the list
   2503 !        separator in head, and the remainder in rest
   2504 !
   2505   head = name(1:i)
   2506   rest = name(i+1:)
   2507 endif  !}
   2508 
   2509 end subroutine find_head  !}


ENTRY POINTS

  Name                                       
                                             
 field_manager_mod_mp_find_head_             

Page 70          Source Listing                  FIND_HEAD
2021-06-01 08:55 Symbol Table                    field_manager.F90



SYMBOL CROSS REFERENCE

 Name                       Object Declared Type            Bytes Dimen Elements Attributes       References                        
                                                                                                                                    
 FIND_HEAD                  Subr   2448                                                                                             
 HEAD                       Dummy  2448     CHAR                        scalar   ARG,OUT          2491,2498,2505                    
 I                          Local  2469     I(4)            4           scalar                    2473,2478,2479,2480,2486,2493,2505
                                                                                                  ,2506                             
 INDEX                      Func   2473                                 scalar                    2473                              
 LEN                        Func   2478                                 scalar                    2478,2493                         
 NAME                       Dummy  2448     CHAR                        scalar   ARG,IN           2473,2478,2479,2492,2493,2498,2505
                                                                                                  ,2506                             
 REST                       Dummy  2448     CHAR                        scalar   ARG,OUT          2492,2499,2506                    

Page 71          Source Listing                  FIND_HEAD
2021-06-01 08:55                                 field_manager.F90

   2510 ! </SUBROUTINE> NAME="find_head"
   2511 !</PRIVATE>
   2512 
   2513 !#######################################################################
   2514 !#######################################################################
   2515 
   2516 ! <PRIVATE><FUNCTION NAME="find_list">
   2517 !
   2518 ! <OVERVIEW>
   2519 !    Find and return a pointer to the specified list, relative to
   2520 !    relative_p. Return a null pointer on error.
   2521 ! </OVERVIEW>
   2522 ! <DESCRIPTION>
   2523 !    This function, when supplied a pointer to a field and a name of a second
   2524 !    field relative to that pointer, will find a list and return the pointer to
   2525 !    the second field. If create is .true. and the second field does not exist,
   2526 !    it will be created.
   2527 ! </DESCRIPTION>
   2528 !   <TEMPLATE>
   2529 !     list_p => find_list(path, relative_p, create)
   2530 !   </TEMPLATE>
   2531 !
   2532 function find_list(path, relative_p, create)                    &
   2533         result (list_p)  !{
   2534 !
   2535 !   <OUT NAME="list_p" TYPE="type(field_def), pointer">
   2536 !     A pointer to the list to be returned.
   2537 !   </OUT>
   2538 !   <IN NAME="path" TYPE="character(len=*)">
   2539 !     A path to the list of interest.
   2540 !   </IN>
   2541 !   <IN NAME="list_p" TYPE="type(field_def), pointer">
   2542 !     A pointer to the list to which "path" is relative to.
   2543 !   </IN>
   2544 !   <IN NAME="create" TYPE="logical">
   2545 !     If the list does not exist, having create = .true. will create it.
   2546 !   </IN>
   2547 !
   2548 !        Function definition
   2549 !
   2550 type (field_def), pointer        :: list_p
   2551 !
   2552 !        arguments
   2553 !
   2554 character(len=*), intent(in)     :: path
   2555 type (field_def), pointer        :: relative_p
   2556 logical,          intent(in)     :: create
   2557 
   2558 !+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   2559 !        local parameters
   2560 !+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   2561 character(len=9),  parameter :: sub_name     = 'find_list'
   2562 character(len=64), parameter :: warn_header  = '==>Warning from ' // trim(module_name) //  &
   2563                                                '(' // trim(sub_name) // '): '
   2564 character(len=64), parameter :: note_header  = '==>Note from ' // trim(module_name)    //  &
   2565                                                '(' // trim(sub_name) // '): '
   2566 !+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

Page 72          Source Listing                  FIND_LIST
2021-06-01 08:55                                 field_manager.F90

   2567 !        local variables
   2568 !+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   2569 character(len=fm_path_name_len)  :: working_path
   2570 character(len=fm_path_name_len)  :: rest
   2571 character(len=fm_field_name_len) :: this_list
   2572 integer                          :: i, out_unit
   2573 type (field_def), pointer, save  :: working_path_p
   2574 type (field_def), pointer, save  :: this_list_p
   2575 
   2576 
   2577 out_unit = stdout()
   2578 nullify(list_p)
   2579 !
   2580 !        If the path is empty, then return the relative list
   2581 !
   2582 if (path .eq. ' ') then  !{
   2583 
   2584   list_p => relative_p
   2585 
   2586 else  !}{
   2587 !
   2588 !        If a fully qualified path is given (i.e., starts with the
   2589 !        list separator) then do everything relative to root,
   2590 !        otherwise, do everything relative to relative list.
   2591 !
   2592   if (path(1:1) .eq. list_sep) then  !{
   2593     working_path_p => root_p
   2594     working_path = path(2:)
   2595   else  !}{
   2596     working_path_p => relative_p
   2597     working_path = path
   2598   endif  !}
   2599 !
   2600 !        Loop over each field in the path
   2601 !
   2602   do while (working_path .ne. ' ')  !{
   2603 !
   2604 !        Get the first list in the working path
   2605 !
   2606     call find_head(working_path, this_list, rest)
   2607 !
   2608 !        If the first list is empty, then the 'rest' should hold the
   2609 !        final field in the path
   2610 !
   2611     if (this_list .eq. ' ') then  !{
   2612       this_list = rest
   2613       rest = ' '
   2614     endif  !}
   2615 !
   2616 !        Strip off trailing list separators
   2617 !
   2618     i = len_trim(this_list)
   2619     do while (i .gt. 0 .and. this_list(i:i) .eq. list_sep)  !{
   2620       this_list(i:i) = ' '
   2621       i = i - 1
   2622     enddo  !}
   2623 !

Page 73          Source Listing                  FIND_LIST
2021-06-01 08:55                                 field_manager.F90

   2624 !        Find a pointer to this field in the working list
   2625 !
   2626     this_list_p => find_field(this_list, working_path_p)
   2627 
   2628     if (.not. associated(this_list_p)) then  !{
   2629       if (create) then  !{
   2630 !
   2631 !        Create the list if so requested
   2632 !
   2633         this_list_p => make_list(working_path_p, this_list)
   2634         if (.not. associated(this_list_p)) then  !{
   2635           if (verb .gt. verb_level_warn) then  !{
   2636             write (out_unit,*) trim(warn_header), 'List "',       &
   2637                  trim(this_list), '" could not be created in ',   &
   2638                  trim(path)
   2639           endif  !}
   2640           nullify(list_p)
   2641           return
   2642         endif  !}
   2643       else  !}{
   2644 !
   2645 !        Otherwise, return an error
   2646 !
   2647 
   2648         if (verb .gt. verb_level_note) then  !{
   2649           write (out_unit,*) trim(note_header), 'List "',         &
   2650                trim(this_list), '" does not exist in ', trim(path)
   2651         endif  !}
   2652         nullify(list_p)
   2653         return
   2654       endif  !}
   2655     endif  !}
   2656 !
   2657 !        Make sure that the field found is a list, and if so, proceed to
   2658 !        the next field in the path, otherwise, return an error
   2659 !
   2660     if (this_list_p%field_type .eq. list_type) then  !{
   2661       working_path_p => this_list_p
   2662       working_path = rest
   2663     else  !}{
   2664       if (verb .gt. verb_level_warn) then  !{
   2665         write (out_unit,*) trim(warn_header), '"',                &
   2666              trim(this_list), '" is not a list in ', trim(path)
   2667       endif  !}
   2668       nullify(list_p)
   2669       return
   2670     endif  !}
   2671   enddo  !}
   2672   list_p => working_path_p
   2673 endif  !}
   2674 
   2675 end function find_list  !}

Page 74          Source Listing                  FIND_LIST
2021-06-01 08:55 Entry Points                    field_manager.F90



ENTRY POINTS

  Name                                       
                                             
 field_manager_mod_mp_find_list_             


SYMBOL CROSS REFERENCE

 Name                       Object Declared Type            Bytes Dimen Elements Attributes       References                        
                                                                                                                                    
 ASSOCIATED                 Func   2628                                 scalar                    2628,2634                         
 CREATE                     Dummy  2532     L(4)            4           scalar   ARG,IN           2629                              
 FIND_FIELD                 Func   2626     RECORD          400         scalar   PTR,PRIV         288,2626,4543,4778,5015,5250,5526,
                                                                                                  5531,5595,5604,5743,6160          
 FIND_HEAD                  Subr   2606                                          PRIV             289,2606                          
 FIND_LIST                  Func   2532     FIELD_DEF       400         scalar   PTR                                                
 I                          Local  2572     I(4)            4           scalar                    2618,2619,2620,2621               
 LEN_TRIM                   Func   2618                                 scalar                    2618                              
 LIST_P                     Local  2550     FIELD_DEF       400         scalar   PTR              2578,2584,2640,2652,2668,2672     
 MAKE_LIST                  Func   2633     RECORD          400         scalar   PTR,PRIV         293,2633,4363                     
 NOTE_HEADER                Param  2564     CHAR            64          scalar                    2649                              
 OUT_UNIT                   Local  2572     I(4)            4           scalar                    2577,2636,2649,2665               
 PATH                       Dummy  2532     CHAR                        scalar   ARG,IN           2582,2592,2594,2597,2638,2650,2666
 RELATIVE_P                 Dummy  2532     FIELD_DEF       400         scalar   ARG,PTR,TGT      2584,2596                         
                                                                                 INOUT                                              
 REST                       Local  2570     CHAR            512         scalar                    2606,2612,2613,2662               
 ROOT_P                     Local  2593     FIELD_DEF       400         scalar   PTR,TGT          585,2593,2820,2821,2826,2830,2831,
                                                                                                  2835,2836,2841,5456,5457,5461,5644
                                                                                                  ,5654                             
 SUB_NAME                   Param  2561     CHAR            9           scalar                    2563,2565                         
 THIS_LIST                  Local  2571     CHAR            48          scalar                    2606,2611,2612,2618,2619,2620,2626
                                                                                                  ,2633,2637,2650,2666              
 THIS_LIST_P                Local  2574     FIELD_DEF       400         scalar   PTR,TGT,SAVE     2626,2628,2633,2634,2660,2661     
 TRIM                       Func   2562                                 scalar                    2562,2563,2564,2565,2636,2637,2638
                                                                                                  ,2649,2650,2665,2666              
 WARN_HEADER                Param  2562     CHAR            64          scalar                    2636,2665                         
 WORKING_PATH               Local  2569     CHAR            512         scalar                    2594,2597,2602,2606,2662          
 WORKING_PATH_P             Local  2573     FIELD_DEF       400         scalar   PTR,TGT,SAVE     2593,2596,2626,2633,2661,2672     

Page 75          Source Listing                  FIND_LIST
2021-06-01 08:55                                 field_manager.F90

   2676 ! </FUNCTION> NAME="find_list"
   2677 !</PRIVATE>
   2678 
   2679 !#######################################################################
   2680 !#######################################################################
   2681 
   2682 ! <FUNCTION NAME="fm_change_list">
   2683 !
   2684 ! <OVERVIEW>
   2685 !    Change the current list. Return true on success,
   2686 !    false otherwise
   2687 ! </OVERVIEW>
   2688 ! <DESCRIPTION>
   2689 !    This function changes the currect list to correspond to the list named name.
   2690 !    If the first character of name is the list separator (/) then the list will
   2691 !    search for "name" starting from the root of the field tree. Otherwise it
   2692 !    will search for name starting from the current list.
   2693 ! </DESCRIPTION>
   2694 !   <TEMPLATE>
   2695 !     success = fm_change_list(name)
   2696 !   </TEMPLATE>
   2697 !
   2698 function fm_change_list(name)                                        &
   2699         result (success)  !{
   2700 !   <OUT NAME="success" TYPE="logical">
   2701 !     A flag to indicate whether the function operated with (FALSE) or
   2702 !     without (TRUE) errors.
   2703 !   </OUT>
   2704 !   <IN NAME="name" TYPE="character(len=*)">
   2705 !     The name of a list that the user wishes to change to.
   2706 !   </IN>
   2707 !
   2708 !        Function definition
   2709 !
   2710 logical        :: success
   2711 !
   2712 !        arguments
   2713 !
   2714 character(len=*), intent(in)  :: name
   2715 
   2716 !+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   2717 !        local variables
   2718 !+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   2719 type (field_def), pointer, save :: temp_p
   2720 !
   2721 !        Initialize the field manager if needed
   2722 !
   2723 if (.not. module_is_initialized) then  !{
   2724   call initialize
   2725 endif  !}
   2726 !
   2727 !        Find the list if path is not empty
   2728 !
   2729 temp_p => find_list(name, current_list_p, .false.)
   2730 
   2731 if (associated(temp_p)) then  !{
   2732   current_list_p => temp_p

Page 76          Source Listing                  FM_CHANGE_LIST
2021-06-01 08:55                                 field_manager.F90

   2733   success = .true.
   2734 else  !}{
   2735   success = .false.
   2736 endif  !}
   2737 
   2738 end function fm_change_list  !}


ENTRY POINTS

  Name                                            
                                                  
 field_manager_mod_mp_fm_change_list_             


SYMBOL CROSS REFERENCE

 Name                       Object Declared Type            Bytes Dimen Elements Attributes       References                        
                                                                                                                                    
 ASSOCIATED                 Func   2731                                 scalar                    2731                              
 CURRENT_LIST_P             Local  2729     FIELD_DEF       400         scalar   PTR,TGT          584,2729,2732,2813,2841,2912,2916,
                                                                                                  2982,3056,3119,3224,3317,3425,3548
                                                                                                  ,3674,3803,3965,4044,4156,4163,423
                                                                                                  1,4233,4357,4369,4540,4775,5012,52
                                                                                                  47,5593,5604,5671,5857,5866,6128,6
                                                                                                  134,6273,6279                     
 FIND_LIST                  Func   2729     RECORD          400         scalar   PTR,PRIV         290,2729,2813,2916,3965,4043,4163,
                                                                                                  4233,4357,4540,4775,5012,5247,5524
                                                                                                  ,5593,5857,5866,6134,6159,6279    
 FM_CHANGE_LIST             Func   2698     L(4)            4           scalar                                                      
 NAME                       Dummy  2698     CHAR                        scalar   ARG,IN           2729                              
 SUCCESS                    Local  2710     L(4)            4           scalar                    2733,2735                         
 TEMP_P                     Local  2719     FIELD_DEF       400         scalar   PTR,TGT,SAVE     2729,2731,2732                    

Page 77          Source Listing                  FM_CHANGE_LIST
2021-06-01 08:55                                 field_manager.F90

   2739 ! </FUNCTION> NAME="fm_change_list"
   2740 
   2741 !#######################################################################
   2742 !#######################################################################
   2743 
   2744 ! <FUNCTION NAME="fm_change_root">
   2745 !
   2746 ! <OVERVIEW>
   2747 !    Change the root list
   2748 ! </OVERVIEW>
   2749 ! <DESCRIPTION>
   2750 !    This function changes the root of the field tree to correspond to the
   2751 !    field named name. An example of a use of this would be if code is
   2752 !    interested in a subset of fields with a common base. This common base
   2753 !    could be set using fm_change_root and fields could be referenced using
   2754 !    this root.
   2755 !
   2756 !    This function should be used in conjunction with fm_return_root.
   2757 !
   2758 ! </DESCRIPTION>
   2759 !   <TEMPLATE>
   2760 !     success = fm_change_root(name)
   2761 !   </TEMPLATE>
   2762 !
   2763 function  fm_change_root(name)                                        &
   2764           result (success)  !{
   2765 !
   2766 !   <OUT NAME="success" TYPE="logical">
   2767 !     A flag to indicate whether the function operated with (FALSE) or
   2768 !     without (TRUE) errors.
   2769 !   </OUT>
   2770 !   <IN NAME="name" TYPE="character(len=*)">
   2771 !     The name of the field which the user wishes to become the root.
   2772 !   </IN>
   2773 !
   2774 !        Function definition
   2775 !
   2776 logical        :: success
   2777 !
   2778 !        arguments
   2779 !
   2780 character(len=*), intent(in)  :: name
   2781 
   2782 !+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   2783 !        local parameters
   2784 !+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   2785 character(len=14), parameter :: sub_name     = 'fm_change_root'
   2786 character(len=64), parameter :: warn_header  = '==>Warning from ' // trim(module_name) //  &
   2787                                                '(' // trim(sub_name) // '): '
   2788 !+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   2789 !        local variables
   2790 !+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   2791 type (field_def), pointer, save :: temp_list_p
   2792 integer :: out_unit
   2793 !
   2794 !        Initialize the field manager if needed
   2795 !

Page 78          Source Listing                  FM_CHANGE_ROOT
2021-06-01 08:55                                 field_manager.F90

   2796 if (.not. module_is_initialized) then  !{
   2797   call initialize
   2798 endif  !}
   2799 out_unit = stdout()
   2800 !
   2801 !        Must supply a field field name
   2802 !
   2803 if (name .eq. ' ') then  !{
   2804   if (verb .gt. verb_level_warn) then  !{
   2805     write (out_unit,*) trim(warn_header), 'Must supply a field name'
   2806   endif  !}
   2807   success = .false.
   2808   return
   2809 endif  !}
   2810 !
   2811 !        Get a pointer to the list
   2812 !
   2813 temp_list_p => find_list(name, current_list_p, .false.)
   2814 
   2815 if (associated(temp_list_p)) then  !{
   2816 !
   2817 !        restore the saved root values if we've already changed root
   2818 !
   2819   if (save_root_name .ne. ' ') then  !{
   2820     root_p%name = save_root_name
   2821     root_p%parent => save_root_parent_p
   2822   endif  !}
   2823 !
   2824 !        set the pointer for the new root field
   2825 !
   2826   root_p => temp_list_p
   2827 !
   2828 !        save the new root field's name and parent
   2829 !
   2830   save_root_name = root_p%name
   2831   save_root_parent_p => root_p%parent
   2832 !
   2833 !        set the new root name and parent fields to appropriate values
   2834 !
   2835   root_p%name = ' '
   2836   nullify(root_p%parent)
   2837 !
   2838 !        set the current list to the new root as it likely is not
   2839 !        going to be meaningful anymore
   2840 !
   2841   current_list_p => root_p
   2842   success = .true.
   2843 else  !}{
   2844 !
   2845 !        Couldn't find the list
   2846 !
   2847 
   2848   if (verb .gt. verb_level_warn) then  !{
   2849     write (out_unit,*) trim(warn_header),                      &
   2850          'Could not find list ', trim(name)
   2851   endif  !}
   2852   success = .false.

Page 79          Source Listing                  FM_CHANGE_ROOT
2021-06-01 08:55                                 field_manager.F90

   2853 endif  !}
   2854 
   2855 end function  fm_change_root  !}


ENTRY POINTS

  Name                                            
                                                  
 field_manager_mod_mp_fm_change_root_             


SYMBOL CROSS REFERENCE

 Name                       Object Declared Type            Bytes Dimen Elements Attributes       References                        
                                                                                                                                    
 ASSOCIATED                 Func   2815                                 scalar                    2815                              
 FM_CHANGE_ROOT             Func   2763     L(4)            4           scalar                                                      
 NAME                       Dummy  2763     CHAR                        scalar   ARG,IN           2803,2813,2850                    
 OUT_UNIT                   Local  2792     I(4)            4           scalar                    2799,2805,2849                    
 SAVE_ROOT_NAME             Local  2819     CHAR            48          scalar                    2819,2820,2830,5456,5465,5677     
 SAVE_ROOT_PARENT_P         Local  2821     FIELD_DEF       400         scalar   PTR,TGT          586,2821,2831,5457,5466,5676      
 SUB_NAME                   Param  2785     CHAR            14          scalar                    2787                              
 SUCCESS                    Local  2776     L(4)            4           scalar                    2807,2842,2852                    
 TEMP_LIST_P                Local  2791     FIELD_DEF       400         scalar   PTR,TGT,SAVE     2813,2815,2826                    
 TRIM                       Func   2786                                 scalar                    2786,2787,2805,2849,2850          
 WARN_HEADER                Param  2786     CHAR            64          scalar                    2805,2849                         

Page 80          Source Listing                  FM_CHANGE_ROOT
2021-06-01 08:55                                 field_manager.F90

   2856 ! </FUNCTION> NAME="fm_change_root"
   2857 
   2858 !#######################################################################
   2859 !#######################################################################
   2860 
   2861 ! <FUNCTION NAME="fm_dump_list">
   2862 !
   2863 ! <OVERVIEW>
   2864 !    A function to list properties associated with a field.
   2865 ! </OVERVIEW>
   2866 ! <DESCRIPTION>
   2867 !    This function writes the contents of the field named "name" to stdout.
   2868 !    If recursive is present and .true., then this function writes out the
   2869 !    contents of any subfields associated with the field named "name".
   2870 ! </DESCRIPTION>
   2871 !   <TEMPLATE>
   2872 !     success = fm_dump_list(name, recursive = .true.)
   2873 !   </TEMPLATE>
   2874 !
   2875 logical function  fm_dump_list(name, recursive, unit) result (success)
   2876   character(len=*), intent(in)  :: name
   2877   logical, intent(in), optional :: recursive
   2878   integer, intent(in), optional :: unit ! file to print to
   2879 !   <OUT NAME="success" TYPE="logical">
   2880 !     A flag to indicate whether the function operated with (FALSE) or
   2881 !     without (TRUE) errors.
   2882 !   </OUT>
   2883 !   <IN NAME="name" TYPE="character(len=*)">
   2884 !     The name of the field for which output is requested.
   2885 !   </IN>
   2886 !   <IN NAME="recursive" TYPE="logical, optional">
   2887 !     If present and .true., then a recursive listing of fields will be
   2888 !     performed.
   2889 !   </IN>
   2890 
   2891 ! ---- local parameters
   2892   character(len=12), parameter :: sub_name     = 'fm_dump_list'
   2893   character(len=64), parameter :: warn_header  = '==>Warning from ' // trim(module_name) //  &
   2894                                                '(' // trim(sub_name) // '): '
   2895 ! ---- local variables
   2896   logical                         :: recursive_t
   2897   type (field_def), pointer, save :: temp_list_p
   2898   integer                         :: out_unit
   2899 
   2900   if (present(unit)) then
   2901      out_unit = unit
   2902   else
   2903      out_unit = stdout()
   2904   endif
   2905 
   2906   recursive_t = .false.
   2907   if (present(recursive)) recursive_t = recursive
   2908   if (.not. module_is_initialized) call initialize()
   2909 
   2910   if (name .eq. ' ') then
   2911 ! If list is empty, then dump the current list
   2912     temp_list_p => current_list_p

Page 81          Source Listing                  FM_DUMP_LIST
2021-06-01 08:55                                 field_manager.F90

   2913     success = .true.
   2914   else
   2915 ! Get a pointer to the list
   2916     temp_list_p => find_list(name, current_list_p, .false.)
   2917     if (associated(temp_list_p)) then
   2918        success = .true.
   2919     else
   2920 ! Error following the path
   2921        if (verb .gt. verb_level_warn) then
   2922           write (out_unit,*) trim(warn_header), 'Could not follow path for ', trim(name)
   2923        endif
   2924        success = .false.
   2925     endif
   2926   endif
   2927 ! Dump the list
   2928   if (success) then
   2929       success = dump_list(temp_list_p, recursive_t, 0, out_unit)
   2930   endif
   2931 end function  fm_dump_list


ENTRY POINTS

  Name                                          
                                                
 field_manager_mod_mp_fm_dump_list_             


SYMBOL CROSS REFERENCE

 Name                       Object Declared Type            Bytes Dimen Elements Attributes       References                        
                                                                                                                                    
 ASSOCIATED                 Func   2917                                 scalar                    2917                              
 FM_DUMP_LIST               Func   2875     L(4)            4           scalar                                                      
 NAME                       Dummy  2875     CHAR                        scalar   ARG,IN           2910,2916,2922                    
 OUT_UNIT                   Local  2898     I(4)            4           scalar                    2901,2903,2922,2929               
 PRESENT                    Func   2900                                 scalar                    2900,2907                         
 RECURSIVE                  Dummy  2875     L(4)            4           scalar   ARG,IN           2907                              
 RECURSIVE_T                Local  2896     L(4)            4           scalar                    2906,2907,2929                    
 SUB_NAME                   Param  2892     CHAR            12          scalar                    2894                              
 SUCCESS                    Result 2875     L(4)            4           scalar                    2913,2918,2924,2928,2929          
 TEMP_LIST_P                Local  2897     FIELD_DEF       400         scalar   PTR,SAVE         2912,2916,2917,2929               
 TRIM                       Func   2893                                 scalar                    2893,2894,2922                    
 UNIT                       Dummy  2875     I(4)            4           scalar   ARG,IN           2900,2901                         
 WARN_HEADER                Param  2893     CHAR            64          scalar                    2922                              

Page 82          Source Listing                  FM_DUMP_LIST
2021-06-01 08:55                                 field_manager.F90

   2932 ! </FUNCTION> NAME="fm_dump_list"
   2933 
   2934 !#######################################################################
   2935 !#######################################################################
   2936 
   2937 ! <FUNCTION NAME="fm_exists">
   2938 !
   2939 ! <OVERVIEW>
   2940 !   A function to test whether a named field exists.
   2941 ! </OVERVIEW>
   2942 ! <DESCRIPTION>
   2943 !   This function determines is a field exists, relative to the current list,
   2944 !   and returns true if the list exists, false otherwise.
   2945 ! </DESCRIPTION>
   2946 !   <TEMPLATE>
   2947 !     success = fm_exists(name)
   2948 !   </TEMPLATE>
   2949 !
   2950 function fm_exists(name)                                                &
   2951         result (success)  !{
   2952 !
   2953 !   <IN NAME="name" TYPE="character(len=*)">
   2954 !     The name of the field that is being queried.
   2955 !   </IN>
   2956 !   <OUT NAME="success" TYPE="logical">
   2957 !     A flag to indicate whether the function operated with (FALSE) or
   2958 !     without (TRUE) errors.
   2959 !   </OUT>
   2960 !
   2961 !        Function definition
   2962 !
   2963 logical        :: success
   2964 !
   2965 !        arguments
   2966 !
   2967 character(len=*), intent(in) :: name
   2968 
   2969 !+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   2970 !        local variables
   2971 !+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   2972 type (field_def), pointer, save :: dummy_p
   2973 !
   2974 !        Initialize the field manager if needed
   2975 !
   2976 if (.not. module_is_initialized) then  !{
   2977   call initialize
   2978 endif  !}
   2979 !
   2980 !        Determine whether the field exists
   2981 !
   2982 dummy_p => get_field(name, current_list_p)
   2983 success = associated(dummy_p)
   2984 
   2985 end function fm_exists  !}

Page 83          Source Listing                  FM_EXISTS
2021-06-01 08:55 Entry Points                    field_manager.F90



ENTRY POINTS

  Name                                       
                                             
 field_manager_mod_mp_fm_exists_             


SYMBOL CROSS REFERENCE

 Name                       Object Declared Type            Bytes Dimen Elements Attributes       References                        
                                                                                                                                    
 ASSOCIATED                 Func   2983                                 scalar                    2983                              
 DUMMY_P                    Local  2972     FIELD_DEF       400         scalar   PTR,SAVE         2982,2983                         
 FM_EXISTS                  Func   2950     L(4)            4           scalar                                                      
 GET_FIELD                  Func   2982     RECORD          400         scalar   PTR,PRIV         291,2982,3056,3224,3317,3425,3548,
                                                                                                  3674,3803                         
 NAME                       Dummy  2950     CHAR                        scalar   ARG,IN           2982                              
 SUCCESS                    Local  2963     L(4)            4           scalar                    2983                              

Page 84          Source Listing                  FM_EXISTS
2021-06-01 08:55                                 field_manager.F90

   2986 ! </FUNCTION> NAME="fm_exists"
   2987 
   2988 !#######################################################################
   2989 !#######################################################################
   2990 
   2991 ! <FUNCTION NAME="fm_get_index">
   2992 !
   2993 ! <OVERVIEW>
   2994 !    A function to return the index of a named field.
   2995 ! </OVERVIEW>
   2996 ! <DESCRIPTION>
   2997 !    Returns the index for name, returns the parameter NO_FIELD if it does not
   2998 !    exist. If the first character of the named field is the list peparator,
   2999 !    then the named field will be relative to the root of the field tree.
   3000 !    Otherwise the named field will be relative to the current list.
   3001 ! </DESCRIPTION>
   3002 !   <TEMPLATE>
   3003 !     index = fm_get_index(name)
   3004 !   </TEMPLATE>
   3005 !
   3006 function  fm_get_index(name)                        &
   3007           result (index)  !{
   3008 !   <OUT NAME="index" TYPE="index">
   3009 !     The index of the named field if it exists.
   3010 !     Otherwise the parameter NO_FIELD.
   3011 !   </OUT>
   3012 !   <IN NAME="name" TYPE="character(len=*)">
   3013 !     The name of a field that the user wishes to get an index for.
   3014 !   </IN>
   3015 !
   3016 !        Function definition
   3017 !
   3018 integer        :: index
   3019 !
   3020 !        arguments
   3021 !
   3022 character(len=*), intent(in) :: name
   3023 
   3024 !+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   3025 !        local parameters
   3026 !+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   3027 character(len=12), parameter :: sub_name     = 'fm_get_index'
   3028 character(len=64), parameter :: warn_header  = '==>Warning from ' // trim(module_name) //  &
   3029                                                '(' // trim(sub_name) // '): '
   3030 !+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   3031 !        local variables
   3032 !+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   3033 type (field_def), pointer, save :: temp_field_p
   3034 integer                         :: out_unit
   3035 
   3036 out_unit = stdout()
   3037 !
   3038 !        Initialize the field manager if needed
   3039 !
   3040 if (.not. module_is_initialized) then  !{
   3041   call initialize
   3042 endif  !}

Page 85          Source Listing                  FM_GET_INDEX
2021-06-01 08:55                                 field_manager.F90

   3043 !
   3044 !        Must supply a field field name
   3045 !
   3046 if (name .eq. ' ') then  !{
   3047   if (verb .gt. verb_level_warn) then  !{
   3048     write (out_unit,*) trim(warn_header), 'Must supply a field name'
   3049   endif  !}
   3050   index = NO_FIELD
   3051   return
   3052 endif  !}
   3053 !
   3054 !        Get a pointer to the field
   3055 !
   3056 temp_field_p => get_field(name, current_list_p)
   3057 if (associated(temp_field_p)) then  !{
   3058 !
   3059 !        Set the index
   3060 !
   3061   index = temp_field_p%index
   3062 else  !}{
   3063 !
   3064 !        Error following the path
   3065 !
   3066   if (verb .gt. verb_level_warn) then  !{
   3067     write (out_unit,*) trim(warn_header), 'Could not follow path for ', trim(name)
   3068   endif  !}
   3069   index = NO_FIELD
   3070 endif  !}
   3071 
   3072 end function  fm_get_index  !}

Page 86          Source Listing                  FM_GET_INDEX
2021-06-01 08:55 Entry Points                    field_manager.F90



ENTRY POINTS

  Name                                          
                                                
 field_manager_mod_mp_fm_get_index_             


SYMBOL CROSS REFERENCE

 Name                       Object Declared Type            Bytes Dimen Elements Attributes       References                        
                                                                                                                                    
 ASSOCIATED                 Func   3057                                 scalar                    3057                              
 FM_GET_INDEX               Func   3006     I(4)            4           scalar                                                      
 INDEX                      Local  3018     I(4)            4           scalar                    3050,3061,3069                    
 NAME                       Dummy  3006     CHAR                        scalar   ARG,IN           3046,3056,3067                    
 OUT_UNIT                   Local  3034     I(4)            4           scalar                    3036,3048,3067                    
 SUB_NAME                   Param  3027     CHAR            12          scalar                    3029                              
 TEMP_FIELD_P               Local  3033     FIELD_DEF       400         scalar   PTR,SAVE         3056,3057,3061                    
 TRIM                       Func   3028                                 scalar                    3028,3029,3048,3067               
 WARN_HEADER                Param  3028     CHAR            64          scalar                    3048,3067                         

Page 87          Source Listing                  FM_GET_INDEX
2021-06-01 08:55                                 field_manager.F90

   3073 ! </FUNCTION> NAME="fm_get_index"
   3074 
   3075 !#######################################################################
   3076 !#######################################################################
   3077 
   3078 ! <FUNCTION NAME="fm_get_current_list">
   3079 !
   3080 ! <OVERVIEW>
   3081 !    A function to return the full path of the current list.
   3082 ! </OVERVIEW>
   3083 ! <DESCRIPTION>
   3084 !    This function returns the full path for the current list. A blank
   3085 !    path indicates an error condition has occurred.
   3086 ! </DESCRIPTION>
   3087 !   <TEMPLATE>
   3088 !     path = fm_get_current_list()
   3089 !   </TEMPLATE>
   3090 !
   3091 function  fm_get_current_list()                                        &
   3092           result (path)  !{
   3093 !
   3094 !   <OUT NAME="path" TYPE="character(len=fm_path_name_len)">
   3095 !     The path corresponding to the current list.
   3096 !   </OUT>
   3097 !
   3098 !        Function definition
   3099 !
   3100 character(len=fm_path_name_len) :: path
   3101 !
   3102 !        arguments
   3103 !
   3104 
   3105 !+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   3106 !        local variables
   3107 !+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   3108 type (field_def), pointer, save :: temp_list_p
   3109 !
   3110 !        Initialize the field manager if needed
   3111 !
   3112 if (.not. module_is_initialized) then  !{
   3113   call initialize
   3114 endif  !}
   3115 !
   3116 !        Set a pointer to the current list and proceed
   3117 !        up the tree, filling in the name as we go
   3118 !
   3119 temp_list_p => current_list_p
   3120 path = ' '
   3121 
   3122 do while (associated(temp_list_p))  !{
   3123 !
   3124 !        Check whether we are at the root field--it is the
   3125 !        only field with a blank name
   3126 !
   3127   if (temp_list_p%name .eq. ' ') then  !{
   3128     exit
   3129   endif  !}

Page 88          Source Listing                  FM_GET_CURRENT_LIST
2021-06-01 08:55                                 field_manager.F90

   3130 !
   3131 !        Append the name to the path
   3132 !
   3133   path = list_sep // trim(temp_list_p%name) // path
   3134 !
   3135 !        Point to the next field
   3136 !
   3137   temp_list_p => temp_list_p%parent
   3138 enddo  !}
   3139 
   3140 if (.not. associated(temp_list_p)) then  !{
   3141 !
   3142 !        The pointer is not associated, indicating an error has
   3143 !        occurred, so set the path accordingly
   3144 !
   3145   path = ' '
   3146 elseif (path .eq. ' ') then  !}{
   3147 !
   3148 !        If path is empty, then the current list must be root,
   3149 !        so set path accordingly
   3150 !
   3151   path = list_sep
   3152 endif  !}
   3153 
   3154 end function  fm_get_current_list  !}


ENTRY POINTS

  Name                                                 
                                                       
 field_manager_mod_mp_fm_get_current_list_             

Page 89          Source Listing                  FM_GET_CURRENT_LIST
2021-06-01 08:55 Symbol Table                    field_manager.F90



SYMBOL CROSS REFERENCE

 Name                       Object Declared Type            Bytes Dimen Elements Attributes       References                        
                                                                                                                                    
 ASSOCIATED                 Func   3122                                 scalar                    3122,3140                         
 FM_GET_CURRENT_LIST        Func   3091     CHAR            512         scalar                                                      
 PATH                       Local  3100     CHAR            512         scalar                    3120,3133,3145,3146,3151          
 TEMP_LIST_P                Local  3108     FIELD_DEF       400         scalar   PTR,SAVE         3119,3122,3127,3133,3137,3140     
 TRIM                       Func   3133                                 scalar                    3133                              

Page 90          Source Listing                  FM_GET_CURRENT_LIST
2021-06-01 08:55                                 field_manager.F90

   3155 ! </FUNCTION> NAME="fm_get_current_list"
   3156 
   3157 !#######################################################################
   3158 !#######################################################################
   3159 
   3160 ! <FUNCTION NAME="fm_get_length">
   3161 !
   3162 ! <OVERVIEW>
   3163 !    A function to return how many elements are contained within the named
   3164 !    list or entry.
   3165 ! </OVERVIEW>
   3166 ! <DESCRIPTION>
   3167 !    This function returns the list or entry length for the named list or entry.
   3168 !    If the named field or entry does not exist, a value of 0 is returned.
   3169 ! </DESCRIPTION>
   3170 !   <TEMPLATE>
   3171 !     length = fm_get_length(name)
   3172 !   </TEMPLATE>
   3173 !
   3174 function  fm_get_length(name)                        &
   3175           result (length)  !{
   3176 !
   3177 !   <OUT NAME="length" TYPE="integer">
   3178 !     The number of elements that the field name has.
   3179 !   </OUT>
   3180 !   <IN NAME="name" TYPE="character(len=*)">
   3181 !     The name of a list or entry that the user wishes to get the length of.
   3182 !   </IN>
   3183 !
   3184 !        Function definition
   3185 !
   3186 integer                      :: length
   3187 !
   3188 !        arguments
   3189 !
   3190 character(len=*), intent(in) :: name
   3191 
   3192 !+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   3193 !        local parameters
   3194 !+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   3195 character(len=13), parameter :: sub_name     = 'fm_get_length'
   3196 character(len=64), parameter :: warn_header  = '==>Warning from ' // trim(module_name) //  &
   3197                                                '(' // trim(sub_name) // '): '
   3198 !+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   3199 !        local variables
   3200 !+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   3201 type (field_def), pointer, save :: temp_field_p
   3202 integer                         :: out_unit
   3203 
   3204 out_unit = stdout()
   3205 !
   3206 !        Initialize the field manager if needed
   3207 !
   3208 if (.not. module_is_initialized) then  !{
   3209   call initialize
   3210 endif  !}
   3211 !

Page 91          Source Listing                  FM_GET_LENGTH
2021-06-01 08:55                                 field_manager.F90

   3212 !        Must supply a field name
   3213 !
   3214 if (name .eq. ' ') then  !{
   3215   if (verb .gt. verb_level_warn) then  !{
   3216     write (out_unit,*) trim(warn_header), 'Must supply a field name'
   3217   endif  !}
   3218   length = 0
   3219   return
   3220 endif  !}
   3221 !
   3222 !        Get a pointer to the field
   3223 !
   3224 temp_field_p => get_field(name, current_list_p)
   3225 
   3226 if (associated(temp_field_p)) then  !{
   3227 !
   3228 !        Set the field length
   3229 !
   3230   if (temp_field_p%field_type .eq. list_type) then !{
   3231     length = temp_field_p%length
   3232   else !}{
   3233     length = temp_field_p%max_index
   3234   endif !}
   3235 else  !}{
   3236 !
   3237 !        Error following the path
   3238 !
   3239 
   3240   if (verb .gt. verb_level_warn) then  !{
   3241     write (out_unit,*) trim(warn_header),                            &
   3242          'Could not follow path for ', trim(name)
   3243   endif  !}
   3244   length = 0
   3245 endif  !}
   3246 
   3247 end function  fm_get_length  !}

Page 92          Source Listing                  FM_GET_LENGTH
2021-06-01 08:55 Entry Points                    field_manager.F90



ENTRY POINTS

  Name                                           
                                                 
 field_manager_mod_mp_fm_get_length_             


SYMBOL CROSS REFERENCE

 Name                       Object Declared Type            Bytes Dimen Elements Attributes       References                        
                                                                                                                                    
 ASSOCIATED                 Func   3226                                 scalar                    3226                              
 FM_GET_LENGTH              Func   3174     I(4)            4           scalar                                                      
 LENGTH                     Local  3186     I(4)            4           scalar                    3218,3231,3233,3244               
 NAME                       Dummy  3174     CHAR                        scalar   ARG,IN           3214,3224,3242                    
 OUT_UNIT                   Local  3202     I(4)            4           scalar                    3204,3216,3241                    
 SUB_NAME                   Param  3195     CHAR            13          scalar                    3197                              
 TEMP_FIELD_P               Local  3201     FIELD_DEF       400         scalar   PTR,SAVE         3224,3226,3230,3231,3233          
 TRIM                       Func   3196                                 scalar                    3196,3197,3216,3241,3242          
 WARN_HEADER                Param  3196     CHAR            64          scalar                    3216,3241                         

Page 93          Source Listing                  FM_GET_LENGTH
2021-06-01 08:55                                 field_manager.F90

   3248 ! </FUNCTION> NAME="fm_get_length"
   3249 
   3250 !#######################################################################
   3251 !#######################################################################
   3252 
   3253 ! <FUNCTION NAME="fm_get_type">
   3254 !
   3255 ! <OVERVIEW>
   3256 !    A function to return the type of the named field.
   3257 ! </OVERVIEW>
   3258 ! <DESCRIPTION>
   3259 !    This function returns the type of the field for name.
   3260 !    This indicates whether the named field is a "list" (has children fields),
   3261 !    or has values of type "integer", "real", "logical" or "string".
   3262 !    If it does not exist it returns a blank string.
   3263 ! </DESCRIPTION>
   3264 !   <TEMPLATE>
   3265 !     name_field_type = fm_get_type(name)
   3266 !   </TEMPLATE>
   3267 !
   3268 function  fm_get_type(name)                        &
   3269           result (name_field_type)  !{
   3270 !   <OUT NAME="name_field_type" TYPE="character(len=8)">
   3271 !     A string containing the type of the named field.
   3272 !   </OUT>
   3273 !   <IN NAME="name" TYPE="character(len=*)">
   3274 !     The name of a field that the user wishes to find the type of.
   3275 !   </IN>
   3276 !
   3277 !        Function definition
   3278 !
   3279 character(len=8)             :: name_field_type
   3280 !
   3281 !        arguments
   3282 !
   3283 character(len=*), intent(in) :: name
   3284 
   3285 !+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   3286 !        local parameters
   3287 !+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   3288 character(len=11), parameter :: sub_name     = 'fm_get_type'
   3289 character(len=64), parameter :: warn_header  = '==>Warning from ' // trim(module_name) //  &
   3290                                                '(' // trim(sub_name) // '): '
   3291 !+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   3292 !        local variables
   3293 !+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   3294 type (field_def), pointer, save :: temp_field_p
   3295 integer                         :: out_unit
   3296 
   3297 out_unit = stdout()
   3298 !
   3299 !        Initialize the field manager if needed
   3300 !
   3301 if (.not. module_is_initialized) then  !{
   3302   call initialize
   3303 endif  !}
   3304 !

Page 94          Source Listing                  FM_GET_TYPE
2021-06-01 08:55                                 field_manager.F90

   3305 !        Must supply a field name
   3306 !
   3307 if (name .eq. ' ') then  !{
   3308   if (verb .gt. verb_level_warn) then  !{
   3309     write (out_unit,*) trim(warn_header), 'Must supply a field name'
   3310   endif  !}
   3311   name_field_type = ' '
   3312   return
   3313 endif  !}
   3314 !
   3315 !        Get a pointer to the field
   3316 !
   3317 temp_field_p => get_field(name, current_list_p)
   3318 
   3319 if (associated(temp_field_p)) then  !{
   3320 !
   3321 !        Set the field type
   3322 !
   3323   name_field_type = field_type_name(temp_field_p%field_type)
   3324 else  !}{
   3325 !
   3326 !        Error following the path
   3327 !
   3328 
   3329   if (verb .gt. verb_level_warn) then  !{
   3330     write (out_unit,*) trim(warn_header),                            &
   3331          'Could not follow path for ', trim(name)
   3332   endif  !}
   3333   name_field_type = ' '
   3334 endif  !}
   3335 
   3336 end function  fm_get_type  !}

Page 95          Source Listing                  FM_GET_TYPE
2021-06-01 08:55 Entry Points                    field_manager.F90



ENTRY POINTS

  Name                                         
                                               
 field_manager_mod_mp_fm_get_type_             


SYMBOL CROSS REFERENCE

 Name                       Object Declared Type            Bytes Dimen Elements Attributes       References                        
                                                                                                                                    
 ASSOCIATED                 Func   3319                                 scalar                    3319                              
 FIELD_TYPE_NAME            Local  3323     CHAR            8     1     5                         3323,4204,4252,4567,4568,4796,4797
                                                                                                  ,5045,5046,5268,5269,5646,5647,564
                                                                                                  8,5649,5650                       
 FM_GET_TYPE                Func   3268     CHAR            8           scalar                                                      
 NAME                       Dummy  3268     CHAR                        scalar   ARG,IN           3307,3317,3331                    
 NAME_FIELD_TYPE            Local  3279     CHAR            8           scalar                    3311,3323,3333                    
 OUT_UNIT                   Local  3295     I(4)            4           scalar                    3297,3309,3330                    
 SUB_NAME                   Param  3288     CHAR            11          scalar                    3290                              
 TEMP_FIELD_P               Local  3294     FIELD_DEF       400         scalar   PTR,SAVE         3317,3319,3323                    
 TRIM                       Func   3289                                 scalar                    3289,3290,3309,3330,3331          
 WARN_HEADER                Param  3289     CHAR            64          scalar                    3309,3330                         

Page 96          Source Listing                  FM_GET_TYPE
2021-06-01 08:55                                 field_manager.F90

   3337 ! </FUNCTION> NAME="fm_get_type"
   3338 
   3339 !#######################################################################
   3340 !#######################################################################
   3341 
   3342 ! <FUNCTION NAME="fm_get_value">
   3343 !
   3344 ! <OVERVIEW>
   3345 !    An overloaded function to find and extract a value for a named field.
   3346 ! </OVERVIEW>
   3347 ! <DESCRIPTION>
   3348 !    Find and extract the value for name. The value may be of type real,
   3349 !    integer, logical or character. If a single value from an array  of values
   3350 !    is required, an optional index can be supplied.
   3351 !    Return true for success and false for failure
   3352 ! </DESCRIPTION>
   3353 !   <TEMPLATE>
   3354 !     success = fm_get_value(name, value, index)
   3355 !   </TEMPLATE>
   3356 !
   3357 function  fm_get_value_integer(name, value, index)                 &
   3358           result (success)  !{
   3359 !   <OUT NAME="success" TYPE="logical">
   3360 !     A flag to indicate whether the function operated with (FALSE) or
   3361 !     without (TRUE) errors.
   3362 !   </OUT>
   3363 !   <IN NAME="name" TYPE="character(len=*)">
   3364 !     The name of a field that the user wishes to get a value for.
   3365 !   </IN>
   3366 !   <OUT NAME="value" TYPE="integer, real, logical or character">
   3367 !     The value associated with the named field.
   3368 !   </OUT>
   3369 !   <IN NAME="index" TYPE="integer, optional">
   3370 !     An optional index to retrieve a single value from an array.
   3371 !   </IN>
   3372 !
   3373 !        Function definition
   3374 !
   3375 logical                                :: success
   3376 !
   3377 !        arguments
   3378 !
   3379 character(len=*), intent(in)           :: name
   3380 integer,          intent(out)          :: value
   3381 integer,          intent(in), optional :: index
   3382 
   3383 !+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   3384 !        local parameters
   3385 !+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   3386 character(len=20), parameter :: sub_name     = 'fm_get_value_integer'
   3387 character(len=64), parameter :: warn_header  = '==>Warning from ' // trim(module_name) //  &
   3388                                                '(' // trim(sub_name) // '): '
   3389 !+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   3390 !        local variables
   3391 !+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   3392 integer                         :: index_t
   3393 type (field_def), pointer, save :: temp_field_p

Page 97          Source Listing                  FM_GET_VALUE_INTEGER
2021-06-01 08:55                                 field_manager.F90

   3394 integer                         :: out_unit
   3395 
   3396 out_unit = stdout()
   3397 !
   3398 !        Initialize the field manager if needed
   3399 !
   3400 if (.not. module_is_initialized) then  !{
   3401   call initialize
   3402 endif  !}
   3403 !
   3404 !        Must supply a field field name
   3405 !
   3406 if (name .eq. ' ') then  !{
   3407   if (verb .gt. verb_level_warn) then  !{
   3408     write (out_unit,*) trim(warn_header), 'Must supply a field name'
   3409   endif  !}
   3410   value = 0
   3411   success = .false.
   3412   return
   3413 endif  !}
   3414 !
   3415 !        Set index to retrieve
   3416 !
   3417 if (present(index)) then  !{
   3418   index_t = index
   3419 else !}{
   3420   index_t = 1
   3421 endif !}
   3422 !
   3423 !        Get a pointer to the field
   3424 !
   3425 temp_field_p => get_field(name, current_list_p)
   3426 
   3427 if (associated(temp_field_p)) then  !{
   3428 !
   3429 !        check that the field is the correct type
   3430 !
   3431   if (temp_field_p%field_type .eq. integer_type) then  !{
   3432     if (index_t .lt. 1) then  !{
   3433 !
   3434 !        Index is not positive
   3435 !
   3436 
   3437       if (verb .gt. verb_level_warn) then  !{
   3438         write (out_unit,*) trim(warn_header),                   &
   3439              'Optional index for ', trim(name),                 &
   3440              ' not positive: ', index_t
   3441       endif  !}
   3442       value = 0
   3443       success = .false.
   3444     elseif (index_t .gt. temp_field_p%max_index) then  !}{
   3445 !
   3446 !        Index is too large
   3447 !
   3448 
   3449       if (verb .gt. verb_level_warn) then  !{
   3450         write (out_unit,*) trim(warn_header),                        &

Page 98          Source Listing                  FM_GET_VALUE_INTEGER
2021-06-01 08:55                                 field_manager.F90

   3451              'Optional index for ', trim(name),                      &
   3452              ' too large: ', index_t, ' > ', temp_field_p%max_index
   3453       endif  !}
   3454       value = 0
   3455       success = .false.
   3456     else  !}{
   3457 !
   3458 !        extract the value
   3459 !
   3460       value = temp_field_p%i_value(index_t)
   3461       success = .true.
   3462     endif !}
   3463   else  !}{
   3464 !
   3465 !        Field not corrcet type
   3466 !
   3467 
   3468     if (verb .gt. verb_level_warn) then  !{
   3469       write (out_unit,*) trim(warn_header),                          &
   3470            'Field not type integer ', trim(name)
   3471     endif  !}
   3472     value = 0
   3473     success = .false.
   3474   endif  !}
   3475 else  !}{
   3476 !
   3477 !        Error following the path
   3478 !
   3479 
   3480   if (verb .gt. verb_level_warn) then  !{
   3481     write (out_unit,*) trim(warn_header),                            &
   3482          'Could not follow path for ', trim(name)
   3483   endif  !}
   3484   value = 0
   3485   success = .false.
   3486 endif  !}
   3487 
   3488 end function  fm_get_value_integer  !}

Page 99          Source Listing                  FM_GET_VALUE_INTEGER
2021-06-01 08:55 Entry Points                    field_manager.F90



ENTRY POINTS

  Name                                                  
                                                        
 field_manager_mod_mp_fm_get_value_integer_             


SYMBOL CROSS REFERENCE

 Name                       Object Declared Type            Bytes Dimen Elements Attributes       References                        
                                                                                                                                    
 ASSOCIATED                 Func   3427                                 scalar                    3427                              
 FM_GET_VALUE_INTEGER       Func   3357     L(4)            4           scalar                                                      
 INDEX                      Dummy  3357     I(4)            4           scalar   ARG,IN           3417,3418                         
 INDEX_T                    Local  3392     I(4)            4           scalar                    3418,3420,3432,3440,3444,3452,3460
 NAME                       Dummy  3357     CHAR                        scalar   ARG,IN           3406,3425,3439,3451,3470,3482     
 OUT_UNIT                   Local  3394     I(4)            4           scalar                    3396,3408,3438,3450,3469,3481     
 PRESENT                    Func   3417                                 scalar                    3417                              
 SUB_NAME                   Param  3386     CHAR            20          scalar                    3388                              
 SUCCESS                    Local  3375     L(4)            4           scalar                    3411,3443,3455,3461,3473,3485     
 TEMP_FIELD_P               Local  3393     FIELD_DEF       400         scalar   PTR,SAVE         3425,3427,3431,3444,3452,3460     
 TRIM                       Func   3387                                 scalar                    3387,3388,3408,3438,3439,3450,3451
                                                                                                  ,3469,3470,3481,3482              
 VALUE                      Dummy  3357     I(4)            4           scalar   ARG,OUT          3410,3442,3454,3460,3472,3484     
 WARN_HEADER                Param  3387     CHAR            64          scalar                    3408,3438,3450,3469,3481          

Page 100         Source Listing                  FM_GET_VALUE_INTEGER
2021-06-01 08:55                                 field_manager.F90

   3489 
   3490 !#######################################################################
   3491 !#######################################################################
   3492 
   3493 function  fm_get_value_logical(name, value, index)                 &
   3494           result (success)  !{
   3495 !
   3496 !        Function definition
   3497 !
   3498 logical                                :: success
   3499 !
   3500 !        arguments
   3501 !
   3502 character(len=*), intent(in)           :: name
   3503 logical,          intent(out)          :: value
   3504 integer,          intent(in), optional :: index
   3505 
   3506 !+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   3507 !        local parameters
   3508 !+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   3509 character(len=20), parameter :: sub_name     = 'fm_get_value_logical'
   3510 character(len=64), parameter :: warn_header  = '==>Warning from ' // trim(module_name) //  &
   3511                                                '(' // trim(sub_name) // '): '
   3512 !+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   3513 !        local variables
   3514 !+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   3515 integer                         :: index_t
   3516 type (field_def), pointer, save :: temp_field_p
   3517 integer                         :: out_unit
   3518 
   3519 out_unit = stdout()
   3520 !
   3521 !        Initialize the field manager if needed
   3522 !
   3523 if (.not. module_is_initialized) then  !{
   3524   call initialize
   3525 endif  !}
   3526 !
   3527 !        Must supply a field field name
   3528 !
   3529 if (name .eq. ' ') then  !{
   3530   if (verb .gt. verb_level_warn) then  !{
   3531     write (out_unit,*) trim(warn_header), 'Must supply a field name'
   3532   endif  !}
   3533   value = .false.
   3534   success = .false.
   3535   return
   3536 endif  !}
   3537 !
   3538 !        Set index to retrieve
   3539 !
   3540 if (present(index)) then  !{
   3541   index_t = index
   3542 else  !}{
   3543   index_t = 1
   3544 endif  !}
   3545 !

Page 101         Source Listing                  FM_GET_VALUE_LOGICAL
2021-06-01 08:55                                 field_manager.F90

   3546 !        Get a pointer to the field
   3547 !
   3548 temp_field_p => get_field(name, current_list_p)
   3549 
   3550 if (associated(temp_field_p)) then  !{
   3551 !
   3552 !        check that the field is the correct type
   3553 !
   3554   if (temp_field_p%field_type .eq. logical_type) then  !{
   3555 
   3556     if (index_t .lt. 1) then  !{
   3557 !
   3558 !        Index is not positive
   3559 !
   3560 
   3561       if (verb .gt. verb_level_warn) then  !{
   3562         write (out_unit,*) trim(warn_header),                   &
   3563              'Optional index for ', trim(name),                 &
   3564              ' not positive: ', index_t
   3565       endif  !}
   3566       value = .false.
   3567       success = .false.
   3568 
   3569     elseif (index_t .gt. temp_field_p%max_index) then  !}{
   3570 !
   3571 !        Index is too large
   3572 !
   3573 
   3574       if (verb .gt. verb_level_warn) then  !{
   3575         write (out_unit,*) trim(warn_header),                        &
   3576              'Optional index for ', trim(name),                      &
   3577              ' too large: ', index_t, ' > ', temp_field_p%max_index
   3578       endif  !}
   3579       value = .false.
   3580       success = .false.
   3581 
   3582     else  !}{
   3583 !
   3584 !        extract the value
   3585 !
   3586       value = temp_field_p%l_value(index_t)
   3587       success = .true.
   3588     endif !}
   3589   else  !}{
   3590 !
   3591 !        Field not correct type
   3592 !
   3593 
   3594     if (verb .gt. verb_level_warn) then  !{
   3595       write (out_unit,*) trim(warn_header),                          &
   3596            'Field not type logical ', trim(name)
   3597     endif  !}
   3598     value = .false.
   3599     success = .false.
   3600   endif  !}
   3601 else  !}{
   3602 !

Page 102         Source Listing                  FM_GET_VALUE_LOGICAL
2021-06-01 08:55                                 field_manager.F90

   3603 !        Error following the path
   3604 !
   3605 
   3606   if (verb .gt. verb_level_warn) then  !{
   3607     write (out_unit,*) trim(warn_header),                            &
   3608          'Could not follow path for ', trim(name)
   3609   endif  !}
   3610   value = .false.
   3611   success = .false.
   3612 endif  !}
   3613 
   3614 end function  fm_get_value_logical  !}


ENTRY POINTS

  Name                                                  
                                                        
 field_manager_mod_mp_fm_get_value_logical_             


SYMBOL CROSS REFERENCE

 Name                       Object Declared Type            Bytes Dimen Elements Attributes       References                        
                                                                                                                                    
 ASSOCIATED                 Func   3550                                 scalar                    3550                              
 FM_GET_VALUE_LOGICAL       Func   3493     L(4)            4           scalar                                                      
 INDEX                      Dummy  3493     I(4)            4           scalar   ARG,IN           3540,3541                         
 INDEX_T                    Local  3515     I(4)            4           scalar                    3541,3543,3556,3564,3569,3577,3586
 NAME                       Dummy  3493     CHAR                        scalar   ARG,IN           3529,3548,3563,3576,3596,3608     
 OUT_UNIT                   Local  3517     I(4)            4           scalar                    3519,3531,3562,3575,3595,3607     
 PRESENT                    Func   3540                                 scalar                    3540                              
 SUB_NAME                   Param  3509     CHAR            20          scalar                    3511                              
 SUCCESS                    Local  3498     L(4)            4           scalar                    3534,3567,3580,3587,3599,3611     
 TEMP_FIELD_P               Local  3516     FIELD_DEF       400         scalar   PTR,SAVE         3548,3550,3554,3569,3577,3586     
 TRIM                       Func   3510                                 scalar                    3510,3511,3531,3562,3563,3575,3576
                                                                                                  ,3595,3596,3607,3608              
 VALUE                      Dummy  3493     L(4)            4           scalar   ARG,OUT          3533,3566,3579,3586,3598,3610     
 WARN_HEADER                Param  3510     CHAR            64          scalar                    3531,3562,3575,3595,3607          

Page 103         Source Listing                  FM_GET_VALUE_LOGICAL
2021-06-01 08:55                                 field_manager.F90

   3615 
   3616 !#######################################################################
   3617 !#######################################################################
   3618 
   3619 function  fm_get_value_real(name, value, index)                 &
   3620           result (success)  !{
   3621 !
   3622 !        Function definition
   3623 !
   3624 logical                                :: success
   3625 !
   3626 !        arguments
   3627 !
   3628 character(len=*), intent(in)           :: name
   3629 real,             intent(out)          :: value
   3630 integer,          intent(in), optional :: index
   3631 
   3632 !+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   3633 !        local parameters
   3634 !+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   3635 character(len=17), parameter :: sub_name     = 'fm_get_value_real'
   3636 character(len=64), parameter :: warn_header  = '==>Warning from ' // trim(module_name) //  &
   3637                                                '(' // trim(sub_name) // '): '
   3638 !+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   3639 !        local variables
   3640 !+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   3641 integer                         :: index_t
   3642 type (field_def), pointer, save :: temp_field_p
   3643 integer                         :: out_unit
   3644 
   3645 out_unit = stdout()
   3646 !
   3647 !        Initialize the field manager if needed
   3648 !
   3649 if (.not. module_is_initialized) then  !{
   3650   call initialize
   3651 endif  !}
   3652 !
   3653 !        Must supply a field field name
   3654 !
   3655 if (name .eq. ' ') then  !{
   3656   if (verb .gt. verb_level_warn) then  !{
   3657     write (out_unit,*) trim(warn_header), 'Must supply a field name'
   3658   endif  !}
   3659   value = 0.0
   3660   success = .false.
   3661   return
   3662 endif  !}
   3663 !
   3664 !        Set index to retrieve
   3665 !
   3666 if (present(index)) then  !{
   3667   index_t = index
   3668 else  !}{
   3669   index_t = 1
   3670 endif  !}
   3671 !

Page 104         Source Listing                  FM_GET_VALUE_REAL
2021-06-01 08:55                                 field_manager.F90

   3672 !        Get a pointer to the field
   3673 !
   3674 temp_field_p => get_field(name, current_list_p)
   3675 
   3676 if (associated(temp_field_p)) then  !{
   3677 !
   3678 !        check that the field is the correct type
   3679 !
   3680   if (temp_field_p%field_type .eq. real_type) then  !{
   3681 
   3682     if (index_t .lt. 1) then  !{
   3683 
   3684 !
   3685 !        Index is not positive
   3686 !
   3687 
   3688       if (verb .gt. verb_level_warn) then  !{
   3689         write (out_unit,*) trim(warn_header),                        &
   3690              'Optional index for ', trim(name),                      &
   3691              ' not positive: ', index_t
   3692       endif  !}
   3693       value = 0.0
   3694       success = .false.
   3695 
   3696     elseif (index_t .gt. temp_field_p%max_index) then  !}{
   3697 
   3698 !
   3699 !        Index is too large
   3700 !
   3701 
   3702       if (verb .gt. verb_level_warn) then  !{
   3703         write (out_unit,*) trim(warn_header),                        &
   3704              'Optional index for ', trim(name),                      &
   3705              ' too large: ', index_t, ' > ', temp_field_p%max_index
   3706       endif  !}
   3707       value = 0.0
   3708       success = .false.
   3709 
   3710     else  !}{
   3711 
   3712 !
   3713 !        extract the value
   3714 !
   3715       value = temp_field_p%r_value(index_t)
   3716       success = .true.
   3717     endif !}
   3718   else  !}{
   3719 !
   3720 !        Field not correct type
   3721 !
   3722 
   3723     if (verb .gt. verb_level_warn) then  !{
   3724       write (out_unit,*) trim(warn_header),                          &
   3725            'Field not type real ', trim(name)
   3726     endif  !}
   3727     value = 0.0
   3728     success = .false.

Page 105         Source Listing                  FM_GET_VALUE_REAL
2021-06-01 08:55                                 field_manager.F90

   3729   endif  !}
   3730 else  !}{
   3731 !
   3732 !        Error following the path
   3733 !
   3734 
   3735   if (verb .gt. verb_level_warn) then  !{
   3736     write (out_unit,*) trim(warn_header),                            &
   3737          'Could not follow path for ', trim(name)
   3738   endif  !}
   3739   value = 0.0
   3740   success = .false.
   3741 endif  !}
   3742 
   3743 end function  fm_get_value_real  !}


ENTRY POINTS

  Name                                               
                                                     
 field_manager_mod_mp_fm_get_value_real_             


SYMBOL CROSS REFERENCE

 Name                       Object Declared Type            Bytes Dimen Elements Attributes       References                        
                                                                                                                                    
 ASSOCIATED                 Func   3676                                 scalar                    3676                              
 FM_GET_VALUE_REAL          Func   3619     L(4)            4           scalar                                                      
 INDEX                      Dummy  3619     I(4)            4           scalar   ARG,IN           3666,3667                         
 INDEX_T                    Local  3641     I(4)            4           scalar                    3667,3669,3682,3691,3696,3705,3715
 NAME                       Dummy  3619     CHAR                        scalar   ARG,IN           3655,3674,3690,3704,3725,3737     
 OUT_UNIT                   Local  3643     I(4)            4           scalar                    3645,3657,3689,3703,3724,3736     
 PRESENT                    Func   3666                                 scalar                    3666                              
 SUB_NAME                   Param  3635     CHAR            17          scalar                    3637                              
 SUCCESS                    Local  3624     L(4)            4           scalar                    3660,3694,3708,3716,3728,3740     
 TEMP_FIELD_P               Local  3642     FIELD_DEF       400         scalar   PTR,SAVE         3674,3676,3680,3696,3705,3715     
 TRIM                       Func   3636                                 scalar                    3636,3637,3657,3689,3690,3703,3704
                                                                                                  ,3724,3725,3736,3737              
 VALUE                      Dummy  3619     R(8)            8           scalar   ARG,OUT          3659,3693,3707,3715,3727,3739     
 WARN_HEADER                Param  3636     CHAR            64          scalar                    3657,3689,3703,3724,3736          

Page 106         Source Listing                  FM_GET_VALUE_REAL
2021-06-01 08:55                                 field_manager.F90

   3744 
   3745 !#######################################################################
   3746 !#######################################################################
   3747 
   3748 function  fm_get_value_string(name, value, index)                 &
   3749           result (success)  !{
   3750 !
   3751 !        Function definition
   3752 !
   3753 logical                                :: success
   3754 !
   3755 !        arguments
   3756 !
   3757 character(len=*), intent(in)           :: name
   3758 character(len=*), intent(out)          :: value
   3759 integer,          intent(in), optional :: index
   3760 
   3761 !+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   3762 !        local parameters
   3763 !+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   3764 character(len=19), parameter :: sub_name     = 'fm_get_value_string'
   3765 character(len=64), parameter :: warn_header  = '==>Warning from ' // trim(module_name) //  &
   3766                                                '(' // trim(sub_name) // '): '
   3767 !+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   3768 !        local variables
   3769 !+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   3770 integer                         :: index_t
   3771 type (field_def), pointer, save :: temp_field_p
   3772 integer                         :: out_unit
   3773 
   3774 out_unit = stdout()
   3775 !
   3776 !        Initialize the field manager if needed
   3777 !
   3778 if (.not. module_is_initialized) then  !{
   3779   call initialize
   3780 endif  !}
   3781 !
   3782 !        Must supply a field field name
   3783 !
   3784 if (name .eq. ' ') then  !{
   3785   if (verb .gt. verb_level_warn) then  !{
   3786     write (out_unit,*) trim(warn_header), 'Must supply a field name'
   3787   endif  !}
   3788   value = ''
   3789   success = .false.
   3790   return
   3791 endif  !}
   3792 !
   3793 !        Set index to retrieve
   3794 !
   3795 if (present(index)) then  !{
   3796   index_t = index
   3797 else  !}{
   3798   index_t = 1
   3799 endif  !}
   3800 !

Page 107         Source Listing                  FM_GET_VALUE_STRING
2021-06-01 08:55                                 field_manager.F90

   3801 !        Get a pointer to the field
   3802 !
   3803 temp_field_p => get_field(name, current_list_p)
   3804 
   3805 if (associated(temp_field_p)) then  !{
   3806 !
   3807 !        check that the field is the correct type
   3808 !
   3809   if (temp_field_p%field_type .eq. string_type) then  !{
   3810     if (index_t .lt. 1) then  !{
   3811 !
   3812 !        Index is not positive
   3813 !
   3814 
   3815       if (verb .gt. verb_level_warn) then  !{
   3816         write (out_unit,*) trim(warn_header),                        &
   3817              'Optional index for ', trim(name),                      &
   3818              ' not positive: ', index_t
   3819       endif  !}
   3820       value = ''
   3821       success = .false.
   3822 
   3823     elseif (index_t .gt. temp_field_p%max_index) then  !}{
   3824 !
   3825 !        Index is too large
   3826 !
   3827 
   3828       if (verb .gt. verb_level_warn) then  !{
   3829         write (out_unit,*) trim(warn_header),                        &
   3830              'Optional index for ', trim(name),                      &
   3831              ' too large: ', index_t, ' > ', temp_field_p%max_index
   3832       endif  !}
   3833       value = ''
   3834       success = .false.
   3835     else  !}{
   3836 !
   3837 !        extract the value
   3838 !
   3839       value = temp_field_p%s_value(index_t)
   3840 !if (trim(value) == '') then
   3841 !success = .false.
   3842 !else
   3843         success = .true.
   3844 !endif
   3845     endif !}
   3846   else  !}{
   3847 !
   3848 !        Field not correct type
   3849 !
   3850 
   3851     if (verb .gt. verb_level_warn) then  !{
   3852       write (out_unit,*) trim(warn_header),                          &
   3853            'Field not type string ', trim(name)
   3854     endif  !}
   3855     value = ''
   3856     success = .false.
   3857   endif  !}

Page 108         Source Listing                  FM_GET_VALUE_STRING
2021-06-01 08:55                                 field_manager.F90

   3858 else  !}{
   3859 !
   3860 !        Error following the path
   3861 !
   3862 
   3863   if (verb .gt. verb_level_warn) then  !{
   3864     write (out_unit,*) trim(warn_header),                            &
   3865          'Could not follow path for ', trim(name)
   3866   endif  !}
   3867   value = ''
   3868   success = .false.
   3869 endif  !}
   3870 
   3871 end function  fm_get_value_string  !}


ENTRY POINTS

  Name                                                 
                                                       
 field_manager_mod_mp_fm_get_value_string_             


SYMBOL CROSS REFERENCE

 Name                       Object Declared Type            Bytes Dimen Elements Attributes       References                        
                                                                                                                                    
 ASSOCIATED                 Func   3805                                 scalar                    3805                              
 FM_GET_VALUE_STRING        Func   3748     L(4)            4           scalar                                                      
 INDEX                      Dummy  3748     I(4)            4           scalar   ARG,IN           3795,3796                         
 INDEX_T                    Local  3770     I(4)            4           scalar                    3796,3798,3810,3818,3823,3831,3839
 NAME                       Dummy  3748     CHAR                        scalar   ARG,IN           3784,3803,3817,3830,3853,3865     
 OUT_UNIT                   Local  3772     I(4)            4           scalar                    3774,3786,3816,3829,3852,3864     
 PRESENT                    Func   3795                                 scalar                    3795                              
 SUB_NAME                   Param  3764     CHAR            19          scalar                    3766                              
 SUCCESS                    Local  3753     L(4)            4           scalar                    3789,3821,3834,3843,3856,3868     
 TEMP_FIELD_P               Local  3771     FIELD_DEF       400         scalar   PTR,SAVE         3803,3805,3809,3823,3831,3839     
 TRIM                       Func   3765                                 scalar                    3765,3766,3786,3816,3817,3829,3830
                                                                                                  ,3852,3853,3864,3865              
 VALUE                      Dummy  3748     CHAR                        scalar   ARG,OUT          3788,3820,3833,3839,3855,3867     
 WARN_HEADER                Param  3765     CHAR            64          scalar                    3786,3816,3829,3852,3864          

Page 109         Source Listing                  FM_GET_VALUE_STRING
2021-06-01 08:55                                 field_manager.F90

   3872 ! </FUNCTION> NAME="fm_get_value"
   3873 
   3874 !#######################################################################
   3875 !#######################################################################
   3876 
   3877 ! <FUNCTION NAME="fm_intersection">
   3878 !
   3879 ! <OVERVIEW>
   3880 !    A function to find the common names of the sub-fields in a list
   3881 !    of fields.
   3882 ! </OVERVIEW>
   3883 ! <DESCRIPTION>
   3884 !    Return a pointer to an fm_array_list of the intersection
   3885 !    of an array of lists, ignoring the contents of the values,
   3886 !    but just returning the names.
   3887 !    Return false on the end of the intersection.
   3888 ! </DESCRIPTION>
   3889 !   <TEMPLATE>
   3890 !     return_p => fm_intersection(lists,dim)
   3891 !   </TEMPLATE>
   3892 !
   3893 function fm_intersection(lists, dim)                        &
   3894         result (return_p)  !{
   3895 !   <OUT NAME="return_p" TYPE="type (fm_array_list_def), pointer">
   3896 !     A pointer to a list of names that are common to the fields provided in
   3897 !     lists.
   3898 !   </OUT>
   3899 !   <IN NAME="dim" TYPE="dim">
   3900 !     The dimension of lists.
   3901 !   </IN>
   3902 !   <IN NAME="lists" TYPE="character(len=*)" DIM="(dim)">
   3903 !     A list of fields that the user wishes to find the common fields of.
   3904 !   </IN>
   3905 !
   3906 !        Function definition
   3907 !
   3908 type (fm_array_list_def), pointer  :: return_p
   3909 !
   3910 !        arguments
   3911 !
   3912 integer,          intent(in)       :: dim
   3913 character(len=*), intent(in)       :: lists(dim)
   3914 
   3915 !+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   3916 !        local parameters
   3917 !+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   3918 character(len=15), parameter :: sub_name     = 'fm_intersection'
   3919 character(len=64), parameter :: error_header = '==>Error from ' // trim(module_name)   //  &
   3920                                                '(' // trim(sub_name) // '): '
   3921 character(len=64), parameter :: warn_header  = '==>Warning from ' // trim(module_name) //  &
   3922                                                '(' // trim(sub_name) // '): '
   3923 !+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   3924 !        local variables
   3925 !+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   3926 character (len=fm_field_name_len)  :: name
   3927 character (len=fm_field_name_len),                          &
   3928         dimension(:), allocatable  :: names

Page 110         Source Listing                  FM_INTERSECTION
2021-06-01 08:55                                 field_manager.F90

   3929 character (len=fm_type_name_len)   :: field_type
   3930 integer                            :: count
   3931 integer                            :: error
   3932 integer                            :: index
   3933 integer                            :: n, ier
   3934 integer                            :: shortest
   3935 logical                            :: found
   3936 type (field_def), pointer, save    :: temp_p
   3937 integer                            :: out_unit
   3938 
   3939 out_unit = stdout()
   3940 
   3941 nullify(return_p)
   3942 !
   3943 !        Initialize the field manager if needed
   3944 !
   3945 if (.not. module_is_initialized) then  !{
   3946   call initialize
   3947 endif  !}
   3948 !
   3949 !        return error if dimension if bad
   3950 !
   3951 if (dim .le. 0) then  !{
   3952   if (verb .gt. verb_level_warn) then  !{
   3953     write (out_unit,*) trim(warn_header), 'Non-positive dimension: ', dim
   3954   endif  !}
   3955   nullify(return_p)
   3956   return
   3957 endif  !}
   3958 !
   3959 !        make sure that the lists exist, and find the shortest list
   3960 !        and its length
   3961 !
   3962 count = -1
   3963 shortest = 0
   3964 do n = 1, dim  !{
   3965   temp_p => find_list(lists(n), current_list_p, .false.)
   3966   if (associated(temp_p)) then  !{
   3967     if (count .eq. -1) then  !{
   3968       count = temp_p%length
   3969       shortest = n
   3970     else  !}{
   3971       if (count .gt. temp_p%length) then  !{
   3972         count = temp_p%length
   3973         shortest = n
   3974       endif  !}
   3975     endif  !}
   3976   else  !}{
   3977     if (verb .gt. verb_level_warn) then  !{
   3978       write (out_unit,*) trim(warn_header),                          &
   3979                          'List does not exist: "', trim(lists(n)), '"'
   3980     endif  !}
   3981     nullify(return_p)
   3982     return
   3983   endif  !}
   3984 enddo  !} n
   3985 !

Page 111         Source Listing                  FM_INTERSECTION
2021-06-01 08:55                                 field_manager.F90

   3986 !        allocate return pointer
   3987 !
   3988 allocate( return_p, stat = error)
   3989 if (error .ne. 0) then !{
   3990   write (out_unit,*) trim(error_header), 'Error ', error          &
   3991                  , ' allocating memory for return_p '
   3992   nullify(return_p)
   3993   return
   3994 endif  !}
   3995 if ( associated(return_p%names)) deallocate(return_p%names)
   3996 !
   3997 !        return if any list is empty
   3998 !
   3999 if (count .eq. 0) then  !{
   4000   return_p%length = 0
   4001   return
   4002 endif  !}
   4003 !
   4004 !        If there is only one list, then return its names
   4005 !
   4006 if (dim .eq. 1) then  !{
   4007 !
   4008 !        allocate space for names in return pointer
   4009 !
   4010   allocate( return_p%names(count), stat = error)
   4011   if (error .ne. 0) then !{
   4012     write (out_unit,*) trim(error_header), 'Error ', error        &
   4013                    , ' allocating memory for names in return_p '
   4014     nullify(return_p)
   4015     return
   4016   endif  !}
   4017   count = 0
   4018   do while (fm_loop_over_list(lists(1), name, field_type, index))  !{
   4019     count = count + 1
   4020     return_p%names(count) = name
   4021   enddo  !}
   4022   return
   4023 endif  !}
   4024 !
   4025 !        allocate space for names
   4026 !
   4027 allocate( names(count), stat = error)
   4028 if (error .ne. 0) then !{
   4029   write (out_unit,*) trim(error_header), 'Error ', error          &
   4030                  , ' allocating memory for names '
   4031   nullify(return_p)
   4032   return
   4033 endif  !}
   4034 !
   4035 !        Loop over the shortest list, checking whether its names
   4036 !        occur in all of the other lists. If so, then save the name
   4037 !
   4038 count = 0
   4039 do while (fm_loop_over_list(lists(shortest), name, field_type, index))  !{
   4040   found = .true.
   4041   do n = 1, dim  !{
   4042     if (n .ne. shortest) then   !{

Page 112         Source Listing                  FM_INTERSECTION
2021-06-01 08:55                                 field_manager.F90

   4043       temp_p => find_list(trim(lists(n)) // list_sep // name,        &
   4044                           current_list_p, .false.)
   4045       if (.not. associated(temp_p)) then  !{
   4046         found = .false.
   4047         exit
   4048       endif  !}
   4049     endif  !}
   4050   enddo  !}
   4051   if (found) then  !{
   4052     count = count + 1
   4053     names(count) = name
   4054   endif  !}
   4055 enddo  !}
   4056 !
   4057 !        allocate space for names in return pointer
   4058 !
   4059 allocate( return_p%names(count), stat = error)
   4060 if (error .ne. 0) then !{
   4061   write (out_unit,*) trim(error_header), 'Error ', error  &
   4062                  , ' allocating memory for names in return_p '
   4063   deallocate(names)
   4064   nullify(return_p)
   4065   return
   4066 endif  !}
   4067 !
   4068 !        copy the names to the return pointer and clean up
   4069 !
   4070 do n = 1, count  !{
   4071   return_p%names(n) = names(n)
   4072 enddo  !} n
   4073 return_p%length = count
   4074 deallocate(names)
   4075 
   4076 end function fm_intersection  !}

Page 113         Source Listing                  FM_INTERSECTION
2021-06-01 08:55 Entry Points                    field_manager.F90



ENTRY POINTS

  Name                                             
                                                   
 field_manager_mod_mp_fm_intersection_             


SYMBOL CROSS REFERENCE

 Name                       Object Declared Type            Bytes Dimen Elements Attributes       References                        
                                                                                                                                    
 ASSOCIATED                 Func   3966                                 scalar                    3966,3995,4045                    
 COUNT                      Local  3930     I(4)            4           scalar                    3962,3967,3968,3971,3972,3999,4010
                                                                                                  ,4017,4019,4020,4027,4038,4052,405
                                                                                                  3,4059,4070,4073                  
 DIM                        Dummy  3893     I(4)            4           scalar   ARG,IN           3913,3951,3953,3964,4006,4041     
 ERROR                      Local  3931     I(4)            4           scalar                    3988,3989,3990,4010,4011,4012,4027
                                                                                                  ,4028,4029,4059,4060,4061         
 ERROR_HEADER               Param  3919     CHAR            64          scalar                    3990,4012,4029,4061               
 FIELD_TYPE                 Local  3929     CHAR            8           scalar                    4018,4039                         
 FM_ARRAY_LIST_DEF          Type   3908                     80          scalar                    355,3908                          
 FM_INTERSECTION            Func   3893     FM_ARRAY_LIST_DEF                                                                       
                                                            80          scalar   PTR                                                
 FM_LOOP_OVER_LIST          Local  4018                                 scalar                    262,4018,4039                     
 FM_TYPE_NAME_LEN           Param  3929     I(4)            4           scalar                    310,567,3929,4122                 
 FOUND                      Local  3935     L(4)            4           scalar                    4040,4046,4051                    
 IER                        Local  3933     I(4)            4           scalar                                                      
 INDEX                      Local  3932     I(4)            4           scalar                    4018,4039                         
 LISTS                      Dummy  3893     CHAR                  1     0        ARG,IN           3965,3979,4018,4039,4043          
 N                          Local  3933     I(4)            4           scalar                    3964,3965,3969,3973,3979,4041,4042
                                                                                                  ,4043,4070,4071                   
 NAME                       Local  3926     CHAR            48          scalar                    4018,4020,4039,4043,4053          
 NAMES                      Local  3928     CHAR            48    1     1        ALC              4027,4053,4063,4071,4074          
 OUT_UNIT                   Local  3937     I(4)            4           scalar                    3939,3953,3978,3990,4012,4029,4061
 RETURN_P                   Local  3908     FM_ARRAY_LIST_DEF                                                                       
                                                            80          scalar   PTR              3941,3955,3981,3988,3992,3995,4000
                                                                                                  ,4010,4014,4020,4031,4059,4064,407
                                                                                                  1,4073                            
 SHORTEST                   Local  3934     I(4)            4           scalar                    3963,3969,3973,4039,4042          
 SUB_NAME                   Param  3918     CHAR            15          scalar                    3920,3922                         
 TEMP_P                     Local  3936     FIELD_DEF       400         scalar   PTR,SAVE         3965,3966,3968,3971,3972,4043,4045
 TRIM                       Func   3919                                 scalar                    3919,3920,3921,3922,3953,3978,3979
                                                                                                  ,3990,4012,4029,4043,4061         
 WARN_HEADER                Param  3921     CHAR            64          scalar                    3953,3978                         



Page 114         Source Listing                  FM_INTERSECTION
2021-06-01 08:55 Symbol Table                    field_manager.F90

TYPE COMPONENTS/COMMON VARIABLES

 Name                       Type            Bytes Offset   Dimen Elements Attributes       References                         
                                                                                                                              
 FM_ARRAY_LIST_DEF.LENGTH   I(4)            4     72             scalar                    4000,4073                          
 FM_ARRAY_LIST_DEF.NAMES    CHAR            48    0        1     1        PTR              3995,4010,4020,4059,4071           

Page 115         Source Listing                  FM_INTERSECTION
2021-06-01 08:55                                 field_manager.F90

   4077 ! </FUNCTION> NAME="fm_intersection"
   4078 
   4079 !#######################################################################
   4080 !#######################################################################
   4081 
   4082 ! <FUNCTION NAME="fm_loop_over_list">
   4083 !
   4084 ! <OVERVIEW>
   4085 !    A function for looping over a list.
   4086 ! </OVERVIEW>
   4087 ! <DESCRIPTION>
   4088 !    Loop over the list, setting the name, type and index
   4089 !    of the next field. Return false at the end of the loop.
   4090 ! </DESCRIPTION>
   4091 !   <TEMPLATE>
   4092 !     success = fm_loop_over_list(list, name, field_type, index)
   4093 !   </TEMPLATE>
   4094 !
   4095 function  fm_loop_over_list_old(list, name, field_type, index)        &
   4096           result (success)  !{
   4097 !   <OUT NAME="success" TYPE="logical">
   4098 !     A flag to indicate whether the function operated with (FALSE) or
   4099 !     without (TRUE) errors.
   4100 !   </OUT>
   4101 !   <IN NAME="list" TYPE="character(len=*)">
   4102 !     The name of a list to loop over.
   4103 !   </IN>
   4104 !   <OUT NAME="name" TYPE="character(len=*)">
   4105 !     The name of a field from list.
   4106 !   </OUT>
   4107 !   <OUT NAME="field_type" TYPE="character(len=fm_type_name_len)">
   4108 !     The type of a list entry.
   4109 !   </OUT>
   4110 !   <OUT NAME="index" TYPE="integer">
   4111 !     The index of tje field within the list.
   4112 !   </OUT>
   4113 !
   4114 !        Function definition
   4115 !
   4116 logical                                      :: success
   4117 !
   4118 !        arguments
   4119 !
   4120 character(len=*),                intent(in)  :: list
   4121 character(len=*),                intent(out) :: name
   4122 character(len=fm_type_name_len), intent(out) :: field_type
   4123 integer,                         intent(out) :: index
   4124 
   4125 !+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   4126 !        local parameters
   4127 !+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   4128 character(len=17), parameter :: sub_name     = 'fm_loop_over_list'
   4129 character(len=64), parameter :: warn_header  = '==>Warning from ' // trim(module_name) //  &
   4130                                                '(' // trim(sub_name) // '): '
   4131 !+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   4132 !        local variables
   4133 !+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

Page 116         Source Listing                  SET_LIST_STUFF
2021-06-01 08:55                                 field_manager.F90

   4134 type (field_def), pointer, save :: temp_list_p
   4135 integer                         :: out_unit
   4136 
   4137 out_unit = stdout()
   4138 !
   4139 !        Initialize the field manager if needed
   4140 !
   4141 if (.not. module_is_initialized) then  !{
   4142   call initialize
   4143 endif  !}
   4144 
   4145 if (list .eq. loop_list .and. associated(loop_list_p)) then  !{
   4146 !
   4147 !        We've already started this loop, so continue on
   4148 !
   4149   loop_list_p => loop_list_p%next
   4150   success = set_list_stuff()
   4151 elseif (list .eq. ' ') then  !{
   4152 !
   4153 !        If list is empty, then loop over the current list
   4154 !
   4155   loop_list = ' '
   4156   loop_list_p => current_list_p%first_field
   4157   success = set_list_stuff()
   4158 else  !}{
   4159 !
   4160 !        Get a pointer to the list
   4161 !
   4162   loop_list = list
   4163   loop_list_p => find_list(loop_list, current_list_p, .false.)
   4164   if (associated(loop_list_p)) then  !{
   4165     loop_list_p => loop_list_p%first_field
   4166     success = set_list_stuff()
   4167   else  !}{
   4168 !
   4169 !        Error following the path
   4170 !
   4171 
   4172     if (verb .gt. verb_level_warn) then  !{
   4173       write (out_unit,*) trim(warn_header),                        &
   4174            'Could not follow path for ', trim(list)
   4175     endif  !}
   4176     success = .false.
   4177   endif  !}
   4178 endif  !}
   4179 
   4180 return
   4181 
   4182 contains
   4183 
   4184 !#######################################################################
   4185 !#######################################################################
   4186 
   4187 ! <FUNCTION NAME="set_list_stuff">
   4188 !
   4189 ! <DESCRIPTION>
   4190 ! If the the pointer matches to the right list,

Page 117         Source Listing                  SET_LIST_STUFF
2021-06-01 08:55                                 field_manager.F90

   4191 ! extract the field information.  Used in fm_loop_over_list
   4192 ! </DESCRIPTION>
   4193 function  set_list_stuff()                                                &
   4194           result (success)  !{
   4195 !
   4196 !        Function definition
   4197 !
   4198   logical        :: success
   4199 !
   4200 !        arguments
   4201 !
   4202   if (associated(loop_list_p)) then  !{
   4203     name = loop_list_p%name
   4204     field_type = field_type_name(loop_list_p%field_type)
   4205     index = loop_list_p%index
   4206     success = .true.
   4207   else  !}{
   4208     name = ' '
   4209     field_type = ' '
   4210     index = 0
   4211     success = .false.
   4212     loop_list = ' '
   4213   endif  !}
   4214 
   4215 end function  set_list_stuff  !}


ENTRY POINTS

  Name                                                                 
                                                                       
 field_manager_modfm_loop_over_list_old_mp_set_list_stuff_             

Page 118         Source Listing                  SET_LIST_STUFF
2021-06-01 08:55 Symbol Table                    field_manager.F90



SYMBOL CROSS REFERENCE

 Name                       Object Declared Type            Bytes Dimen Elements Attributes       References                        
                                                                                                                                    
 ASSOCIATED                 Func   4202                                 scalar                    4145,4164,4202                    
 FIELD_TYPE                 Dummy  4204     CHAR            8           scalar   ARG,OUT          4204,4209                         
 INDEX                      Dummy  4205     I(4)            4           scalar   ARG,OUT          4205,4210                         
 LOOP_LIST                  Local  4212     CHAR            512         scalar                    4145,4155,4162,4163,4212,5415,5674
 LOOP_LIST_P                Local  4202     FIELD_DEF       400         scalar   PTR              583,4145,4149,4156,4163,4164,4165,
                                                                                                  4202,4203,4204,4205,5416,5673     
 NAME                       Dummy  4203     CHAR                        scalar   ARG,OUT          4203,4208                         
 SET_LIST_STUFF             Func   4193     L(4)            4           scalar                    4150,4157,4166                    
 SUCCESS                    Local  4198     L(4)            4           scalar                    4206,4211                         

Page 119         Source Listing                  SET_LIST_STUFF
2021-06-01 08:55                                 field_manager.F90

   4216 ! </FUNCTION> NAME="set_list_stuff"
   4217 
   4218 end function  fm_loop_over_list_old


ENTRY POINTS

  Name                                                   
                                                         
 field_manager_mod_mp_fm_loop_over_list_old_             


SYMBOL CROSS REFERENCE

 Name                       Object Declared Type            Bytes Dimen Elements Attributes       References                        
                                                                                                                                    
 FM_LOOP_OVER_LIST_OLD      Func   4095     L(4)            4           scalar   PRIV             4018,4039                         
 LIST                       Dummy  4095     CHAR                        scalar   ARG,IN           4145,4151,4162,4174               
 OUT_UNIT                   Local  4135     I(4)            4           scalar                    4137,4173                         
 SUB_NAME                   Param  4128     CHAR            17          scalar                    4130                              
 SUCCESS                    Local  4116     L(4)            4           scalar                    4150,4157,4166,4176               
 TEMP_LIST_P                Local  4134     FIELD_DEF       400         scalar   PTR,SAVE                                           
 TRIM                       Func   4129                                 scalar                    4129,4130,4173,4174               
 WARN_HEADER                Param  4129     CHAR            64          scalar                    4173                              

Page 120         Source Listing                  SET_LIST_STUFF
2021-06-01 08:55                                 field_manager.F90

   4219 ! </FUNCTION> NAME="fm_loop_over_list"
   4220 
   4221 !#######################################################################
   4222 ! given a name of the list, prepares an iterator over the list content.
   4223 ! If the name of the given list is blank, then the current list is used
   4224 subroutine fm_init_loop(loop_list, iter)
   4225   character(len=*)       , intent(in)  :: loop_list ! name of the list to iterate over
   4226   type(fm_list_iter_type), intent(out) :: iter     ! loop iterator
   4227 
   4228   if (.not.module_is_initialized) call initialize
   4229 
   4230   if (loop_list==' ') then ! looping over current list
   4231      iter%ptr => current_list_p%first_field
   4232   else
   4233      iter%ptr => find_list(loop_list,current_list_p,.false.)
   4234      if (associated(iter%ptr)) iter%ptr => iter%ptr%first_field
   4235   endif
   4236 end subroutine fm_init_loop


ENTRY POINTS

  Name                                          
                                                
 field_manager_mod_mp_fm_init_loop_             


SYMBOL CROSS REFERENCE

 Name                       Object Declared Type            Bytes Dimen Elements Attributes       References                        
                                                                                                                                    
 ASSOCIATED                 Func   4234                                 scalar                    4234                              
 FM_INIT_LOOP               Subr   4224                                                                                             
 FM_LIST_ITER_TYPE          Type   4226                     8           scalar                    435,4226,4244                     
 ITER                       Dummy  4224     FM_LIST_ITER_TYPE                                                                       
                                                            8           scalar   ARG,OUT          4231,4233,4234                    
 LOOP_LIST                  Dummy  4224     CHAR                        scalar   ARG,IN           4230,4233                         


TYPE COMPONENTS/COMMON VARIABLES

 Name                       Type            Bytes Offset   Dimen Elements Attributes       References                         
                                                                                                                              
 FM_LIST_ITER_TYPE.PTR      FIELD_DEF       400   0              scalar   PTR              4231,4233,4234,4250,4251,4252,4253 
                                                                                           ,4255                              

Page 121         Source Listing                  FM_INIT_LOOP
2021-06-01 08:55                                 field_manager.F90

   4237 
   4238 !#######################################################################
   4239 ! given a list iterator, returns information about curren list element
   4240 ! and advances the iterator to the next list element. At the end of the
   4241 ! list, returns FALSE
   4242 function fm_loop_over_list_new(iter, name, field_type, index) &
   4243          result (success) ; logical success
   4244   type (fm_list_iter_type), intent(inout) :: iter ! list iterator
   4245   character(len=*), intent(out) :: name       ! name of the current list item
   4246   character(len=*), intent(out) :: field_type ! type of the field
   4247   integer         , intent(out) :: index      ! index in the list
   4248 
   4249   if (.not.module_is_initialized) call initialize
   4250   if (associated(iter%ptr)) then
   4251      name       = iter%ptr%name
   4252      field_type = field_type_name(iter%ptr%field_type)
   4253      index      = iter%ptr%index
   4254      success    = .TRUE.
   4255      iter%ptr => iter%ptr%next
   4256   else
   4257      name       = ' '
   4258      field_type = ' '
   4259      index      = 0
   4260      success    = .FALSE.
   4261   endif
   4262 end function fm_loop_over_list_new


ENTRY POINTS

  Name                                                   
                                                         
 field_manager_mod_mp_fm_loop_over_list_new_             

Page 122         Source Listing                  FM_LOOP_OVER_LIST_NEW
2021-06-01 08:55 Symbol Table                    field_manager.F90



SYMBOL CROSS REFERENCE

 Name                       Object Declared Type            Bytes Dimen Elements Attributes       References                        
                                                                                                                                    
 ASSOCIATED                 Func   4250                                 scalar                    4250                              
 FIELD_TYPE                 Dummy  4242     CHAR                        scalar   ARG,OUT          4252,4258                         
 FM_LOOP_OVER_LIST_NEW      Func   4242     L(4)            4           scalar   PRIV                                               
 INDEX                      Dummy  4242     I(4)            4           scalar   ARG,OUT          4253,4259                         
 ITER                       Dummy  4242     FM_LIST_ITER_TYPE                                                                       
                                                            8           scalar   ARG,INOUT        4250,4251,4252,4253,4255          
 NAME                       Dummy  4242     CHAR                        scalar   ARG,OUT          4251,4257                         
 SUCCESS                    Result 4243     L(4)            4           scalar                    4254,4260                         

Page 123         Source Listing                  FM_LOOP_OVER_LIST_NEW
2021-06-01 08:55                                 field_manager.F90

   4263 
   4264 !#######################################################################
   4265 !#######################################################################
   4266 
   4267 ! <FUNCTION NAME="fm_new_list">
   4268 !
   4269 ! <OVERVIEW>
   4270 !    A function to create a new list.
   4271 ! </OVERVIEW>
   4272 ! <DESCRIPTION>
   4273 !    Allocate and initialize a new list and return the index of the list.
   4274 !    If an error occurs return the parameter NO_FIELD.
   4275 ! </DESCRIPTION>
   4276 !   <TEMPLATE>
   4277 !     index = fm_new_list(name, create, keep)
   4278 !   </TEMPLATE>
   4279 !
   4280 function  fm_new_list(name, create, keep)                        &
   4281           result (index)  !{
   4282 !   <OUT NAME="index" TYPE="integer">
   4283 !     The index of the newly created list.
   4284 !   </OUT>
   4285 !   <IN NAME="name" TYPE="character(len=*)">
   4286 !     The name of a list that the user wishes to create.
   4287 !   </IN>
   4288 !   <IN NAME="create" TYPE="logical, optional">
   4289 !     If present and .true., create the list if it does not exist.
   4290 !   </IN>
   4291 !   <IN NAME="keep" TYPE="logical, optional">
   4292 !     If present and .true., make this list the current list.
   4293 !   </IN>
   4294 !
   4295 !        Function definition
   4296 !
   4297 integer                                :: index
   4298 !
   4299 !        arguments
   4300 !
   4301 character(len=*), intent(in)           :: name
   4302 logical,          intent(in), optional :: create
   4303 logical,          intent(in), optional :: keep
   4304 
   4305 !+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   4306 !        local parameters
   4307 !+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   4308 character(len=11), parameter :: sub_name     = 'fm_new_list'
   4309 character(len=64), parameter :: warn_header  = '==>Warning from ' // trim(module_name) //  &
   4310                                                '(' // trim(sub_name) // '): '
   4311 !+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   4312 !        local variables
   4313 !+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   4314 logical                          :: create_t
   4315 logical                          :: keep_t
   4316 character(len=fm_path_name_len)  :: path
   4317 character(len=fm_field_name_len) :: base
   4318 type (field_def), pointer, save  :: temp_list_p
   4319 integer                         :: out_unit

Page 124         Source Listing                  FM_NEW_LIST
2021-06-01 08:55                                 field_manager.F90

   4320 
   4321 out_unit = stdout()
   4322 !
   4323 !        Initialize the field manager if needed
   4324 !
   4325 if (.not. module_is_initialized) then  !{
   4326   call initialize
   4327 endif  !}
   4328 !
   4329 !        Must supply a field list name
   4330 !
   4331 if (name .eq. ' ') then  !{
   4332   if (verb .gt. verb_level_warn) then  !{
   4333     write (out_unit,*) trim(warn_header), 'Must supply a list name'
   4334   endif  !}
   4335   index = NO_FIELD
   4336   return
   4337 endif  !}
   4338 !
   4339 !        Check for optional arguments
   4340 !
   4341 if (present(create)) then  !{
   4342   create_t = create
   4343 else  !}{
   4344   create_t = .false.
   4345 endif  !}
   4346 
   4347 if (present(keep)) then  !{
   4348   keep_t = keep
   4349 else  !}{
   4350   keep_t = .false.
   4351 endif  !}
   4352 !
   4353 !        Get a pointer to the parent list
   4354 !
   4355 call find_base(name, path, base)
   4356 
   4357 temp_list_p => find_list(path, current_list_p, create_t)
   4358 
   4359 if (associated(temp_list_p)) then  !{
   4360 !
   4361 !        Create the list
   4362 !
   4363   temp_list_p => make_list(temp_list_p, base)
   4364   if (associated(temp_list_p)) then  !{
   4365 !
   4366 !        Make this list the current list, if requested
   4367 !
   4368     if (keep_t) then  !{
   4369       current_list_p => temp_list_p
   4370     endif  !}
   4371     index = temp_list_p%index
   4372   else  !}{
   4373 !
   4374 !        Error in making the list
   4375 !
   4376 

Page 125         Source Listing                  FM_NEW_LIST
2021-06-01 08:55                                 field_manager.F90

   4377     if (verb .gt. verb_level_warn) then  !{
   4378       write (out_unit,*) trim(warn_header),                        &
   4379            'Could not create list ', trim(name)
   4380     endif  !}
   4381     index = NO_FIELD
   4382 
   4383   endif  !}
   4384 else  !}{
   4385 !
   4386 !        Error following the path
   4387 !
   4388 
   4389   if (verb .gt. verb_level_warn) then  !{
   4390     write (out_unit,*) trim(warn_header),                  &
   4391          'Could not follow path for ', trim(name)
   4392   endif  !}
   4393   index = NO_FIELD
   4394 
   4395 endif  !}
   4396 
   4397 end function  fm_new_list  !}


ENTRY POINTS

  Name                                         
                                               
 field_manager_mod_mp_fm_new_list_             

Page 126         Source Listing                  FM_NEW_LIST
2021-06-01 08:55 Symbol Table                    field_manager.F90



SYMBOL CROSS REFERENCE

 Name                       Object Declared Type            Bytes Dimen Elements Attributes       References                        
                                                                                                                                    
 ASSOCIATED                 Func   4359                                 scalar                    4359,4364                         
 BASE                       Local  4317     CHAR            48          scalar                    4355,4363                         
 CREATE                     Dummy  4280     L(4)            4           scalar   ARG,IN           4341,4342                         
 CREATE_T                   Local  4314     L(4)            4           scalar                    4342,4344,4357                    
 FIND_BASE                  Subr   4355                                          PRIV             287,4355,4539,4774,5011,5246,5519,
                                                                                                  5587,5855,6158                    
 FM_NEW_LIST                Func   4280     I(4)            4           scalar                                                      
 INDEX                      Local  4297     I(4)            4           scalar                    4335,4371,4381,4393               
 KEEP                       Dummy  4280     L(4)            4           scalar   ARG,IN           4347,4348                         
 KEEP_T                     Local  4315     L(4)            4           scalar                    4348,4350,4368                    
 NAME                       Dummy  4280     CHAR                        scalar   ARG,IN           4331,4355,4379,4391               
 OUT_UNIT                   Local  4319     I(4)            4           scalar                    4321,4333,4378,4390               
 PATH                       Local  4316     CHAR            512         scalar                    4355,4357                         
 PRESENT                    Func   4341                                 scalar                    4341,4347                         
 SUB_NAME                   Param  4308     CHAR            11          scalar                    4310                              
 TEMP_LIST_P                Local  4318     FIELD_DEF       400         scalar   PTR,TGT,SAVE     4357,4359,4363,4364,4369,4371     
 TRIM                       Func   4309                                 scalar                    4309,4310,4333,4378,4379,4390,4391
 WARN_HEADER                Param  4309     CHAR            64          scalar                    4333,4378,4390                    

Page 127         Source Listing                  FM_NEW_LIST
2021-06-01 08:55                                 field_manager.F90

   4398 ! </FUNCTION> NAME="fm_new_list"
   4399 
   4400 !#######################################################################
   4401 !#######################################################################
   4402 
   4403 ! <FUNCTION NAME="fm_new_value">
   4404 !
   4405 ! <OVERVIEW>
   4406 !    An overloaded function to assign a value to a field.
   4407 ! </OVERVIEW>
   4408 ! <DESCRIPTION>
   4409 !    Allocate and initialize a new value and return the index.
   4410 !    If an error condition occurs the parameter NO_FIELD is returned.
   4411 !
   4412 !    If the type of the field is changing (e.g. real values being transformed to
   4413 !    integers), then any previous values for the field are removed and replaced
   4414 !    by the value passed in the present call to this function.
   4415 !
   4416 !    If append is present and .true., then index cannot be greater than 0 if
   4417 !    it is present.
   4418 ! </DESCRIPTION>
   4419 !   <TEMPLATE>
   4420 !     field_index = fm_new_value(name, value, [create], [index], [append])
   4421 !   </TEMPLATE>
   4422 !
   4423 function  fm_new_value_integer(name, value, create, index, append)     &
   4424           result (field_index)  !{
   4425 !   <OUT NAME="field_index" TYPE="integer">
   4426 !     An index for the named field.
   4427 !   </OUT>
   4428 !   <IN NAME="name" TYPE="character(len=*)">
   4429 !     The name of a field that the user wishes to create a value for.
   4430 !   </IN>
   4431 !   <IN NAME="value" TYPE="integer, real, logical, or character(len=*)">
   4432 !     The value that the user wishes to apply to the named field.
   4433 !   </IN>
   4434 !   <IN NAME="create" TYPE="logical, optional">
   4435 !     If present and .true., then a value for this field will be created.
   4436 !   </IN>
   4437 !   <IN NAME="index" TYPE="integer, optional">
   4438 !     The index to an array of values that the user wishes to apply a new value.
   4439 !   </IN>
   4440 !   <IN NAME="append" TYPE="logical, optional">
   4441 !     If present and .true., then append the value to an array of the present
   4442 !     values. If present and .true., then index cannot be greater than 0.
   4443 !   </IN>
   4444 !
   4445 !        Function definition
   4446 !
   4447 integer                                :: field_index
   4448 !
   4449 !        arguments
   4450 !
   4451 character(len=*), intent(in)           :: name
   4452 integer,          intent(in)           :: value
   4453 logical,          intent(in), optional :: create
   4454 integer,          intent(in), optional :: index

Page 128         Source Listing                  FM_NEW_VALUE_INTEGER
2021-06-01 08:55                                 field_manager.F90

   4455 logical,          intent(in), optional :: append
   4456 
   4457 !+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   4458 !        local parameters
   4459 !+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   4460 character(len=20), parameter :: sub_name     = 'fm_new_value_integer'
   4461 character(len=64), parameter :: warn_header  = '==>Warning from ' // trim(module_name) //  &
   4462                                                '(' // trim(sub_name) // '): '
   4463 !+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   4464 !        local variables
   4465 !+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   4466 logical                          :: create_t
   4467 integer                          :: i, ier
   4468 integer                          :: index_t
   4469 integer, pointer, dimension(:)   :: temp_i_value
   4470 character(len=fm_path_name_len)  :: path
   4471 character(len=fm_field_name_len) :: base
   4472 type (field_def), pointer, save  :: temp_list_p
   4473 type (field_def), pointer, save  :: temp_field_p
   4474 integer                          :: out_unit
   4475 
   4476 out_unit = stdout()
   4477 !
   4478 !        Initialize the field manager if needed
   4479 !
   4480 if (.not. module_is_initialized) then  !{
   4481   call initialize
   4482 endif  !}
   4483 !
   4484 !        Must supply a field name
   4485 !
   4486 if (name .eq. ' ') then  !{
   4487   if (verb .gt. verb_level_warn) then  !{
   4488     write (out_unit,*) trim(warn_header), 'Must supply a field name'
   4489   endif  !}
   4490   field_index = NO_FIELD
   4491   return
   4492 endif  !}
   4493 !
   4494 !        Check for optional arguments
   4495 !
   4496 if (present(create)) then  !{
   4497   create_t = create
   4498 else  !}{
   4499   create_t = .false.
   4500 endif  !}
   4501 !
   4502 !        Check that append is not true and index non-positive
   4503 !
   4504 
   4505 if (present(index) .and. present(append)) then  !{
   4506   if (append .and. index .gt. 0) then  !{
   4507     if (verb .gt. verb_level_warn) then  !{
   4508       write (out_unit,*) trim(warn_header),                          &
   4509            'Index and Append both set for ', trim(name)
   4510     endif  !}
   4511     field_index = NO_FIELD

Page 129         Source Listing                  FM_NEW_VALUE_INTEGER
2021-06-01 08:55                                 field_manager.F90

   4512     return
   4513   endif  !}
   4514 endif  !}
   4515 !
   4516 !        Set index to define
   4517 !
   4518 if (present(index)) then  !{
   4519   index_t = index
   4520   if (index_t .lt. 0) then  !{
   4521 !
   4522 !        Index is negative
   4523 !
   4524 
   4525     if (verb .gt. verb_level_warn) then  !{
   4526       write (out_unit,*) trim(warn_header),                     &
   4527            'Optional index for ', trim(name),                   &
   4528            ' negative: ', index_t
   4529     endif  !}
   4530     field_index = NO_FIELD
   4531     return
   4532   endif  !}
   4533 else  !}{
   4534   index_t = 1
   4535 endif  !}
   4536 !
   4537 !        Get a pointer to the parent list
   4538 !
   4539 call find_base(name, path, base)
   4540 temp_list_p => find_list(path, current_list_p, create_t)
   4541 
   4542 if (associated(temp_list_p)) then  !{
   4543   temp_field_p => find_field(base, temp_list_p)
   4544   if (.not. associated(temp_field_p)) then  !{
   4545 !
   4546 !        Create the field if it doesn't exist
   4547 !
   4548     temp_field_p => create_field(temp_list_p, base)
   4549   endif  !}
   4550   if (associated(temp_field_p)) then  !{
   4551 !
   4552 !        Check if the field_type is the same as previously
   4553 !        If not then reset max_index to 0
   4554 !
   4555     if (temp_field_p%field_type == real_type ) then
   4556 ! promote integer input to real
   4557        field_index = fm_new_value_real(name, real(value), create, index, append)
   4558        return
   4559     else if (temp_field_p%field_type /= integer_type ) then
   4560 !  slm: why would we reset index? Is it not an error to have a "list" defined
   4561 !  with different types in more than one place?
   4562       temp_field_p%max_index = 0
   4563       if (temp_field_p%field_type /= null_type ) then  !{
   4564         if (verb .gt. verb_level_warn) then  !{
   4565           write (out_unit,*) trim(warn_header),                   &
   4566                'Changing type of ', trim(name), ' from ',         &
   4567                trim(field_type_name(temp_field_p%field_type)),    &
   4568                ' to ', trim(field_type_name(integer_type))

Page 130         Source Listing                  FM_NEW_VALUE_INTEGER
2021-06-01 08:55                                 field_manager.F90

   4569         endif  !}
   4570       endif  !}
   4571     endif
   4572 !
   4573 !        Assign the type
   4574 !
   4575     temp_field_p%field_type = integer_type
   4576 !
   4577 !        Set the index if appending
   4578 !
   4579 
   4580     if (present(append)) then  !{
   4581       if (append) then  !{
   4582         index_t = temp_field_p%max_index + 1
   4583       endif  !}
   4584     endif  !}
   4585 
   4586     if (index_t .gt. temp_field_p%max_index + 1) then  !{
   4587 
   4588 !
   4589 !        Index too large
   4590 !
   4591 
   4592       if (verb .gt. verb_level_warn) then  !{
   4593         write (out_unit,*) trim(warn_header),                   &
   4594              'Index too large for ', trim(name), ': ', index_t
   4595       endif  !}
   4596       field_index = NO_FIELD
   4597       return
   4598 
   4599     elseif (index_t .eq. 0 .and.                                &
   4600             temp_field_p%max_index .gt. 0) then  !}{
   4601 !
   4602 !        Can't set non-null field to null
   4603 !
   4604 
   4605       if (verb .gt. verb_level_warn) then  !{
   4606         write (out_unit,*) trim(warn_header),                   &
   4607              'Trying to nullify a non-null field: ',            &
   4608              trim(name)
   4609       endif  !}
   4610       field_index = NO_FIELD
   4611       return
   4612 
   4613     elseif (.not. associated(temp_field_p%i_value) .and.        &
   4614             index_t .gt. 0) then  !}{
   4615 !
   4616 !        Array undefined, so allocate the array
   4617 !
   4618       allocate(temp_field_p%i_value(1))
   4619       temp_field_p%max_index = 1
   4620       temp_field_p%array_dim = 1
   4621     elseif (index_t .gt. temp_field_p%array_dim) then  !}{
   4622 !
   4623 !        Array is too small, so allocate new array and copy over
   4624 !        old values
   4625 !

Page 131         Source Listing                  FM_NEW_VALUE_INTEGER
2021-06-01 08:55                                 field_manager.F90

   4626       temp_field_p%array_dim = temp_field_p%array_dim + array_increment
   4627       allocate (temp_i_value(temp_field_p%array_dim))
   4628       do i = 1, temp_field_p%max_index  !{
   4629         temp_i_value(i) = temp_field_p%i_value(i)
   4630       enddo  !} i
   4631       if (associated (temp_field_p%i_value)) deallocate(temp_field_p%i_value)
   4632       temp_field_p%i_value => temp_i_value
   4633       temp_field_p%max_index = index_t
   4634     endif  !}
   4635 !
   4636 !        Assign the value and set the field_index for return
   4637 !        for non-null fields (index_t > 0)
   4638 !
   4639     if (index_t .gt. 0) then  !{
   4640       temp_field_p%i_value(index_t) = value
   4641       if (index_t .gt. temp_field_p%max_index) then  !{
   4642         temp_field_p%max_index = index_t
   4643       endif  !}
   4644     endif  !}
   4645     field_index = temp_field_p%index
   4646 
   4647   else  !}{
   4648 !
   4649 !        Error in making the field
   4650 !
   4651 
   4652     if (verb .gt. verb_level_warn) then  !{
   4653       write (out_unit,*) trim(warn_header),                     &
   4654            'Could not create integer value field ',             &
   4655            trim(name)
   4656     endif  !}
   4657     field_index = NO_FIELD
   4658   endif  !}
   4659 else  !}{
   4660 !
   4661 !        Error following the path
   4662 !
   4663 
   4664   if (verb .gt. verb_level_warn) then  !{
   4665     write (out_unit,*) trim(warn_header),                       &
   4666          'Could not follow path for ',                          &
   4667          trim(name)
   4668   endif  !}
   4669   field_index = NO_FIELD
   4670 endif  !}
   4671 
   4672 end function  fm_new_value_integer  !}

Page 132         Source Listing                  FM_NEW_VALUE_INTEGER
2021-06-01 08:55 Entry Points                    field_manager.F90



ENTRY POINTS

  Name                                                  
                                                        
 field_manager_mod_mp_fm_new_value_integer_             


SYMBOL CROSS REFERENCE

 Name                       Object Declared Type            Bytes Dimen Elements Attributes       References                        
                                                                                                                                    
 APPEND                     Dummy  4423     L(4)            4           scalar   ARG,IN           4505,4506,4557,4580,4581          
 ARRAY_INCREMENT            Param  4626     I(4)            4           scalar                    4626,4859,5099,5332               
 ASSOCIATED                 Func   4542                                 scalar                    4542,4544,4550,4613,4631          
 BASE                       Local  4471     CHAR            48          scalar                    4539,4543,4548                    
 CREATE                     Dummy  4423     L(4)            4           scalar   ARG,IN           4496,4497,4557                    
 CREATE_FIELD               Func   4548     RECORD          400         scalar   PTR,PRIV         285,4548,4783,5020,5255,5760      
 CREATE_T                   Local  4466     L(4)            4           scalar                    4497,4499,4540                    
 FIELD_INDEX                Local  4447     I(4)            4           scalar                    4490,4511,4530,4557,4596,4610,4645
                                                                                                  ,4657,4669                        
 FM_NEW_VALUE_INTEGER       Func   4423     I(4)            4           scalar                                                      
 I                          Local  4467     I(4)            4           scalar                    4628,4629                         
 IER                        Local  4467     I(4)            4           scalar                                                      
 INDEX                      Dummy  4423     I(4)            4           scalar   ARG,IN           4505,4506,4518,4519,4557          
 INDEX_T                    Local  4468     I(4)            4           scalar                    4519,4520,4528,4534,4582,4586,4594
                                                                                                  ,4599,4614,4621,4633,4639,4640,464
                                                                                                  1,4642                            
 NAME                       Dummy  4423     CHAR                        scalar   ARG,IN           4486,4509,4527,4539,4557,4566,4594
                                                                                                  ,4608,4655,4667                   
 OUT_UNIT                   Local  4474     I(4)            4           scalar                    4476,4488,4508,4526,4565,4593,4606
                                                                                                  ,4653,4665                        
 PATH                       Local  4470     CHAR            512         scalar                    4539,4540                         
 PRESENT                    Func   4496                                 scalar                    4496,4505,4518,4580               
 REAL                       Func   4557                                 scalar                    4557                              
 SUB_NAME                   Param  4460     CHAR            20          scalar                    4462                              
 TEMP_FIELD_P               Local  4473     FIELD_DEF       400         scalar   PTR,SAVE         4543,4544,4548,4550,4555,4559,4562
                                                                                                  ,4563,4567,4575,4582,4586,4600,461
                                                                                                  3,4618,4619,4620,4621,4626,4627,46
                                                                                                  28,4629,4631,4632,4633,4640,4641,4
                                                                                                  642,4645                          
 TEMP_I_VALUE               Local  4469     I(4)            4     1     1        PTR              4627,4629,4632                    
 TEMP_LIST_P                Local  4472     FIELD_DEF       400         scalar   PTR,SAVE         4540,4542,4543,4548               
 TRIM                       Func   4461                                 scalar                    4461,4462,4488,4508,4509,4526,4527
                                                                                                  ,4565,4566,4567,4568,4593,4594,460
                                                                                                  6,4608,4653,4655,4665,4667        
 VALUE                      Dummy  4423     I(4)            4           scalar   ARG,IN           4557,4640                         
 WARN_HEADER                Param  4461     CHAR            64          scalar                    4488,4508,4526,4565,4593,4606,4653
                                                                                                  ,4665                             

Page 133         Source Listing                  FM_NEW_VALUE_INTEGER
2021-06-01 08:55                                 field_manager.F90

   4673 
   4674 !#######################################################################
   4675 !#######################################################################
   4676 
   4677 function  fm_new_value_logical(name, value, create, index, append) &
   4678           result (field_index)  !{
   4679 !
   4680 !        Function definition
   4681 !
   4682 integer                                :: field_index
   4683 !
   4684 !        arguments
   4685 !
   4686 character(len=*), intent(in)           :: name
   4687 logical,          intent(in)           :: value
   4688 logical,          intent(in), optional :: create
   4689 integer,          intent(in), optional :: index
   4690 logical,          intent(in), optional :: append
   4691 
   4692 !+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   4693 !        local parameters
   4694 !+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   4695 character(len=20), parameter :: sub_name     = 'fm_new_value_logical'
   4696 character(len=64), parameter :: warn_header  = '==>Warning from ' // trim(module_name) //  &
   4697                                                '(' // trim(sub_name) // '): '
   4698 !+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   4699 !        local variables
   4700 !+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   4701 character(len=fm_path_name_len)      :: path
   4702 character(len=fm_field_name_len)     :: base
   4703 integer                              :: i, ier
   4704 integer                              :: index_t
   4705 logical                              :: create_t
   4706 logical, dimension(:), pointer       :: temp_l_value
   4707 type (field_def),      pointer, save :: temp_list_p
   4708 type (field_def),      pointer, save :: temp_field_p
   4709 integer                              :: out_unit
   4710 
   4711 out_unit = stdout()
   4712 !
   4713 !        Initialize the field manager if needed
   4714 !
   4715 if (.not. module_is_initialized) then  !{
   4716   call initialize
   4717 endif  !}
   4718 !
   4719 !        Must supply a field name
   4720 !
   4721 if (name .eq. ' ') then  !{
   4722   if (verb .gt. verb_level_warn) then  !{
   4723     write (out_unit,*) trim(warn_header), 'Must supply a field name'
   4724   endif  !}
   4725   field_index = NO_FIELD
   4726   return
   4727 endif  !}
   4728 !
   4729 !        Check for optional arguments

Page 134         Source Listing                  FM_NEW_VALUE_LOGICAL
2021-06-01 08:55                                 field_manager.F90

   4730 !
   4731 if (present(create)) then  !{
   4732   create_t = create
   4733 else  !}{
   4734   create_t = .false.
   4735 endif  !}
   4736 !
   4737 !        Check that append is not true and index greater than 0
   4738 !
   4739 if (present(index) .and. present(append)) then  !{
   4740   if (append .and. index .gt. 0) then  !{
   4741     if (verb .gt. verb_level_warn) then  !{
   4742       write (out_unit,*) trim(warn_header),                          &
   4743            'Index and Append both set for ', trim(name)
   4744     endif  !}
   4745     field_index = NO_FIELD
   4746     return
   4747   endif  !}
   4748 endif  !}
   4749 !
   4750 !        Set index to define
   4751 !
   4752 
   4753 if (present(index)) then  !{
   4754   index_t = index
   4755   if (index_t .lt. 0) then  !{
   4756 !
   4757 !        Index is negative
   4758 !
   4759 
   4760     if (verb .gt. verb_level_warn) then  !{
   4761       write (out_unit,*) trim(warn_header),                     &
   4762            'Optional index for ', trim(name),                   &
   4763            ' negative: ', index_t
   4764     endif  !}
   4765     field_index = NO_FIELD
   4766     return
   4767   endif  !}
   4768 else  !}{
   4769   index_t = 1
   4770 endif !}
   4771 !
   4772 !        Get a pointer to the parent list
   4773 !
   4774 call find_base(name, path, base)
   4775 temp_list_p => find_list(path, current_list_p, create_t)
   4776 
   4777 if (associated(temp_list_p)) then  !{
   4778   temp_field_p => find_field(base, temp_list_p)
   4779   if (.not. associated(temp_field_p)) then  !{
   4780 !
   4781 !        Create the field if it doesn't exist
   4782 !
   4783     temp_field_p => create_field(temp_list_p, base)
   4784   endif  !}
   4785   if (associated(temp_field_p)) then  !{
   4786 !

Page 135         Source Listing                  FM_NEW_VALUE_LOGICAL
2021-06-01 08:55                                 field_manager.F90

   4787 !        Check if the field_type is the same as previously
   4788 !        If not then reset max_index to 0
   4789 !
   4790     if (temp_field_p%field_type /= logical_type ) then
   4791         temp_field_p%max_index = 0
   4792       if (temp_field_p%field_type /= null_type ) then  !{
   4793         if (verb .gt. verb_level_warn) then  !{
   4794           write (out_unit,*) trim(warn_header),                   &
   4795                'Changing type of ', trim(name), ' from ',         &
   4796                trim(field_type_name(temp_field_p%field_type)),    &
   4797                ' to ', trim(field_type_name(logical_type))
   4798         endif  !}
   4799       endif  !}
   4800     endif
   4801 !
   4802 !        Assign the type
   4803 !
   4804     temp_field_p%field_type = logical_type
   4805 !
   4806 !        Set the index if appending
   4807 !
   4808 
   4809     if (present(append)) then  !{
   4810       if (append) then  !{
   4811         index_t = temp_field_p%max_index + 1
   4812       endif  !}
   4813     endif  !}
   4814 
   4815     if (index_t .gt. temp_field_p%max_index + 1) then  !{
   4816 
   4817 !
   4818 !        Index too large
   4819 !
   4820 
   4821       if (verb .gt. verb_level_warn) then  !{
   4822         write (out_unit,*) trim(warn_header),                   &
   4823              'Index too large for ', trim(name), ': ', index_t
   4824       endif  !}
   4825       field_index = NO_FIELD
   4826       return
   4827 
   4828     elseif (index_t .eq. 0 .and.                                &
   4829             temp_field_p%max_index .gt. 0) then  !}{
   4830 
   4831 !
   4832 !        Can't set non-null field to null
   4833 !
   4834 
   4835       if (verb .gt. verb_level_warn) then  !{
   4836         write (out_unit,*) trim(warn_header),                   &
   4837              'Trying to nullify a non-null field: ', trim(name)
   4838       endif  !}
   4839       field_index = NO_FIELD
   4840       return
   4841 
   4842     elseif (.not. associated(temp_field_p%l_value) .and.        &
   4843             index_t .gt. 0) then  !}{

Page 136         Source Listing                  FM_NEW_VALUE_LOGICAL
2021-06-01 08:55                                 field_manager.F90

   4844 
   4845 !
   4846 !        Array undefined, so allocate the array
   4847 !
   4848 
   4849       allocate(temp_field_p%l_value(1))
   4850       temp_field_p%max_index = 1
   4851       temp_field_p%array_dim = 1
   4852 
   4853     elseif (index_t .gt. temp_field_p%array_dim) then  !}{
   4854 
   4855 !
   4856 !        Array is too small, so allocate new array and copy over
   4857 !        old values
   4858 !
   4859       temp_field_p%array_dim = temp_field_p%array_dim + array_increment
   4860       allocate (temp_l_value(temp_field_p%array_dim))
   4861       do i = 1, temp_field_p%max_index  !{
   4862         temp_l_value(i) = temp_field_p%l_value(i)
   4863       enddo  !} i
   4864       if (associated(temp_field_p%l_value)) deallocate(temp_field_p%l_value)
   4865       temp_field_p%l_value => temp_l_value
   4866       temp_field_p%max_index = index_t
   4867 
   4868     endif  !}
   4869 
   4870 !
   4871 !        Assign the value and set the field_index for return
   4872 !        for non-null fields (index_t > 0)
   4873 !
   4874 
   4875     if (index_t .gt. 0) then  !{
   4876       temp_field_p%l_value(index_t) = value
   4877       if (index_t .gt. temp_field_p%max_index) then  !{
   4878         temp_field_p%max_index = index_t
   4879       endif  !}
   4880     endif  !}
   4881     field_index = temp_field_p%index
   4882   else  !}{
   4883 !
   4884 !        Error in making the field
   4885 !
   4886 
   4887     if (verb .gt. verb_level_warn) then  !{
   4888       write (out_unit,*) trim(warn_header),                     &
   4889            'Could not create logical value field ',             &
   4890            trim(name)
   4891     endif  !}
   4892     field_index = NO_FIELD
   4893   endif  !}
   4894 else  !}{
   4895 !
   4896 !        Error following the path
   4897 !
   4898 
   4899   if (verb .gt. verb_level_warn) then  !{
   4900     write (out_unit,*) trim(warn_header),                       &

Page 137         Source Listing                  FM_NEW_VALUE_LOGICAL
2021-06-01 08:55                                 field_manager.F90

   4901          'Could not follow path for ',                          &
   4902          trim(name)
   4903   endif  !}
   4904   field_index = NO_FIELD
   4905 endif  !}
   4906 
   4907 end function  fm_new_value_logical  !}


ENTRY POINTS

  Name                                                  
                                                        
 field_manager_mod_mp_fm_new_value_logical_             


SYMBOL CROSS REFERENCE

 Name                       Object Declared Type            Bytes Dimen Elements Attributes       References                        
                                                                                                                                    
 APPEND                     Dummy  4677     L(4)            4           scalar   ARG,IN           4739,4740,4809,4810               
 ASSOCIATED                 Func   4777                                 scalar                    4777,4779,4785,4842,4864          
 BASE                       Local  4702     CHAR            48          scalar                    4774,4778,4783                    
 CREATE                     Dummy  4677     L(4)            4           scalar   ARG,IN           4731,4732                         
 CREATE_T                   Local  4705     L(4)            4           scalar                    4732,4734,4775                    
 FIELD_INDEX                Local  4682     I(4)            4           scalar                    4725,4745,4765,4825,4839,4881,4892
                                                                                                  ,4904                             
 FM_NEW_VALUE_LOGICAL       Func   4677     I(4)            4           scalar                                                      
 I                          Local  4703     I(4)            4           scalar                    4861,4862                         
 IER                        Local  4703     I(4)            4           scalar                                                      
 INDEX                      Dummy  4677     I(4)            4           scalar   ARG,IN           4739,4740,4753,4754               
 INDEX_T                    Local  4704     I(4)            4           scalar                    4754,4755,4763,4769,4811,4815,4823
                                                                                                  ,4828,4843,4853,4866,4875,4876,487
                                                                                                  7,4878                            
 NAME                       Dummy  4677     CHAR                        scalar   ARG,IN           4721,4743,4762,4774,4795,4823,4837
                                                                                                  ,4890,4902                        
 OUT_UNIT                   Local  4709     I(4)            4           scalar                    4711,4723,4742,4761,4794,4822,4836
                                                                                                  ,4888,4900                        
 PATH                       Local  4701     CHAR            512         scalar                    4774,4775                         
 PRESENT                    Func   4731                                 scalar                    4731,4739,4753,4809               
 SUB_NAME                   Param  4695     CHAR            20          scalar                    4697                              
 TEMP_FIELD_P               Local  4708     FIELD_DEF       400         scalar   PTR,SAVE         4778,4779,4783,4785,4790,4791,4792
                                                                                                  ,4796,4804,4811,4815,4829,4842,484
                                                                                                  9,4850,4851,4853,4859,4860,4861,48
                                                                                                  62,4864,4865,4866,4876,4877,4878,4
                                                                                                  881                               
 TEMP_LIST_P                Local  4707     FIELD_DEF       400         scalar   PTR,SAVE         4775,4777,4778,4783               
 TEMP_L_VALUE               Local  4706     L(4)            4     1     1        PTR              4860,4862,4865                    
 TRIM                       Func   4696                                 scalar                    4696,4697,4723,4742,4743,4761,4762
                                                                                                  ,4794,4795,4796,4797,4822,4823,483
                                                                                                  6,4837,4888,4890,4900,4902        
 VALUE                      Dummy  4677     L(4)            4           scalar   ARG,IN           4876                              
 WARN_HEADER                Param  4696     CHAR            64          scalar                    4723,4742,4761,4794,4822,4836,4888
                                                                                                  ,4900                             

Page 138         Source Listing                  FM_NEW_VALUE_LOGICAL
2021-06-01 08:55                                 field_manager.F90

   4908 
   4909 !#######################################################################
   4910 !#######################################################################
   4911 
   4912 function  fm_new_value_real(name, value, create, index, append) &
   4913           result (field_index)  !{
   4914 !
   4915 !        Function definition
   4916 !
   4917 integer                                :: field_index
   4918 !
   4919 !        arguments
   4920 !
   4921 character(len=*), intent(in)           :: name
   4922 real,             intent(in)           :: value
   4923 logical,          intent(in), optional :: create
   4924 integer,          intent(in), optional :: index
   4925 logical,          intent(in), optional :: append
   4926 !+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   4927 !        local parameters
   4928 !+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   4929 
   4930 character(len=17), parameter :: sub_name     = 'fm_new_value_real'
   4931 character(len=64), parameter :: warn_header  = '==>Warning from ' // trim(module_name) //  &
   4932                                                '(' // trim(sub_name) // '): '
   4933 !+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   4934 !        local variables
   4935 !+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   4936 
   4937 logical                          :: create_t
   4938 integer                          :: i, ier
   4939 integer                          :: index_t
   4940 real, pointer, dimension(:)      :: temp_r_value
   4941 character(len=fm_path_name_len)  :: path
   4942 character(len=fm_field_name_len) :: base
   4943 type (field_def), pointer, save  :: temp_list_p
   4944 type (field_def), pointer, save  :: temp_field_p
   4945 integer                          :: out_unit
   4946 
   4947 out_unit = stdout()
   4948 !
   4949 !        Initialize the field manager if needed
   4950 !
   4951 if (.not. module_is_initialized) then  !{
   4952   call initialize
   4953 endif  !}
   4954 !
   4955 !        Must supply a field name
   4956 !
   4957 if (name .eq. ' ') then  !{
   4958   if (verb .gt. verb_level_warn) then  !{
   4959     write (out_unit,*) trim(warn_header), 'Must supply a field name'
   4960   endif  !}
   4961   field_index = NO_FIELD
   4962   return
   4963 endif  !}
   4964 !

Page 139         Source Listing                  FM_NEW_VALUE_REAL
2021-06-01 08:55                                 field_manager.F90

   4965 !        Check for optional arguments
   4966 !
   4967 if (present(create)) then  !{
   4968   create_t = create
   4969 else  !}{
   4970   create_t = .false.
   4971 endif  !}
   4972 !
   4973 !        Check that append is not true and index greater than 0
   4974 !
   4975 if (present(index) .and. present(append)) then  !{
   4976   if (append .and. index .gt. 0) then  !{
   4977     if (verb .gt. verb_level_warn) then  !{
   4978       write (out_unit,*) trim(warn_header),                          &
   4979            'Index and Append both set for ', trim(name)
   4980     endif  !}
   4981     field_index = NO_FIELD
   4982     return
   4983   endif  !}
   4984 endif  !}
   4985 !
   4986 !        Set index to define
   4987 !
   4988 
   4989 if (present(index)) then  !{
   4990   index_t = index
   4991   if (index_t .lt. 0) then  !{
   4992 !
   4993 !        Index is negative
   4994 !
   4995 
   4996     if (verb .gt. verb_level_warn) then  !{
   4997       write (out_unit,*) trim(warn_header),                     &
   4998            'Optional index for ', trim(name),                   &
   4999            ' negative: ', index_t
   5000     endif  !}
   5001     field_index = NO_FIELD
   5002     return
   5003   endif  !}
   5004 else  !}{
   5005   index_t = 1
   5006 endif !}
   5007 
   5008 !
   5009 !        Get a pointer to the parent list
   5010 !
   5011 call find_base(name, path, base)
   5012 temp_list_p => find_list(path, current_list_p, create_t)
   5013 
   5014 if (associated(temp_list_p)) then  !{
   5015   temp_field_p => find_field(base, temp_list_p)
   5016   if (.not. associated(temp_field_p)) then  !{
   5017 !
   5018 !        Create the field if it doesn't exist
   5019 !
   5020     temp_field_p => create_field(temp_list_p, base)
   5021   endif  !}

Page 140         Source Listing                  FM_NEW_VALUE_REAL
2021-06-01 08:55                                 field_manager.F90

   5022   if (associated(temp_field_p)) then  !{
   5023 !
   5024 !        Check if the field_type is the same as previously
   5025 !        If not then reset max_index to 0
   5026 !
   5027     if (temp_field_p%field_type == integer_type) then
   5028 ! promote integer field to real
   5029        allocate(temp_field_p%r_value(size(temp_field_p%i_value)))
   5030        do i = 1, size(temp_field_p%i_value)
   5031           temp_field_p%r_value(i) = temp_field_p%i_value(i)
   5032        enddo
   5033        temp_field_p%field_type = real_type
   5034        deallocate(temp_field_p%i_value)
   5035     else if (temp_field_p%field_type /= real_type ) then
   5036 ! slm: why reset index to 0? does it make any sense? It sounds like this is the
   5037 ! case where the values in the array have different types, so is it not an error?
   5038 ! Or, alternatively, if string follows a real value, should not be the entire
   5039 ! array converted to string type?
   5040       temp_field_p%max_index = 0
   5041       if (temp_field_p%field_type /= null_type ) then  !{
   5042         if (verb .gt. verb_level_warn) then  !{
   5043           write (out_unit,*) trim(warn_header),                   &
   5044                'Changing type of ', trim(name), ' from ',         &
   5045                trim(field_type_name(temp_field_p%field_type)),    &
   5046                ' to ', trim(field_type_name(real_type))
   5047         endif  !}
   5048       endif  !}
   5049     endif
   5050 !
   5051 !        Assign the type
   5052 !
   5053     temp_field_p%field_type = real_type
   5054 !
   5055 !        Set the index if appending
   5056 !
   5057     if (present(append)) then  !{
   5058       if (append) then  !{
   5059         index_t = temp_field_p%max_index + 1
   5060       endif  !}
   5061     endif  !}
   5062     if (index_t .gt. temp_field_p%max_index + 1) then  !{
   5063 !
   5064 !        Index too large
   5065 !
   5066 
   5067       if (verb .gt. verb_level_warn) then  !{
   5068         write (out_unit,*) trim(warn_header),                   &
   5069              'Index too large for ', trim(name), ': ', index_t
   5070       endif  !}
   5071       field_index = NO_FIELD
   5072       return
   5073     elseif (index_t .eq. 0 .and.                                &
   5074             temp_field_p%max_index .gt. 0) then  !}{
   5075 !
   5076 !        Can't set non-null field to null
   5077 !
   5078 

Page 141         Source Listing                  FM_NEW_VALUE_REAL
2021-06-01 08:55                                 field_manager.F90

   5079       if (verb .gt. verb_level_warn) then  !{
   5080         write (out_unit,*) trim(warn_header),                   &
   5081              'Trying to nullify a non-null field: ',            &
   5082              trim(name)
   5083       endif  !}
   5084       field_index = NO_FIELD
   5085       return
   5086     elseif (.not. associated(temp_field_p%r_value) .and.        &
   5087             index_t .gt. 0) then  !}{
   5088 !
   5089 !        Array undefined, so allocate the array
   5090 !
   5091       allocate(temp_field_p%r_value(1))
   5092       temp_field_p%max_index = 1
   5093       temp_field_p%array_dim = 1
   5094     elseif (index_t .gt. temp_field_p%array_dim) then  !}{
   5095 !
   5096 !        Array is too small, so allocate new array and copy over
   5097 !        old values
   5098 !
   5099       temp_field_p%array_dim = temp_field_p%array_dim + array_increment
   5100       allocate (temp_r_value(temp_field_p%array_dim))
   5101       do i = 1, temp_field_p%max_index  !{
   5102         temp_r_value(i) = temp_field_p%r_value(i)
   5103       enddo  !} i
   5104       if (associated(temp_field_p%r_value)) deallocate(temp_field_p%r_value)
   5105       temp_field_p%r_value => temp_r_value
   5106       temp_field_p%max_index = index_t
   5107     endif  !}
   5108 !
   5109 !        Assign the value and set the field_index for return
   5110 !        for non-null fields (index_t > 0)
   5111 !
   5112     if (index_t .gt. 0) then  !{
   5113       temp_field_p%r_value(index_t) = value
   5114       if (index_t .gt. temp_field_p%max_index) then  !{
   5115         temp_field_p%max_index = index_t
   5116       endif  !}
   5117     endif  !}
   5118     field_index = temp_field_p%index
   5119   else  !}{
   5120 !
   5121 !        Error in making the field
   5122 !
   5123 
   5124     if (verb .gt. verb_level_warn) then  !{
   5125       write (out_unit,*) trim(warn_header),                        &
   5126            'Could not create real value field ', trim(name)
   5127     endif  !}
   5128     field_index = NO_FIELD
   5129   endif  !}
   5130 else  !}{
   5131 !
   5132 !        Error following the path
   5133 !
   5134 
   5135   if (verb .gt. verb_level_warn) then  !{

Page 142         Source Listing                  FM_NEW_VALUE_REAL
2021-06-01 08:55                                 field_manager.F90

   5136     write (out_unit,*) trim(warn_header),                          &
   5137          'Could not follow path for ', trim(name)
   5138   endif  !}
   5139   field_index = NO_FIELD
   5140 endif  !}
   5141 
   5142 end function  fm_new_value_real  !}


ENTRY POINTS

  Name                                               
                                                     
 field_manager_mod_mp_fm_new_value_real_             


SYMBOL CROSS REFERENCE

 Name                       Object Declared Type            Bytes Dimen Elements Attributes       References                        
                                                                                                                                    
 APPEND                     Dummy  4912     L(4)            4           scalar   ARG,IN           4975,4976,5057,5058               
 ASSOCIATED                 Func   5014                                 scalar                    5014,5016,5022,5086,5104          
 BASE                       Local  4942     CHAR            48          scalar                    5011,5015,5020                    
 CREATE                     Dummy  4912     L(4)            4           scalar   ARG,IN           4967,4968                         
 CREATE_T                   Local  4937     L(4)            4           scalar                    4968,4970,5012                    
 FIELD_INDEX                Local  4917     I(4)            4           scalar                    4961,4981,5001,5071,5084,5118,5128
                                                                                                  ,5139                             
 FM_NEW_VALUE_REAL          Func   4912     I(4)            4           scalar                                                      
 I                          Local  4938     I(4)            4           scalar                    5030,5031,5101,5102               
 IER                        Local  4938     I(4)            4           scalar                                                      
 INDEX                      Dummy  4912     I(4)            4           scalar   ARG,IN           4975,4976,4989,4990               
 INDEX_T                    Local  4939     I(4)            4           scalar                    4990,4991,4999,5005,5059,5062,5069
                                                                                                  ,5073,5087,5094,5106,5112,5113,511
                                                                                                  4,5115                            
 NAME                       Dummy  4912     CHAR                        scalar   ARG,IN           4957,4979,4998,5011,5044,5069,5082
                                                                                                  ,5126,5137                        
 OUT_UNIT                   Local  4945     I(4)            4           scalar                    4947,4959,4978,4997,5043,5068,5080
                                                                                                  ,5125,5136                        
 PATH                       Local  4941     CHAR            512         scalar                    5011,5012                         
 PRESENT                    Func   4967                                 scalar                    4967,4975,4989,5057               
 SIZE                       Func   5029                                 scalar                    5029,5030                         
 SUB_NAME                   Param  4930     CHAR            17          scalar                    4932                              
 TEMP_FIELD_P               Local  4944     FIELD_DEF       400         scalar   PTR,SAVE         5015,5016,5020,5022,5027,5029,5030
                                                                                                  ,5031,5033,5034,5035,5040,5041,504
                                                                                                  5,5053,5059,5062,5074,5086,5091,50
                                                                                                  92,5093,5094,5099,5100,5101,5102,5
                                                                                                  104,5105,5106,5113,5114,5115,5118 
 TEMP_LIST_P                Local  4943     FIELD_DEF       400         scalar   PTR,SAVE         5012,5014,5015,5020               
 TEMP_R_VALUE               Local  4940     R(8)            8     1     1        PTR              5100,5102,5105                    
 TRIM                       Func   4931                                 scalar                    4931,4932,4959,4978,4979,4997,4998
                                                                                                  ,5043,5044,5045,5046,5068,5069,508
                                                                                                  0,5082,5125,5126,5136,5137        
 VALUE                      Dummy  4912     R(8)            8           scalar   ARG,IN           5113                              
 WARN_HEADER                Param  4931     CHAR            64          scalar                    4959,4978,4997,5043,5068,5080,5125
                                                                                                  ,5136                             

Page 143         Source Listing                  FM_NEW_VALUE_REAL
2021-06-01 08:55                                 field_manager.F90

   5143 
   5144 !#######################################################################
   5145 !#######################################################################
   5146 
   5147 function  fm_new_value_string(name, value, create, index, append) &
   5148           result (field_index)  !{
   5149 !
   5150 !        Function definition
   5151 !
   5152 integer                                :: field_index
   5153 !
   5154 !        arguments
   5155 !
   5156 character(len=*), intent(in)           :: name
   5157 character(len=*), intent(in)           :: value
   5158 logical,          intent(in), optional :: create
   5159 integer,          intent(in), optional :: index
   5160 logical,          intent(in), optional :: append
   5161 !+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   5162 !        local parameters
   5163 !+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   5164 
   5165 character(len=19), parameter :: sub_name     = 'fm_new_value_string'
   5166 character(len=64), parameter :: warn_header  = '==>Warning from ' // trim(module_name) //  &
   5167                                                '(' // trim(sub_name) // '): '
   5168 !+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   5169 !        local variables
   5170 !+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   5171 
   5172 character(len=fm_string_len), dimension(:), pointer :: temp_s_value
   5173 character(len=fm_path_name_len)                     :: path
   5174 character(len=fm_field_name_len)                    :: base
   5175 integer                                             :: i, ier
   5176 integer                                             :: index_t
   5177 logical                                             :: create_t
   5178 type (field_def),                     save, pointer :: temp_list_p
   5179 type (field_def),                     save, pointer :: temp_field_p
   5180 integer                         :: out_unit
   5181 
   5182 out_unit = stdout()
   5183 !
   5184 !        Initialize the field manager if needed
   5185 !
   5186 if (.not. module_is_initialized) then  !{
   5187   call initialize
   5188 endif  !}
   5189 !
   5190 !        Must supply a field name
   5191 !
   5192 if (name .eq. ' ') then  !{
   5193   if (verb .gt. verb_level_warn) then  !{
   5194     write (out_unit,*) trim(warn_header), 'Must supply a field name'
   5195   endif  !}
   5196   field_index = NO_FIELD
   5197   return
   5198 endif  !}
   5199 !

Page 144         Source Listing                  FM_NEW_VALUE_STRING
2021-06-01 08:55                                 field_manager.F90

   5200 !        Check for optional arguments
   5201 !
   5202 if (present(create)) then  !{
   5203   create_t = create
   5204 else  !}{
   5205   create_t = .false.
   5206 endif  !}
   5207 !
   5208 !        Check that append is not true and index greater than 0
   5209 !
   5210 
   5211 if (present(index) .and. present(append)) then  !{
   5212   if (append .and. index .gt. 0) then  !{
   5213     if (verb .gt. verb_level_warn) then  !{
   5214       write (out_unit,*) trim(warn_header),                     &
   5215            'Index and Append both set for ', trim(name)
   5216     endif  !}
   5217     field_index = NO_FIELD
   5218     return
   5219   endif  !}
   5220 endif  !}
   5221 !
   5222 !        Set index to define
   5223 !
   5224 if (present(index)) then  !{
   5225   index_t = index
   5226   if (index_t .lt. 0) then  !{
   5227 !
   5228 !        Index is negative
   5229 !
   5230 
   5231     if (verb .gt. verb_level_warn) then  !{
   5232       write (out_unit,*) trim(warn_header),                     &
   5233            'Optional index for ', trim(name),                   &
   5234            ' negative: ', index_t
   5235     endif  !}
   5236     field_index = NO_FIELD
   5237     return
   5238   endif  !}
   5239 else  !}{
   5240   index_t = 1
   5241 endif  !}
   5242 
   5243 !
   5244 !        Get a pointer to the parent list
   5245 !
   5246 call find_base(name, path, base)
   5247 temp_list_p => find_list(path, current_list_p, create_t)
   5248 
   5249 if (associated(temp_list_p)) then  !{
   5250   temp_field_p => find_field(base, temp_list_p)
   5251   if (.not. associated(temp_field_p)) then  !{
   5252 !
   5253 !        Create the field if it doesn't exist
   5254 !
   5255     temp_field_p => create_field(temp_list_p, base)
   5256   endif  !}

Page 145         Source Listing                  FM_NEW_VALUE_STRING
2021-06-01 08:55                                 field_manager.F90

   5257   if (associated(temp_field_p)) then  !{
   5258 !
   5259 !        Check if the field_type is the same as previously
   5260 !        If not then reset max_index to 0
   5261 !
   5262     if (temp_field_p%field_type /= string_type ) then
   5263         temp_field_p%max_index = 0
   5264       if (temp_field_p%field_type /= null_type ) then  !{
   5265         if (verb .gt. verb_level_warn) then  !{
   5266           write (out_unit,*) trim(warn_header),                   &
   5267                'Changing type of ', trim(name), ' from ',         &
   5268                trim(field_type_name(temp_field_p%field_type)),    &
   5269                ' to ', trim(field_type_name(string_type))
   5270         endif  !}
   5271       endif  !}
   5272     endif
   5273 !
   5274 !        Assign the type
   5275 !
   5276     temp_field_p%field_type = string_type
   5277 !
   5278 !        Set the index if appending
   5279 !
   5280 
   5281     if (present(append)) then  !{
   5282       if (append) then  !{
   5283         index_t = temp_field_p%max_index + 1
   5284       endif  !}
   5285     endif  !}
   5286 
   5287     if (index_t .gt. temp_field_p%max_index + 1) then  !{
   5288 
   5289 !
   5290 !        Index too large
   5291 !
   5292 
   5293       if (verb .gt. verb_level_warn) then  !{
   5294         write (out_unit,*) trim(warn_header),                   &
   5295              'Index too large for ', trim(name), ': ', index_t
   5296       endif  !}
   5297       field_index = NO_FIELD
   5298       return
   5299 
   5300     elseif (index_t .eq. 0 .and.                                &
   5301             temp_field_p%max_index .gt. 0) then  !}{
   5302 
   5303 !
   5304 !        Can't set non-null field to null
   5305 !
   5306 
   5307       if (verb .gt. verb_level_warn) then  !{
   5308         write (out_unit,*) trim(warn_header),                   &
   5309              'Trying to nullify a non-null field: ',            &
   5310              trim(name)
   5311       endif  !}
   5312       field_index = NO_FIELD
   5313       return

Page 146         Source Listing                  FM_NEW_VALUE_STRING
2021-06-01 08:55                                 field_manager.F90

   5314 
   5315     elseif (.not. associated(temp_field_p%s_value) .and.        &
   5316             index_t .gt. 0) then  !}{
   5317 
   5318 !
   5319 !        Array undefined, so allocate the array
   5320 !
   5321 
   5322       allocate(temp_field_p%s_value(1))
   5323       temp_field_p%max_index = 1
   5324       temp_field_p%array_dim = 1
   5325 
   5326     elseif (index_t .gt. temp_field_p%array_dim) then  !}{
   5327 
   5328 !
   5329 !        Array is too small, so allocate new array and copy over
   5330 !        old values
   5331 !
   5332       temp_field_p%array_dim = temp_field_p%array_dim + array_increment
   5333       allocate (temp_s_value(temp_field_p%array_dim))
   5334       do i = 1, temp_field_p%max_index  !{
   5335         temp_s_value(i) = temp_field_p%s_value(i)
   5336       enddo  !} i
   5337       if (associated(temp_field_p%s_value)) deallocate(temp_field_p%s_value)
   5338       temp_field_p%s_value => temp_s_value
   5339       temp_field_p%max_index = index_t
   5340 
   5341     endif  !}
   5342 
   5343 !
   5344 !        Assign the value and set the field_index for return
   5345 !        for non-null fields (index_t > 0)
   5346 !
   5347 
   5348     if (index_t .gt. 0) then  !{
   5349       temp_field_p%s_value(index_t) = value
   5350       if (index_t .gt. temp_field_p%max_index) then  !{
   5351         temp_field_p%max_index = index_t
   5352       endif  !}
   5353     endif  !}
   5354     field_index = temp_field_p%index
   5355   else  !}{
   5356 !
   5357 !        Error in making the field
   5358 !
   5359 
   5360     if (verb .gt. verb_level_warn) then  !{
   5361       write (out_unit,*) trim(warn_header),                     &
   5362            'Could not create string value field ',              &
   5363            trim(name)
   5364     endif  !}
   5365     field_index = NO_FIELD
   5366   endif  !}
   5367 else  !}{
   5368 !
   5369 !        Error following the path
   5370 !

Page 147         Source Listing                  FM_NEW_VALUE_STRING
2021-06-01 08:55                                 field_manager.F90

   5371 
   5372   if (verb .gt. verb_level_warn) then  !{
   5373     write (out_unit,*) trim(warn_header),                       &
   5374          'Could not follow path for ', trim(name)
   5375   endif  !}
   5376   field_index = NO_FIELD
   5377 endif  !}
   5378 
   5379 end function  fm_new_value_string  !}


ENTRY POINTS

  Name                                                 
                                                       
 field_manager_mod_mp_fm_new_value_string_             


SYMBOL CROSS REFERENCE

 Name                       Object Declared Type            Bytes Dimen Elements Attributes       References                        
                                                                                                                                    
 APPEND                     Dummy  5147     L(4)            4           scalar   ARG,IN           5211,5212,5281,5282               
 ASSOCIATED                 Func   5249                                 scalar                    5249,5251,5257,5315,5337          
 BASE                       Local  5174     CHAR            48          scalar                    5246,5250,5255                    
 CREATE                     Dummy  5147     L(4)            4           scalar   ARG,IN           5202,5203                         
 CREATE_T                   Local  5177     L(4)            4           scalar                    5203,5205,5247                    
 FIELD_INDEX                Local  5152     I(4)            4           scalar                    5196,5217,5236,5297,5312,5354,5365
                                                                                                  ,5376                             
 FM_NEW_VALUE_STRING        Func   5147     I(4)            4           scalar                                                      
 I                          Local  5175     I(4)            4           scalar                    5334,5335                         
 IER                        Local  5175     I(4)            4           scalar                                                      
 INDEX                      Dummy  5147     I(4)            4           scalar   ARG,IN           5211,5212,5224,5225               
 INDEX_T                    Local  5176     I(4)            4           scalar                    5225,5226,5234,5240,5283,5287,5295
                                                                                                  ,5300,5316,5326,5339,5348,5349,535
                                                                                                  0,5351                            
 NAME                       Dummy  5147     CHAR                        scalar   ARG,IN           5192,5215,5233,5246,5267,5295,5310
                                                                                                  ,5363,5374                        
 OUT_UNIT                   Local  5180     I(4)            4           scalar                    5182,5194,5214,5232,5266,5294,5308
                                                                                                  ,5361,5373                        
 PATH                       Local  5173     CHAR            512         scalar                    5246,5247                         
 PRESENT                    Func   5202                                 scalar                    5202,5211,5224,5281               
 SUB_NAME                   Param  5165     CHAR            19          scalar                    5167                              
 TEMP_FIELD_P               Local  5179     FIELD_DEF       400         scalar   PTR,SAVE         5250,5251,5255,5257,5262,5263,5264
                                                                                                  ,5268,5276,5283,5287,5301,5315,532
                                                                                                  2,5323,5324,5326,5332,5333,5334,53
                                                                                                  35,5337,5338,5339,5349,5350,5351,5
                                                                                                  354                               
 TEMP_LIST_P                Local  5178     FIELD_DEF       400         scalar   PTR,SAVE         5247,5249,5250,5255               
 TEMP_S_VALUE               Local  5172     CHAR            128   1     1        PTR              5333,5335,5338                    
 TRIM                       Func   5166                                 scalar                    5166,5167,5194,5214,5215,5232,5233
                                                                                                  ,5266,5267,5268,5269,5294,5295,530
                                                                                                  8,5310,5361,5363,5373,5374        
 VALUE                      Dummy  5147     CHAR                        scalar   ARG,IN           5349                              
 WARN_HEADER                Param  5166     CHAR            64          scalar                    5194,5214,5232,5266,5294,5308,5361
                                                                                                  ,5373                             

Page 148         Source Listing                  FM_NEW_VALUE_STRING
2021-06-01 08:55                                 field_manager.F90

   5380 ! </FUNCTION> NAME="fm_new_value"
   5381 
   5382 
   5383 !#######################################################################
   5384 !#######################################################################
   5385 
   5386 ! <FUNCTION NAME="fm_reset_loop">
   5387 !
   5388 ! <OVERVIEW>
   5389 !    Resets the loop variable. For use in conjunction with fm_loop_over_list.
   5390 ! </OVERVIEW>
   5391 ! <DESCRIPTION>
   5392 !    Resets the loop variable. For use in conjunction with fm_loop_over_list.
   5393 ! </DESCRIPTION>
   5394 !   <TEMPLATE>
   5395 !     call fm_reset_loop
   5396 !   </TEMPLATE>
   5397 !
   5398 subroutine  fm_reset_loop
   5399 !
   5400 !        arguments
   5401 !
   5402 !+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   5403 !        local variables
   5404 !+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   5405 
   5406 !
   5407 !        Initialize the field manager if needed
   5408 !
   5409 if (.not. module_is_initialized) then  !{
   5410   call initialize
   5411 endif  !}
   5412 !
   5413 !        Reset the variables
   5414 !
   5415 loop_list = ' '
   5416 nullify(loop_list_p)
   5417 
   5418 end subroutine  fm_reset_loop  !}

Page 149         Source Listing                  FM_RESET_LOOP
2021-06-01 08:55 Entry Points                    field_manager.F90



ENTRY POINTS

  Name                                           
                                                 
 field_manager_mod_mp_fm_reset_loop_             


SYMBOL CROSS REFERENCE

 Name                       Object Declared Type            Bytes Dimen Elements Attributes       References                        
                                                                                                                                    
 FM_RESET_LOOP              Subr   5398                                                                                             

Page 150         Source Listing                  FM_RESET_LOOP
2021-06-01 08:55                                 field_manager.F90

   5419 ! </FUNCTION> NAME="fm_reset_loop"
   5420 
   5421 !#######################################################################
   5422 !#######################################################################
   5423 
   5424 ! <FUNCTION NAME="fm_return_root">
   5425 !
   5426 ! <OVERVIEW>
   5427 !    Return the root list to the value at initialization
   5428 ! </OVERVIEW>
   5429 ! <DESCRIPTION>
   5430 !    Return the root list to the value at initialization.
   5431 !    For use in conjunction with fm_change_root.
   5432 !
   5433 !    Users should use this routine before leaving their routine if they
   5434 !    previously used fm_change_root.
   5435 ! </DESCRIPTION>
   5436 !   <TEMPLATE>
   5437 !     call fm_return_root
   5438 !   </TEMPLATE>
   5439 !
   5440 subroutine  fm_return_root  !{
   5441 !
   5442 !        arguments
   5443 !
   5444 !+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   5445 !        local variables
   5446 !+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   5447 !
   5448 !        Initialize the field manager if needed
   5449 !
   5450 if (.not. module_is_initialized) then  !{
   5451   call initialize
   5452 endif  !}
   5453 !
   5454 !        restore the saved values to the current root
   5455 !
   5456 root_p%name = save_root_name
   5457 root_p%parent => save_root_parent_p
   5458 !
   5459 !        set the pointer to the original root field
   5460 !
   5461 root_p => root
   5462 !
   5463 !        reset the save root name and parent variables
   5464 !
   5465 save_root_name = ' '
   5466 nullify(save_root_parent_p)
   5467 
   5468 end subroutine  fm_return_root  !}

Page 151         Source Listing                  FM_RETURN_ROOT
2021-06-01 08:55 Entry Points                    field_manager.F90



ENTRY POINTS

  Name                                            
                                                  
 field_manager_mod_mp_fm_return_root_             


SYMBOL CROSS REFERENCE

 Name                       Object Declared Type            Bytes Dimen Elements Attributes       References                        
                                                                                                                                    
 FM_RETURN_ROOT             Subr   5440                                                                                             
 ROOT                       Local  5461     FIELD_DEF       400         scalar   TGT,SAVE         5461,5644,5652,5653,5654,5656,5658
                                                                                                  ,5659,5660,5661,5662,5663,5664,566
                                                                                                  5,5666,5668,5669,5671             

Page 152         Source Listing                  FM_RETURN_ROOT
2021-06-01 08:55                                 field_manager.F90

   5469 ! </FUNCTION> NAME="fm_return_root"
   5470 
   5471 !#######################################################################
   5472 !#######################################################################
   5473 
   5474 ! <PRIVATE><FUNCTION NAME="get_field">
   5475 !
   5476 ! <OVERVIEW>
   5477 !    Return a pointer to the field if it exists relative to this_list_p,
   5478 !    null otherwise
   5479 ! </OVERVIEW>
   5480 ! <DESCRIPTION>
   5481 !    Return a pointer to the field if it exists relative to this_list_p,
   5482 !    null otherwise
   5483 ! </DESCRIPTION>
   5484 !   <TEMPLATE>
   5485 !     list_p => get_field(name, this_list_p)
   5486 !   </TEMPLATE>
   5487 !
   5488 function get_field(name, this_list_p)                                        &
   5489         result (list_p)  !{
   5490 !   <OUT NAME="list_p" TYPE="type (field_def)">
   5491 !     A pointer to the field name.
   5492 !   </OUT>
   5493 !   <IN NAME="name" TYPE="character(len=*)">
   5494 !     The name of a list that the user wishes to get information for.
   5495 !   </IN>
   5496 !   <IN NAME="this_list_p" TYPE="type (field_def)">
   5497 !     A pointer to a list that serves as the base point for searching for name.
   5498 !   </IN>
   5499 !
   5500 !        Function definition
   5501 !
   5502 type (field_def), pointer        :: list_p
   5503 !
   5504 !        arguments
   5505 !
   5506 character(len=*), intent(in)     :: name
   5507 type (field_def), pointer        :: this_list_p
   5508 !+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   5509 !        local variables
   5510 !+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   5511 character(len=fm_path_name_len)  :: path
   5512 character(len=fm_field_name_len) :: base
   5513 type (field_def), pointer, save  :: temp_p
   5514 
   5515 nullify(list_p)
   5516 !
   5517 !        Get the path and base for name
   5518 !
   5519 call find_base(name, path, base)
   5520 !
   5521 !        Find the list if path is not empty
   5522 !
   5523 if (path .ne. ' ') then  !{
   5524   temp_p => find_list(path, this_list_p, .false.)
   5525   if (associated(temp_p)) then  !{

Page 153         Source Listing                  GET_FIELD
2021-06-01 08:55                                 field_manager.F90

   5526     list_p => find_field(base, temp_p)
   5527   else  !}{
   5528     nullify(list_p)
   5529   endif  !}
   5530 else  !}{
   5531   list_p => find_field(base, this_list_p)
   5532 endif  !}
   5533 
   5534 end function get_field  !}


ENTRY POINTS

  Name                                       
                                             
 field_manager_mod_mp_get_field_             


SYMBOL CROSS REFERENCE

 Name                       Object Declared Type            Bytes Dimen Elements Attributes       References                        
                                                                                                                                    
 ASSOCIATED                 Func   5525                                 scalar                    5525                              
 BASE                       Local  5512     CHAR            48          scalar                    5519,5526,5531                    
 GET_FIELD                  Func   5488     FIELD_DEF       400         scalar   PTR                                                
 LIST_P                     Local  5502     FIELD_DEF       400         scalar   PTR              5515,5526,5528,5531               
 NAME                       Dummy  5488     CHAR                        scalar   ARG,IN           5519                              
 PATH                       Local  5511     CHAR            512         scalar                    5519,5523,5524                    
 TEMP_P                     Local  5513     FIELD_DEF       400         scalar   PTR,SAVE         5524,5525,5526                    
 THIS_LIST_P                Dummy  5488     FIELD_DEF       400         scalar   ARG,PTR,INOUT    5524,5531                         

Page 154         Source Listing                  GET_FIELD
2021-06-01 08:55                                 field_manager.F90

   5535 ! </FUNCTION> NAME="get_field"
   5536 !</PRIVATE>
   5537 
   5538 
   5539 !#######################################################################
   5540 !#######################################################################
   5541 
   5542 ! <FUNCTION NAME="fm_modify_name">
   5543 !
   5544 ! <OVERVIEW>
   5545 !    This function allows a user to rename a field without modifying the
   5546 !    contents of the field.
   5547 ! </OVERVIEW>
   5548 ! <DESCRIPTION>
   5549 !    Function to modify the name of a field.
   5550 !    Should be used with caution.
   5551 ! </DESCRIPTION>
   5552 !   <TEMPLATE>
   5553 !     success = fm_modify_name(oldname, newname)
   5554 !   </TEMPLATE>
   5555 !
   5556 function fm_modify_name(oldname, newname)                                        &
   5557         result (success)  !{
   5558 !   <OUT NAME="success" TYPE="logical">
   5559 !     A flag to indicate whether the function operated with (FALSE) or
   5560 !     without (TRUE) errors.
   5561 !   </OUT>
   5562 !   <IN NAME="oldname" TYPE="character(len=*)">
   5563 !     The name of a field that the user wishes to change the name of.
   5564 !   </IN>
   5565 !   <IN NAME="newname" TYPE="character(len=*)">
   5566 !     The name that the user wishes to change the name of the field to.
   5567 !   </IN>
   5568 !
   5569 !        Function definition
   5570 !
   5571 logical                          :: success
   5572 !
   5573 !        arguments
   5574 !
   5575 character(len=*), intent(in)     :: oldname
   5576 character(len=*), intent(in)     :: newname
   5577 !+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   5578 !        local variables
   5579 !+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   5580 character(len=fm_path_name_len)  :: path
   5581 character(len=fm_field_name_len) :: base
   5582 type (field_def), pointer, save  :: list_p
   5583 type (field_def), pointer, save  :: temp_p
   5584 !
   5585 !        Get the path and base for name
   5586 !
   5587 call find_base(oldname, path, base)
   5588 !
   5589 !        Find the list if path is not empty
   5590 !
   5591 success = .false.

Page 155         Source Listing                  FM_MODIFY_NAME
2021-06-01 08:55                                 field_manager.F90

   5592 if (path .ne. ' ') then  !{
   5593   temp_p => find_list(path, current_list_p, .false.)
   5594   if (associated(temp_p)) then  !{
   5595     list_p => find_field(base, temp_p)
   5596     if (associated(list_p)) then !{
   5597       list_p%name = newname
   5598       success = .true.
   5599     endif!}
   5600   else  !}{
   5601     nullify(list_p)
   5602   endif  !}
   5603 else  !}{
   5604   list_p => find_field(base, current_list_p)
   5605   if (associated(list_p)) then !{
   5606     list_p%name = newname
   5607     success = .true.
   5608   endif !}
   5609 endif  !}
   5610 
   5611 end function fm_modify_name  !}


ENTRY POINTS

  Name                                            
                                                  
 field_manager_mod_mp_fm_modify_name_             


SYMBOL CROSS REFERENCE

 Name                       Object Declared Type            Bytes Dimen Elements Attributes       References                        
                                                                                                                                    
 ASSOCIATED                 Func   5594                                 scalar                    5594,5596,5605                    
 BASE                       Local  5581     CHAR            48          scalar                    5587,5595,5604                    
 FM_MODIFY_NAME             Func   5556     L(4)            4           scalar                                                      
 LIST_P                     Local  5582     FIELD_DEF       400         scalar   PTR,SAVE         5595,5596,5597,5601,5604,5605,5606
 NEWNAME                    Dummy  5556     CHAR                        scalar   ARG,IN           5597,5606                         
 OLDNAME                    Dummy  5556     CHAR                        scalar   ARG,IN           5587                              
 PATH                       Local  5580     CHAR            512         scalar                    5587,5592,5593                    
 SUCCESS                    Local  5571     L(4)            4           scalar                    5591,5598,5607                    
 TEMP_P                     Local  5583     FIELD_DEF       400         scalar   PTR,SAVE         5593,5594,5595                    

Page 156         Source Listing                  FM_MODIFY_NAME
2021-06-01 08:55                                 field_manager.F90

   5612 ! </FUNCTION> NAME="fm_modify_name"
   5613 
   5614 
   5615 !#######################################################################
   5616 !#######################################################################
   5617 
   5618 ! <PRIVATE><FUNCTION NAME="initialize">
   5619 !
   5620 ! <OVERVIEW>
   5621 !    A function to initialize the values of the pointers. This will remove
   5622 !    all fields and reset the field tree to only the root field.
   5623 ! </OVERVIEW>
   5624 ! <DESCRIPTION>
   5625 !    A function to initialize the values of the pointers. This will remove
   5626 !    all fields and reset the field tree to only the root field.
   5627 ! </DESCRIPTION>
   5628 !   <TEMPLATE>
   5629 !     call initialize
   5630 !   </TEMPLATE>
   5631 !
   5632 subroutine initialize  !{
   5633 !
   5634 !        arguments
   5635 !
   5636 !+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   5637 !        local variables
   5638 !+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   5639 integer :: ier
   5640 !
   5641 !        Initialize the root field
   5642 !
   5643 if (.not. module_is_initialized) then  !{
   5644   root_p => root
   5645 
   5646   field_type_name(integer_type) = 'integer'
   5647   field_type_name(list_type) = 'list'
   5648   field_type_name(logical_type) = 'logical'
   5649   field_type_name(real_type) = 'real'
   5650   field_type_name(string_type) = 'string'
   5651 
   5652   root%name = ' '
   5653   root%index = 1
   5654   root%parent => root_p
   5655 
   5656   root%field_type = list_type
   5657 
   5658   root%length = 0
   5659   nullify(root%first_field)
   5660   nullify(root%last_field)
   5661   root%max_index = 0
   5662   root%array_dim = 0
   5663   if (associated(root%i_value)) deallocate(root%i_value)
   5664   if (associated(root%l_value)) deallocate(root%l_value)
   5665   if (associated(root%r_value)) deallocate(root%r_value)
   5666   if (associated(root%s_value)) deallocate(root%s_value)
   5667 
   5668   nullify(root%next)

Page 157         Source Listing                  INITIALIZE
2021-06-01 08:55                                 field_manager.F90

   5669   nullify(root%prev)
   5670 
   5671   current_list_p => root
   5672 
   5673   nullify(loop_list_p)
   5674   loop_list = ' '
   5675 
   5676   nullify(save_root_parent_p)
   5677   save_root_name = ' '
   5678 
   5679   module_is_initialized = .true.
   5680 
   5681 endif  !}
   5682 
   5683 end subroutine initialize  !}


ENTRY POINTS

  Name                                        
                                              
 field_manager_mod_mp_initialize_             


SYMBOL CROSS REFERENCE

 Name                       Object Declared Type            Bytes Dimen Elements Attributes       References                        
                                                                                                                                    
 ASSOCIATED                 Func   5663                                 scalar                    5663,5664,5665,5666               
 IER                        Local  5639     I(4)            4           scalar                                                      
 INITIALIZE                 Subr   5632                                                                                             

Page 158         Source Listing                  INITIALIZE
2021-06-01 08:55                                 field_manager.F90

   5684 ! </FUNCTION> NAME="initialize"
   5685 !</PRIVATE>
   5686 
   5687 !#######################################################################
   5688 !#######################################################################
   5689 
   5690 ! <PRIVATE><FUNCTION NAME="make_list">
   5691 !
   5692 ! <OVERVIEW>
   5693 !    This function creates a new field and returns a pointer to that field.
   5694 ! </OVERVIEW>
   5695 ! <DESCRIPTION>
   5696 !    Allocate and initialize a new list in this_list_p list.
   5697 !    Return a pointer to the list on success, or a null pointer
   5698 !    on failure
   5699 ! </DESCRIPTION>
   5700 !   <TEMPLATE>
   5701 !     list_p => make_list(this_list_p, name)
   5702 !   </TEMPLATE>
   5703 !
   5704 function  make_list(this_list_p, name)                        &
   5705           result (list_p)  !{
   5706 !   <OUT NAME="list_p" TYPE="type (field_def), pointer">
   5707 !     A pointer to the list that has been created.
   5708 !   </OUT>
   5709 !   <IN NAME="this_list_p" TYPE="type (field_def), pointer">
   5710 !     The base of a list that the user wishes to add a list to.
   5711 !   </IN>
   5712 !   <IN NAME="name" TYPE="character(len=*)">
   5713 !     The name of a list that the user wishes to create.
   5714 !   </IN>
   5715 !
   5716 !        Function definition
   5717 !
   5718 type (field_def), pointer    :: list_p
   5719 !
   5720 !        arguments
   5721 !
   5722 type (field_def), pointer    :: this_list_p
   5723 character(len=*), intent(in) :: name
   5724 !+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   5725 !        local parameters
   5726 !+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   5727 character(len=9),  parameter :: sub_name     = 'make_list'
   5728 character(len=64), parameter :: warn_header  = '==>Warning from ' // trim(module_name) //  &
   5729                                                '(' // trim(sub_name) // '): '
   5730 !+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   5731 !        local variables
   5732 !+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   5733 integer :: ier
   5734 type (field_def), pointer, save :: dummy_p
   5735 integer                         :: out_unit
   5736 
   5737 out_unit = stdout()
   5738 !
   5739 !        Check to see whether there is already a list with
   5740 !        this name, and if so, return an error as list names

Page 159         Source Listing                  MAKE_LIST
2021-06-01 08:55                                 field_manager.F90

   5741 !        must be unique
   5742 !
   5743 dummy_p => find_field(name, this_list_p )
   5744 if (associated(dummy_p)) then  !{
   5745 !
   5746 !        This list is already specified, return an error
   5747 !
   5748   if (verb .gt. verb_level_warn) then  !{
   5749     write (out_unit,*) trim(warn_header), 'List ',                 &
   5750          trim(name), ' already exists'
   5751   endif  !}
   5752 !  nullify(list_p)
   5753   list_p => dummy_p
   5754   return
   5755 endif  !}
   5756 !
   5757 !        Create a field for the new list
   5758 !
   5759 nullify(list_p)
   5760 list_p => create_field(this_list_p, name)
   5761 if (.not. associated(list_p)) then !{
   5762   if (verb .gt. verb_level_warn) then  !{
   5763     write (out_unit,*) trim(warn_header),                          &
   5764          'Could not create field ', trim(name)
   5765   endif  !}
   5766   nullify(list_p)
   5767   return
   5768 endif  !}
   5769 !
   5770 !        Initialize the new list
   5771 !
   5772 list_p%length = 0
   5773 list_p%field_type = list_type
   5774 if (associated(list_p%i_value)) deallocate(list_p%i_value)
   5775 if (associated(list_p%l_value)) deallocate(list_p%l_value)
   5776 if (associated(list_p%r_value)) deallocate(list_p%r_value)
   5777 if (associated(list_p%s_value)) deallocate(list_p%s_value)
   5778 
   5779 end function  make_list  !}

Page 160         Source Listing                  MAKE_LIST
2021-06-01 08:55 Entry Points                    field_manager.F90



ENTRY POINTS

  Name                                       
                                             
 field_manager_mod_mp_make_list_             


SYMBOL CROSS REFERENCE

 Name                       Object Declared Type            Bytes Dimen Elements Attributes       References                        
                                                                                                                                    
 ASSOCIATED                 Func   5744                                 scalar                    5744,5761,5774,5775,5776,5777     
 DUMMY_P                    Local  5734     FIELD_DEF       400         scalar   PTR,TGT,SAVE     5743,5744,5753                    
 IER                        Local  5733     I(4)            4           scalar                                                      
 LIST_P                     Local  5718     FIELD_DEF       400         scalar   PTR              5753,5759,5760,5761,5766,5772,5773
                                                                                                  ,5774,5775,5776,5777              
 MAKE_LIST                  Func   5704     FIELD_DEF       400         scalar   PTR                                                
 NAME                       Dummy  5704     CHAR                        scalar   ARG,IN           5743,5750,5760,5764               
 OUT_UNIT                   Local  5735     I(4)            4           scalar                    5737,5749,5763                    
 SUB_NAME                   Param  5727     CHAR            9           scalar                    5729                              
 THIS_LIST_P                Dummy  5704     FIELD_DEF       400         scalar   ARG,PTR,INOUT    5743,5760                         
 TRIM                       Func   5728                                 scalar                    5728,5729,5749,5750,5763,5764     
 WARN_HEADER                Param  5728     CHAR            64          scalar                    5749,5763                         

Page 161         Source Listing                  MAKE_LIST
2021-06-01 08:55                                 field_manager.F90

   5780 ! </FUNCTION> NAME="make_list"
   5781 !</PRIVATE>
   5782 
   5783 
   5784 !#######################################################################
   5785 !#######################################################################
   5786 
   5787 ! <FUNCTION NAME="fm_query_method">
   5788 !
   5789 ! <OVERVIEW>
   5790 !    This is a function that provides the capability to return parameters
   5791 !    associated with a field in a pair of strings.
   5792 ! </OVERVIEW>
   5793 ! <DESCRIPTION>
   5794 !    Given a name return a list of method names and control strings.
   5795 !    This function should return strings similar to those in the field
   5796 !    table if a comma delimited format is being used.
   5797 ! </DESCRIPTION>
   5798 !   <TEMPLATE>
   5799 !     success = fm_query_method(name, method_name, method_control)
   5800 !   </TEMPLATE>
   5801 !
   5802 function fm_query_method(name, method_name, method_control)                &
   5803           result (success)  !{
   5804 !   <OUT NAME="success" TYPE="logical">
   5805 !     A flag to indicate whether the function operated with (FALSE) or
   5806 !     without (TRUE) errors.
   5807 !   </OUT>
   5808 !   <IN NAME="name" TYPE="character(len=*)">
   5809 !     The name of a list that the user wishes to change to.
   5810 !   </IN>
   5811 !   <OUT NAME="method_name" TYPE="character(len=*)">
   5812 !     The name of a parameter associated with the named field.
   5813 !   </OUT>
   5814 !   <OUT NAME="method_control" TYPE="character(len=*)">
   5815 !     The value of parameters associated with the named field.
   5816 !   </OUT>
   5817 !
   5818 !        Function definition
   5819 !
   5820 logical                       :: success
   5821 !
   5822 !        arguments
   5823 !
   5824 character(len=*), intent(in)  :: name
   5825 character(len=*), intent(out) :: method_name
   5826 character(len=*), intent(out) :: method_control
   5827 !+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   5828 !        local parameters
   5829 !+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   5830 character(len=15), parameter :: sub_name     = 'fm_query_method'
   5831 character(len=64), parameter :: warn_header  = '==>Warning from ' // trim(module_name) //  &
   5832                                                '(' // trim(sub_name) // '): '
   5833 !+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   5834 !        local variables
   5835 !+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   5836 character(len=fm_path_name_len) :: path

Page 162         Source Listing                  FM_QUERY_METHOD
2021-06-01 08:55                                 field_manager.F90

   5837 character(len=fm_path_name_len) :: base
   5838 character(len=fm_path_name_len) :: name_loc
   5839 logical                         :: recursive_t
   5840 type (field_def), pointer, save :: temp_list_p
   5841 type (field_def), pointer, save :: temp_value_p
   5842 type (field_def), pointer, save :: this_field_p
   5843 integer                         :: out_unit
   5844 
   5845   out_unit = stdout()
   5846   success     = .false.
   5847   recursive_t = .true.
   5848   method_name = " "
   5849   method_control = " "
   5850 !
   5851 !        Initialize the field manager if needed
   5852 !
   5853 if (.not. module_is_initialized) call initialize
   5854 name_loc = lowercase(name)
   5855 call find_base(name_loc, path, base)
   5856 
   5857   temp_list_p => find_list(name_loc, current_list_p, .false.)
   5858 
   5859 if (associated(temp_list_p)) then
   5860 ! Find the entry values for the list.
   5861   success = query_method(temp_list_p, recursive_t, base, method_name, method_control)
   5862 else  !}{
   5863 ! This is not a list but it may be a parameter with a value
   5864 ! If so put the parameter value in method_name.
   5865 
   5866   temp_value_p => find_list(path, current_list_p, .false.)
   5867   if (associated(temp_value_p)) then  !{
   5868 ! Find the entry values for this item.
   5869   this_field_p => temp_value_p%first_field
   5870 
   5871   do while (associated(this_field_p))  !{
   5872     if ( this_field_p%name == base ) then !{
   5873       method_name = this_field_p%s_value(1)
   5874       method_control = ""
   5875       success = .true.
   5876       exit
   5877     else !}{
   5878       success = .false.
   5879     endif !}
   5880     this_field_p => this_field_p%next
   5881   enddo
   5882 
   5883   else  !}{
   5884 !
   5885 !        Error following the path
   5886 !
   5887     if (verb .gt. verb_level_warn) then
   5888       write (out_unit,*) trim(warn_header), 'Could not follow path for ', trim(path)
   5889     endif
   5890     success = .false.
   5891   endif  !}
   5892 endif  !}
   5893 

Page 163         Source Listing                  FM_QUERY_METHOD
2021-06-01 08:55                                 field_manager.F90

   5894 end function  fm_query_method  !}


ENTRY POINTS

  Name                                             
                                                   
 field_manager_mod_mp_fm_query_method_             


SYMBOL CROSS REFERENCE

 Name                       Object Declared Type            Bytes Dimen Elements Attributes       References                        
                                                                                                                                    
 ASSOCIATED                 Func   5859                                 scalar                    5859,5867,5871                    
 BASE                       Local  5837     CHAR            512         scalar                    5855,5861,5872                    
 FM_QUERY_METHOD            Func   5802     L(4)            4           scalar                                                      
 METHOD_CONTROL             Dummy  5802     CHAR                        scalar   ARG,OUT          5849,5861,5874                    
 METHOD_NAME                Dummy  5802     CHAR                        scalar   ARG,OUT          5848,5861,5873                    
 NAME                       Dummy  5802     CHAR                        scalar   ARG,IN           5854                              
 NAME_LOC                   Local  5838     CHAR            512         scalar                    5854,5855,5857                    
 OUT_UNIT                   Local  5843     I(4)            4           scalar                    5845,5888                         
 PATH                       Local  5836     CHAR            512         scalar                    5855,5866,5888                    
 RECURSIVE_T                Local  5839     L(4)            4           scalar                    5847,5861                         
 SUB_NAME                   Param  5830     CHAR            15          scalar                    5832                              
 SUCCESS                    Local  5820     L(4)            4           scalar                    5846,5861,5875,5878,5890          
 TEMP_LIST_P                Local  5840     FIELD_DEF       400         scalar   PTR,SAVE         5857,5859,5861                    
 TEMP_VALUE_P               Local  5841     FIELD_DEF       400         scalar   PTR,SAVE         5866,5867,5869                    
 THIS_FIELD_P               Local  5842     FIELD_DEF       400         scalar   PTR,SAVE         5869,5871,5872,5873,5880          
 TRIM                       Func   5831                                 scalar                    5831,5832,5888                    
 WARN_HEADER                Param  5831     CHAR            64          scalar                    5888                              

Page 164         Source Listing                  FM_QUERY_METHOD
2021-06-01 08:55                                 field_manager.F90

   5895 ! </FUNCTION> NAME="fm_query_method"
   5896 
   5897 !#######################################################################
   5898 !#######################################################################
   5899 
   5900 ! <PRIVATE><FUNCTION NAME="query_method">
   5901 !
   5902 ! <OVERVIEW>
   5903 !    A private function that can recursively recover values for parameters
   5904 !    associated with a field.
   5905 ! </OVERVIEW>
   5906 ! <DESCRIPTION>
   5907 !    A private function that can recursively recover values for parameters
   5908 !    associated with a field.
   5909 ! </DESCRIPTION>
   5910 !   <TEMPLATE>
   5911 !     success = query_method(list_p, recursive, name, method_name, method_control)
   5912 !   </TEMPLATE>
   5913 !
   5914 recursive function query_method(list_p, recursive, name, method_name, method_control) &
   5915           result (success)
   5916 logical :: success
   5917 !   <OUT NAME="success" TYPE="logical">
   5918 !     A flag to indicate whether the function operated with (FALSE) or
   5919 !     without (TRUE) errors.
   5920 !   </OUT>
   5921 !   <IN NAME="list_p" TYPE="type (field_def), pointer">
   5922 !     A pointer to the field that is of interest.
   5923 !   </IN>
   5924 !   <IN NAME="name" TYPE="character(len=*)">
   5925 !     The name of a list that the user wishes to change to.
   5926 !   </IN>
   5927 !   <OUT NAME="method_name" TYPE="character(len=*)">
   5928 !     The name of a parameter associated with the named field.
   5929 !   </OUT>
   5930 !   <OUT NAME="method_control" TYPE="character(len=*)">
   5931 !     The value of parameters associated with the named field.
   5932 !   </OUT>
   5933 !
   5934 !        Function definition
   5935 !
   5936 !
   5937 !        arguments
   5938 !
   5939 type (field_def), pointer     :: list_p
   5940 logical,          intent(in)  :: recursive
   5941 character(len=*), intent(in)  :: name
   5942 character(len=*), intent(out) :: method_name, method_control
   5943 
   5944 ! local parameters
   5945 character(len=12), parameter :: sub_name     = 'query_method'
   5946 character(len=64), parameter :: warn_header  = '==>Warning from ' // trim(module_name) //  &
   5947                                                '(' // trim(sub_name) // '): '
   5948 ! local variables
   5949 integer                         :: i
   5950 character(len=64)               :: scratch
   5951 type (field_def), pointer :: this_field_p

Page 165         Source Listing                  QUERY_METHOD
2021-06-01 08:55                                 field_manager.F90

   5952 integer                         :: out_unit
   5953 
   5954 out_unit = stdout()
   5955 
   5956 !  Check for a valid list
   5957 if (.not. associated(list_p)) then
   5958   if (verb .gt. verb_level_warn) then
   5959     write (out_unit,*) trim(warn_header), 'Invalid list pointer'
   5960   endif
   5961   success = .false.
   5962 elseif (list_p%field_type .ne. list_type) then
   5963   if (verb .gt. verb_level_warn) then
   5964     write (out_unit,*) trim(warn_header), trim(list_p%name)//' is not a list'
   5965   endif
   5966   success = .false.
   5967 else
   5968 
   5969 ! set the default return value
   5970   success = .true.
   5971 
   5972   this_field_p => list_p%first_field
   5973 
   5974   do while (associated(this_field_p))
   5975     select case(this_field_p%field_type)
   5976     case(list_type)
   5977 ! If this is a list, then this is the method name
   5978       if (recursive) then
   5979         if (.not. query_method(this_field_p, .true., this_field_p%name, method_name, method_control)) then
   5980           success = .false.
   5981           exit
   5982         else
   5983           method_name = trim(method_name)//trim(this_field_p%name)
   5984 ! TODO: check length
   5985         endif
   5986       endif
   5987 
   5988     case(integer_type)
   5989         write (scratch,*) this_field_p%i_value
   5990         call concat_strings(method_control, comma//trim(this_field_p%name)//' = '//trim(adjustl(scratch)))
   5991 
   5992     case(logical_type)
   5993         write (scratch,'(l1)')this_field_p%l_value
   5994         call concat_strings(method_control, comma//trim(this_field_p%name)//' = '//trim(adjustl(scratch)))
   5995 
   5996     case(real_type)
   5997         write (scratch,*) this_field_p%r_value
   5998         call concat_strings(method_control, comma//trim(this_field_p%name)//' = '//trim(adjustl(scratch)))
   5999 
   6000     case(string_type)
   6001         call concat_strings(method_control, comma//trim(this_field_p%name)//' = '//trim(this_field_p%s_value(1)))
   6002         do i = 2, this_field_p%max_index
   6003            call concat_strings(method_control, comma//trim(this_field_p%s_value(i)))
   6004         enddo
   6005 
   6006     case default
   6007         if (verb .gt. verb_level_warn) then
   6008           write (out_unit,*) trim(warn_header), 'Undefined type for ', trim(this_field_p%name)

Page 166         Source Listing                  QUERY_METHOD
2021-06-01 08:55                                 field_manager.F90

   6009         endif
   6010         success = .false.
   6011         exit
   6012 
   6013     end select
   6014     this_field_p => this_field_p%next
   6015   enddo
   6016 endif
   6017 
   6018 end function query_method


ENTRY POINTS

  Name                                          
                                                
 field_manager_mod_mp_query_method_             


SYMBOL CROSS REFERENCE

 Name                       Object Declared Type            Bytes Dimen Elements Attributes       References                        
                                                                                                                                    
 ADJUSTL                    Func   5990                                 scalar                    5990,5994,5998                    
 ASSOCIATED                 Func   5957                                 scalar                    5957,5974                         
 I                          Local  5949     I(4)            4           scalar                    6002,6003                         
 LIST_P                     Dummy  5914     FIELD_DEF       400         scalar   ARG,PTR,INOUT    5957,5962,5964,5972               
 METHOD_CONTROL             Dummy  5914     CHAR                        scalar   ARG,OUT          5979,5990,5994,5998,6001,6003     
 METHOD_NAME                Dummy  5914     CHAR                        scalar   ARG,OUT          5979,5983                         
 NAME                       Dummy  5914     CHAR                        scalar   ARG,IN                                             
 OUT_UNIT                   Local  5952     I(4)            4           scalar                    5954,5959,5964,6008               
 QUERY_METHOD               Func   5914     L(4)            4           scalar                    5861,5979                         
 RECURSIVE                  Dummy  5914     L(4)            4           scalar   ARG,IN           5978                              
 SCRATCH                    Local  5950     CHAR            64          scalar                    5989,5990,5993,5994,5997,5998     
 SUB_NAME                   Param  5945     CHAR            12          scalar                    5947                              
 SUCCESS                    Local  5916     L(4)            4           scalar                    5961,5966,5970,5980,6010          
 THIS_FIELD_P               Local  5951     FIELD_DEF       400         scalar   PTR              5972,5974,5975,5979,5983,5989,5990
                                                                                                  ,5993,5994,5997,5998,6001,6002,600
                                                                                                  3,6008,6014                       
 TRIM                       Func   5946                                 scalar                    5946,5947,5959,5964,5983,5990,5994
                                                                                                  ,5998,6001,6003,6008              
 WARN_HEADER                Param  5946     CHAR            64          scalar                    5959,5964,6008                    

Page 167         Source Listing                  QUERY_METHOD
2021-06-01 08:55                                 field_manager.F90

   6019 
   6020 !#######################################################################
   6021 ! private function: appends str2 to the end of str1, with length check
   6022 subroutine concat_strings(str1,str2)
   6023    character(*), intent(inout) :: str1
   6024    character(*), intent(in)    :: str2
   6025 
   6026    character(64) :: n1,n2 ! for error reporting
   6027 
   6028    if (len_trim(str1)+len_trim(str2)>len(str1)) then
   6029       write(n1,*)len(str1)
   6030       write(n2,*)len_trim(str1)+len_trim(str2)
   6031       call mpp_error(FATAL,'length of output string ('//trim(adjustl(n1))&
   6032            //') is not enough for the result of concatenation (len='&
   6033            //trim(adjustl(n2))//')')
   6034    endif
   6035    str1 = trim(str1)//trim(str2)
   6036 end subroutine concat_strings


ENTRY POINTS

  Name                                            
                                                  
 field_manager_mod_mp_concat_strings_             


SYMBOL CROSS REFERENCE

 Name                       Object Declared Type            Bytes Dimen Elements Attributes       References                        
                                                                                                                                    
 ADJUSTL                    Func   6031                                 scalar                    6031,6033                         
 CONCAT_STRINGS             Subr   6022                                                           5990,5994,5998,6001,6003          
 LEN                        Func   6028                                 scalar                    6028,6029                         
 LEN_TRIM                   Func   6028                                 scalar                    6028,6030                         
 N1                         Local  6026     CHAR            64          scalar                    6029,6031                         
 N2                         Local  6026     CHAR            64          scalar                    6030,6033                         
 STR1                       Dummy  6022     CHAR                        scalar   ARG,INOUT        6028,6029,6030,6035               
 STR2                       Dummy  6022     CHAR                        scalar   ARG,IN           6028,6030,6035                    
 TRIM                       Func   6031                                 scalar                    6031,6033,6035                    

Page 168         Source Listing                  CONCAT_STRINGS
2021-06-01 08:55                                 field_manager.F90

   6037 
   6038 ! </FUNCTION> NAME="query_method"
   6039 !</PRIVATE>
   6040 
   6041 !#######################################################################
   6042 !#######################################################################
   6043 
   6044 ! <FUNCTION NAME = "fm_copy_list" >
   6045 ! <OVERVIEW>
   6046 !    A function that allows the user to copy a field and add a suffix to
   6047 !    the name of the new field.
   6048 ! </OVERVIEW>
   6049 ! <DESCRIPTION>
   6050 !    Given the name of a pre-existing field and a suffix, this function
   6051 !    will create a new field. The name of the new field will be that of
   6052 !    the old field with a suffix supplied by the user.
   6053 ! </DESCRIPTION>
   6054 !   <TEMPLATE>
   6055 !     index = fm_copy_list(list_name, suffix, create)
   6056 !   </TEMPLATE>
   6057 !
   6058 function fm_copy_list(list_name, suffix, create ) &
   6059          result(index)   !{
   6060 !   <OUT NAME="index" TYPE="integer">
   6061 !     The index of the field that has been created by the copy.
   6062 !   </OUT>
   6063 !   <IN NAME="list_name" TYPE="character(len=*)">
   6064 !     The name of a field that the user wishes to copy..
   6065 !   </IN>
   6066 !   <IN NAME="suffix" TYPE="character(len=*)">
   6067 !     The suffix that will be added to list_name when the field is copied.
   6068 !   </IN>
   6069 !
   6070 !        Function definition
   6071 !
   6072 integer        :: index
   6073 !
   6074 !        arguments
   6075 !
   6076 character(len=*), intent(in)           :: list_name
   6077 character(len=*), intent(in)           :: suffix
   6078 logical,          intent(in), optional :: create
   6079 
   6080 !+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   6081 !        local parameters
   6082 !+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   6083 character(len=12), parameter :: sub_name     = 'fm_copy_list'
   6084 character(len=64), parameter :: error_header = '==>Error from ' // trim(module_name)   //  &
   6085                                                '(' // trim(sub_name) // '): '
   6086 character(len=64), parameter :: warn_header  = '==>Warning from ' // trim(module_name) //  &
   6087                                                '(' // trim(sub_name) // '): '
   6088 !+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   6089 !        local variables
   6090 !+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   6091 character(len=fm_string_len), dimension(MAX_FIELD_METHODS) :: control
   6092 character(len=fm_string_len), dimension(MAX_FIELD_METHODS) :: method
   6093 character(len=fm_string_len)                               :: head

Page 169         Source Listing                  FM_COPY_LIST
2021-06-01 08:55                                 field_manager.F90

   6094 character(len=fm_string_len)                               :: list_name_new
   6095 character(len=fm_string_len)                               :: tail
   6096 character(len=fm_string_len)                               :: val_str
   6097 integer                                                    :: n
   6098 integer                                                    :: num_meth
   6099 integer                                                    :: val_int
   6100 logical                                                    :: found_methods
   6101 logical                                                    :: got_value
   6102 logical                                                    :: recursive_t
   6103 logical                                                    :: success
   6104 logical                                                    :: val_logical
   6105 real                                                       :: val_real
   6106 type (field_def), pointer, save                            :: temp_field_p
   6107 type (field_def), pointer, save                            :: temp_list_p
   6108 integer                                                    :: out_unit
   6109 
   6110 out_unit = stdout()
   6111 
   6112 
   6113 num_meth= 1
   6114 list_name_new = trim(list_name)//trim(suffix)
   6115 !
   6116   recursive_t = .true.
   6117 !
   6118 !        Initialize the field manager if needed
   6119 !
   6120 if (.not. module_is_initialized) then  !{
   6121   call initialize
   6122 endif  !}
   6123 
   6124 if (list_name .eq. ' ') then  !{
   6125 !
   6126 !        If list is empty, then dump the current list
   6127 !
   6128   temp_list_p => current_list_p
   6129   success = .true.
   6130 else  !}{
   6131 !
   6132 !        Get a pointer to the list
   6133 !
   6134   temp_list_p => find_list(list_name, current_list_p, .false.)
   6135   if (associated(temp_list_p)) then  !{
   6136     success = .true.
   6137   else  !}{
   6138 !
   6139 !        Error following the path
   6140 !
   6141     if (verb .gt. verb_level_warn) then
   6142       write (out_unit,*) trim(warn_header), 'Could not follow path for ', trim(list_name)
   6143     endif
   6144     success = .false.
   6145   endif  !}
   6146 endif  !}
   6147 
   6148 !
   6149 !        Find the list
   6150 !

Page 170         Source Listing                  FM_COPY_LIST
2021-06-01 08:55                                 field_manager.F90

   6151 if (success) then  !{
   6152   method(:) = ' '
   6153   control(:) = ' '
   6154   found_methods = fm_find_methods(trim(list_name), method, control)
   6155   do n = 1, MAX_FIELD_METHODS
   6156     if (LEN_TRIM(method(n)) > 0 ) then
   6157       index = fm_new_list(trim(list_name_new)//list_sep//method(n), create = create)
   6158       call find_base(method(n), head, tail)
   6159       temp_field_p => find_list(trim(list_name)//list_sep//head,temp_list_p, .false.)
   6160       temp_field_p => find_field(tail,temp_field_p)
   6161       select case (temp_field_p%field_type)
   6162         case (integer_type)
   6163           got_value = fm_get_value( trim(list_name)//list_sep//method(n), val_int)
   6164           if ( fm_new_value( trim(list_name_new)//list_sep//method(n), val_int, &
   6165                              create = create, append = .true.) < 0 ) &
   6166             call mpp_error(FATAL, trim(error_header)//'Could not set the '//trim(method(n))//&
   6167                                   ' for '//trim(list_name)//trim(suffix))
   6168 
   6169         case (logical_type)
   6170           got_value = fm_get_value( trim(list_name)//list_sep//method(n), val_logical)
   6171           if ( fm_new_value( trim(list_name_new)//list_sep//method(n), val_logical, &
   6172                              create = create, append = .true.) < 0 ) &
   6173             call mpp_error(FATAL, trim(error_header)//'Could not set the '//trim(method(n))//&
   6174                                   ' for '//trim(list_name)//trim(suffix))
   6175 
   6176         case (real_type)
   6177           got_value = fm_get_value( trim(list_name)//list_sep//method(n), val_real)
   6178           if ( fm_new_value( trim(list_name_new)//list_sep//method(n), val_real, &
   6179                              create = create, append = .true.) < 0 ) &
   6180             call mpp_error(FATAL, trim(error_header)//'Could not set the '//trim(method(n))//&
   6181                                   ' for '//trim(list_name)//trim(suffix))
   6182 
   6183         case (string_type)
   6184           got_value = fm_get_value( trim(list_name)//list_sep//method(n), val_str)
   6185           if ( fm_new_value( trim(list_name_new)//list_sep//method(n), val_str, &
   6186                              create = create, append = .true.) < 0 ) &
   6187             call mpp_error(FATAL, trim(error_header)//'Could not set the '//trim(method(n))//&
   6188                                   ' for '//trim(list_name)//trim(suffix))
   6189         case default
   6190       end select
   6191 
   6192     endif
   6193   enddo
   6194 endif  !}
   6195 
   6196 end function fm_copy_list !}

Page 171         Source Listing                  FM_COPY_LIST
2021-06-01 08:55 Entry Points                    field_manager.F90



ENTRY POINTS

  Name                                          
                                                
 field_manager_mod_mp_fm_copy_list_             


SYMBOL CROSS REFERENCE

 Name                       Object Declared Type            Bytes Dimen Elements Attributes       References                        
                                                                                                                                    
 ASSOCIATED                 Func   6135                                 scalar                    6135                              
 CONTROL                    Local  6091     CHAR            128   1     250      TGT              6153,6154                         
 CREATE                     Dummy  6058     L(4)            4           scalar   ARG,IN           6157,6165,6172,6179,6186          
 ERROR_HEADER               Param  6084     CHAR            64          scalar                    6166,6173,6180,6187               
 FM_COPY_LIST               Func   6058     I(4)            4           scalar                                                      
 FM_FIND_METHODS            Func   6154     L(4)            4           scalar                    275,6154                          
 FM_GET_VALUE               Local  6163                                 scalar                    255,6163,6170,6177,6184           
 FM_GET_VALUE_INTEGER       Func   6163     L(4)            4           scalar                    256,6163                          
 FM_GET_VALUE_LOGICAL       Func   6170     L(4)            4           scalar                    257,6170                          
 FM_GET_VALUE_REAL          Func   6177     L(4)            4           scalar                    258,6177                          
 FM_GET_VALUE_STRING        Func   6184     L(4)            4           scalar                    259,6184                          
 FOUND_METHODS              Local  6100     L(4)            4           scalar                    6154                              
 GOT_VALUE                  Local  6101     L(4)            4           scalar                    6163,6170,6177,6184               
 HEAD                       Local  6093     CHAR            128         scalar                    6158,6159                         
 INDEX                      Local  6072     I(4)            4           scalar                    6157                              
 LEN_TRIM                   Func   6156                                 scalar                    6156                              
 LIST_NAME                  Dummy  6058     CHAR                        scalar   ARG,IN           6114,6124,6134,6142,6154,6159,6163
                                                                                                  ,6167,6170,6174,6177,6181,6184,618
                                                                                                  8                                 
 LIST_NAME_NEW              Local  6094     CHAR            128         scalar                    6114,6157,6164,6171,6178,6185     
 METHOD                     Local  6092     CHAR            128   1     250      TGT              6152,6154,6156,6157,6158,6163,6164
                                                                                                  ,6166,6170,6171,6173,6177,6178,618
                                                                                                  0,6184,6185,6187                  
 N                          Local  6097     I(4)            4           scalar                    6155,6156,6157,6158,6163,6164,6166
                                                                                                  ,6170,6171,6173,6177,6178,6180,618
                                                                                                  4,6185,6187                       
 NUM_METH                   Local  6098     I(4)            4           scalar                    6113                              
 OUT_UNIT                   Local  6108     I(4)            4           scalar                    6110,6142                         
 RECURSIVE_T                Local  6102     L(4)            4           scalar                    6116                              
 SUB_NAME                   Param  6083     CHAR            12          scalar                    6085,6087                         
 SUCCESS                    Local  6103     L(4)            4           scalar                    6129,6136,6144,6151               
 SUFFIX                     Dummy  6058     CHAR                        scalar   ARG,IN           6114,6167,6174,6181,6188          
 TAIL                       Local  6095     CHAR            128         scalar                    6158,6160                         
 TEMP_FIELD_P               Local  6106     FIELD_DEF       400         scalar   PTR,SAVE         6159,6160,6161                    
 TEMP_LIST_P                Local  6107     FIELD_DEF       400         scalar   PTR,SAVE         6128,6134,6135,6159               
 TRIM                       Func   6084                                 scalar                    6084,6085,6086,6087,6114,6142,6154
                                                                                                  ,6157,6159,6163,6164,6166,6167,617
                                                                                                  0,6171,6173,6174,6177,6178,6180,61
                                                                                                  81,6184,6185,6187,6188            
 VAL_INT                    Local  6099     I(4)            4           scalar                    6163,6164                         
 VAL_LOGICAL                Local  6104     L(4)            4           scalar                    6170,6171                         
 VAL_REAL                   Local  6105     R(8)            8           scalar                    6177,6178                         
 VAL_STR                    Local  6096     CHAR            128         scalar                    6184,6185                         
 WARN_HEADER                Param  6086     CHAR            64          scalar                    6142                              

Page 172         Source Listing                  FM_COPY_LIST
2021-06-01 08:55                                 field_manager.F90

   6197 ! </FUNCTION > NAME = "fm_copy_list"
   6198 
   6199 !#######################################################################
   6200 !#######################################################################
   6201 
   6202 ! <FUNCTION NAME = "fm_find_methods" >
   6203 ! <OVERVIEW>
   6204 !    This function retrieves all the methods associated with a field.
   6205 ! </OVERVIEW>
   6206 ! <DESCRIPTION>
   6207 !    This function retrieves all the methods associated with a field.
   6208 !    This is different from fm_query_method in that this function gets all
   6209 !    the methods associated as opposed to 1 method.
   6210 ! </DESCRIPTION>
   6211 !   <TEMPLATE>
   6212 !     success = fm_find_methods(list_name, methods, control )
   6213 !   </TEMPLATE>
   6214 !
   6215 function fm_find_methods(list_name, methods, control ) &
   6216          result(success)   !{
   6217 !   <OUT NAME="success" TYPE="logical">
   6218 !     A flag to indicate whether the function operated with (FALSE) or
   6219 !     without (TRUE) errors.
   6220 !   </OUT>
   6221 !   <IN NAME="list_name" TYPE="character(len=*)">
   6222 !     The name of a list that the user wishes to find methods for.
   6223 !   </IN>
   6224 !   <OUT NAME="methods" TYPE="character(len=*)">
   6225 !     An array of the methods associated with list_name.
   6226 !   </OUT>
   6227 !   <OUT NAME="control" TYPE="character(len=*)">
   6228 !     An array of the parameters associated with methods.
   6229 !   </OUT>
   6230 !
   6231 !        Function definition
   6232 !
   6233 logical                                     :: success
   6234 !
   6235 !        arguments
   6236 !
   6237 character(len=*), intent(in)                :: list_name
   6238 character(len=*), intent(out), dimension(:) :: methods
   6239 character(len=*), intent(out), dimension(:) :: control
   6240 
   6241 !+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   6242 !        local parameters
   6243 !+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   6244 character(len=15), parameter :: sub_name     = 'fm_find_methods'
   6245 character(len=64), parameter :: warn_header  = '==>Warning from ' // trim(module_name) //  &
   6246                                                '(' // trim(sub_name) // '): '
   6247 !+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   6248 !        local variables
   6249 !+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   6250 integer                         :: num_meth
   6251 logical                         :: recursive_t
   6252 type (field_def), pointer, save :: temp_list_p
   6253 integer                         :: out_unit

Page 173         Source Listing                  FM_FIND_METHODS
2021-06-01 08:55                                 field_manager.F90

   6254 
   6255 out_unit = stdout()
   6256 num_meth= 1
   6257 !
   6258 !        Check whether to do things recursively
   6259 !
   6260   recursive_t = .true.
   6261 !  recursive_t = .false.
   6262 !
   6263 !        Initialize the field manager if needed
   6264 !
   6265 if (.not. module_is_initialized) then  !{
   6266   call initialize
   6267 endif  !}
   6268 
   6269 if (list_name .eq. ' ') then  !{
   6270 !
   6271 !        If list is empty, then dump the current list
   6272 !
   6273   temp_list_p => current_list_p
   6274   success = .true.
   6275 else  !}{
   6276 !
   6277 !        Get a pointer to the list
   6278 !
   6279   temp_list_p => find_list(list_name, current_list_p, .false.)
   6280   if (associated(temp_list_p)) then  !{
   6281     success = .true.
   6282   else  !}{
   6283 !
   6284 !        Error following the path
   6285 !
   6286     if (verb .gt. verb_level_warn) then
   6287       write (out_unit,*) trim(warn_header), 'Could not follow path for ', trim(list_name)
   6288     endif
   6289     success = .false.
   6290   endif  !}
   6291 endif  !}
   6292 
   6293 !
   6294 !        Find the list
   6295 !
   6296 if (success) then  !{
   6297   success = find_method(temp_list_p, recursive_t, num_meth, methods, control)
   6298 endif  !}
   6299 
   6300 end function fm_find_methods !}

Page 174         Source Listing                  FM_FIND_METHODS
2021-06-01 08:55 Entry Points                    field_manager.F90



ENTRY POINTS

  Name                                             
                                                   
 field_manager_mod_mp_fm_find_methods_             


SYMBOL CROSS REFERENCE

 Name                       Object Declared Type            Bytes Dimen Elements Attributes       References                        
                                                                                                                                    
 ASSOCIATED                 Func   6280                                 scalar                    6280                              
 CONTROL                    Dummy  6215     CHAR                  1     1        ARG,OUT          6297                              
 FM_FIND_METHODS            Func   6215     L(4)            4           scalar                                                      
 LIST_NAME                  Dummy  6215     CHAR                        scalar   ARG,IN           6269,6279,6287                    
 METHODS                    Dummy  6215     CHAR                  1     1        ARG,OUT          6297                              
 NUM_METH                   Local  6250     I(4)            4           scalar                    6256,6297                         
 OUT_UNIT                   Local  6253     I(4)            4           scalar                    6255,6287                         
 RECURSIVE_T                Local  6251     L(4)            4           scalar                    6260,6297                         
 SUB_NAME                   Param  6244     CHAR            15          scalar                    6246                              
 SUCCESS                    Local  6233     L(4)            4           scalar                    6274,6281,6289,6296,6297          
 TEMP_LIST_P                Local  6252     FIELD_DEF       400         scalar   PTR,SAVE         6273,6279,6280,6297               
 TRIM                       Func   6245                                 scalar                    6245,6246,6287                    
 WARN_HEADER                Param  6245     CHAR            64          scalar                    6287                              

Page 175         Source Listing                  FM_FIND_METHODS
2021-06-01 08:55                                 field_manager.F90

   6301 ! </FUNCTION > NAME = "fm_find_methods"
   6302 
   6303 !#######################################################################
   6304 !#######################################################################
   6305 
   6306 ! <PRIVATE><FUNCTION NAME = "find_method">
   6307 !
   6308 ! <OVERVIEW>
   6309 !    Given a field list pointer this function retrieves methods and
   6310 !    associated parameters for the field list.
   6311 ! </OVERVIEW>
   6312 ! <DESCRIPTION>
   6313 !    Given a field list pointer this function retrieves methods and
   6314 !    associated parameters for the field list.
   6315 ! </DESCRIPTION>
   6316 !   <TEMPLATE>
   6317 !     success = find_method(list_p, recursive, num_meth, method, control)
   6318 !   </TEMPLATE>
   6319 !
   6320 recursive function find_method(list_p, recursive, num_meth, method, control)   &
   6321           result (success)  !{
   6322 !   <OUT NAME="success" TYPE="logical">
   6323 !     A flag to indicate whether the function operated with (FALSE) or
   6324 !     without (TRUE) errors.
   6325 !   </OUT>
   6326 !   <IN NAME="list_p" TYPE="type (field_def), pointer">
   6327 !     A pointer to the field of interest
   6328 !   </IN>
   6329 !   <IN NAME="recursive" TYPE="logical">
   6330 !     If true, then recursively search for methods.
   6331 !   </IN>
   6332 !   <INOUT NAME="num_meth" TYPE="integer">
   6333 !     The number of methods found.
   6334 !   </INOUT>
   6335 !   <OUT NAME="method" TYPE="character(len=*)" DIM="(:)">
   6336 !     The methods associated with the field pointed to by list_p
   6337 !   </OUT>
   6338 !   <OUT NAME="control" TYPE="character(len=*)" DIM="(:)">
   6339 !     The control parameters for the methods found.
   6340 !   </OUT>
   6341 !
   6342 !        Function definition
   6343 !
   6344 logical                                     :: success
   6345 !
   6346 !        arguments
   6347 !
   6348 type (field_def), pointer                   :: list_p
   6349 logical,          intent(in)                :: recursive
   6350 integer,          intent(inout)             :: num_meth
   6351 character(len=*), intent(out), dimension(:) :: method
   6352 character(len=*), intent(out), dimension(:) :: control
   6353 !+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   6354 !        local parameters
   6355 !+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   6356 character(len=11), parameter :: sub_name     = 'find_method'
   6357 character(len=64), parameter :: warn_header  = '==>Warning from ' // trim(module_name) //  &

Page 176         Source Listing                  FIND_METHOD
2021-06-01 08:55                                 field_manager.F90

   6358                                                '(' // trim(sub_name) // '): '
   6359 !+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   6360 !        local variables
   6361 !+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   6362 character(len=fm_path_name_len) :: scratch
   6363 integer                         :: depthp1
   6364 integer                         :: first
   6365 integer                         :: i
   6366 integer                         :: last
   6367 integer                         :: n
   6368 type (field_def), pointer, save :: this_field_p
   6369 integer                         :: out_unit
   6370 
   6371 out_unit = stdout()
   6372 !
   6373 !        Check for a valid list
   6374 !
   6375 if (.not. associated(list_p)) then  !{
   6376   if (verb .gt. verb_level_warn) then
   6377     write (out_unit,*) trim(warn_header), 'Invalid list pointer'
   6378   endif
   6379   success = .false.
   6380 elseif (list_p%field_type .ne. list_type) then  !}{
   6381   if (verb .gt. verb_level_warn) then
   6382     write (out_unit,*) trim(warn_header), trim(list_p%name), ' is not a list'
   6383   endif
   6384   success = .false.
   6385 else  !}{
   6386 !
   6387 !        set the default return value
   6388 !
   6389   success = .true.
   6390 
   6391   this_field_p => list_p%first_field
   6392 
   6393   do while (associated(this_field_p))  !{
   6394     select case(this_field_p%field_type)
   6395     case(list_type)
   6396 !
   6397 !        If this is a list, then this is the method name
   6398 !
   6399         if ( this_field_p%length > 1) then
   6400            do n = num_meth+1, num_meth + this_field_p%length - 1
   6401               write (method(n),'(a,a,a,$)') trim(method(num_meth)), &
   6402                                             trim(this_field_p%name), list_sep
   6403            enddo
   6404            write (method(num_meth),'(a,a,a,$)') trim(method(num_meth)), &
   6405                                                 trim(this_field_p%name), list_sep
   6406         else
   6407            write (method(num_meth),'(a,a,a,$)') trim(method(num_meth)), &
   6408                                                 trim(this_field_p%name), list_sep
   6409         endif
   6410         success = find_method(this_field_p, .true., num_meth, method, control)
   6411 
   6412     case(integer_type)
   6413         write (scratch,*) this_field_p%i_value
   6414         call strip_front_blanks(scratch)

Page 177         Source Listing                  FIND_METHOD
2021-06-01 08:55                                 field_manager.F90

   6415         write (method(num_meth),'(a,a)') trim(method(num_meth)), &
   6416                 trim(this_field_p%name)
   6417         write (control(num_meth),'(a)') &
   6418                 trim(scratch)
   6419         num_meth = num_meth + 1
   6420 
   6421 
   6422     case(logical_type)
   6423 
   6424         write (method(num_meth),'(a,a)') trim(method(num_meth)), &
   6425                 trim(this_field_p%name)
   6426         write (control(num_meth),'(l1)') &
   6427                 this_field_p%l_value
   6428         num_meth = num_meth + 1
   6429 
   6430     case(real_type)
   6431 
   6432         write (scratch,*) this_field_p%r_value
   6433         call strip_front_blanks(scratch)
   6434         write (method(num_meth),'(a,a)') trim(method(num_meth)), &
   6435                 trim(this_field_p%name)
   6436         write (control(num_meth),'(a)') &
   6437                 trim(scratch)
   6438         num_meth = num_meth + 1
   6439 
   6440 
   6441     case(string_type)
   6442         write (method(num_meth),'(a,a)') trim(method(num_meth)), &
   6443                 trim(this_field_p%name)
   6444         write (control(num_meth),'(a)') &
   6445                  trim(this_field_p%s_value(1))
   6446         do i = 2, this_field_p%max_index
   6447           write (control(num_meth),'(a,a,$)') comma//trim(this_field_p%s_value(i))
   6448         enddo
   6449         num_meth = num_meth + 1
   6450 
   6451 
   6452     case default
   6453         if (verb .gt. verb_level_warn) then
   6454           write (out_unit,*) trim(warn_header), 'Undefined type for ', trim(this_field_p%name)
   6455         endif
   6456         success = .false.
   6457         exit
   6458 
   6459     end select
   6460 
   6461     this_field_p => this_field_p%next
   6462   enddo  !}
   6463 endif  !}
   6464 
   6465 end function find_method !}

Page 178         Source Listing                  FIND_METHOD
2021-06-01 08:55 Entry Points                    field_manager.F90



ENTRY POINTS

  Name                                         
                                               
 field_manager_mod_mp_find_method_             


SYMBOL CROSS REFERENCE

 Name                       Object Declared Type            Bytes Dimen Elements Attributes       References                        
                                                                                                                                    
 ASSOCIATED                 Func   6375                                 scalar                    6375,6393                         
 CONTROL                    Dummy  6320     CHAR                  1     1        ARG,OUT          6410,6417,6426,6436,6444,6447     
 DEPTHP1                    Local  6363     I(4)            4           scalar                                                      
 FIND_METHOD                Func   6320     L(4)            4           scalar                    6297,6410                         
 FIRST                      Local  6364     I(4)            4           scalar                                                      
 I                          Local  6365     I(4)            4           scalar                    6446,6447                         
 LAST                       Local  6366     I(4)            4           scalar                                                      
 LIST_P                     Dummy  6320     FIELD_DEF       400         scalar   ARG,PTR,INOUT    6375,6380,6382,6391               
 METHOD                     Dummy  6320     CHAR                  1     1        ARG,OUT          6401,6404,6407,6410,6415,6424,6434
                                                                                                  ,6442                             
 N                          Local  6367     I(4)            4           scalar                    6400,6401                         
 NUM_METH                   Dummy  6320     I(4)            4           scalar   ARG,INOUT        6400,6401,6404,6407,6410,6415,6417
                                                                                                  ,6419,6424,6426,6428,6434,6436,643
                                                                                                  8,6442,6444,6447,6449             
 OUT_UNIT                   Local  6369     I(4)            4           scalar                    6371,6377,6382,6454               
 RECURSIVE                  Dummy  6320     L(4)            4           scalar   ARG,IN                                             
 SCRATCH                    Local  6362     CHAR            512         scalar                    6413,6414,6418,6432,6433,6437     
 SUB_NAME                   Param  6356     CHAR            11          scalar                    6358                              
 SUCCESS                    Local  6344     L(4)            4           scalar                    6379,6384,6389,6410,6456          
 THIS_FIELD_P               Local  6368     FIELD_DEF       400         scalar   PTR,SAVE         6391,6393,6394,6399,6400,6402,6405
                                                                                                  ,6408,6410,6413,6416,6425,6427,643
                                                                                                  2,6435,6443,6445,6446,6447,6454,64
                                                                                                  61                                
 TRIM                       Func   6357                                 scalar                    6357,6358,6377,6382,6401,6402,6404
                                                                                                  ,6405,6407,6408,6415,6416,6418,642
                                                                                                  4,6425,6434,6435,6437,6442,6443,64
                                                                                                  45,6447,6454                      
 WARN_HEADER                Param  6357     CHAR            64          scalar                    6377,6382,6454                    

Page 179         Source Listing                  FIND_METHOD
2021-06-01 08:55                                 field_manager.F90

   6466 ! </FUNCTION > NAME = "find_method"
   6467 !</PRIVATE>
   6468 
   6469 !#######################################################################
   6470 ! <SUBROUTINE NAME="fm_set_verbosity">
   6471 !
   6472 ! <OVERVIEW>
   6473 !   A subroutine to set the verbosity of the field manager output.
   6474 ! </OVERVIEW>
   6475 ! <DESCRIPTION>
   6476 !   This subroutine will set the level of verbosity in the module.
   6477 !   Currently, verbosity is either on (1) or off (0). However,
   6478 !   in the future, "on" may have more granularity. If no argument
   6479 !   is given, then, if verbosity is on it will be turned off, and
   6480 !   is off, will be turned to the default on level.
   6481 !   If verbosity is negative then it is turned off.
   6482 !   Values greater than the maximum will be set to the maximum.
   6483 ! </DESCRIPTION>
   6484 !   <TEMPLATE>
   6485 !     call fm_set_verbosity(verbosity)
   6486 !   </TEMPLATE>
   6487 !
   6488 subroutine  fm_set_verbosity(verbosity)  !{
   6489 !   <IN NAME="verbosity" TYPE="integer, optional">
   6490 !     The level of verbosity required by the user.
   6491 !   </IN>
   6492 !
   6493 !       arguments
   6494 !
   6495 
   6496 integer, intent(in), optional :: verbosity
   6497 
   6498 !+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   6499 !       local parameters
   6500 !+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   6501 
   6502 character(len=16), parameter :: sub_name     = 'fm_set_verbosity'
   6503 character(len=64), parameter :: note_header  = '==>Note from ' // trim(module_name)    //  &
   6504                                                '(' // trim(sub_name) // '): '
   6505 !+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   6506 !        local variables
   6507 !+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   6508 integer                         :: out_unit
   6509 
   6510 out_unit = stdout()
   6511 
   6512 !
   6513 !       Check whether an argument has been given
   6514 !
   6515 
   6516 if (present(verbosity)) then  !{
   6517 
   6518   if (verbosity .le. 0) then  !{
   6519     verb = 0
   6520   elseif (verbosity .ge. max_verbosity) then  !}{
   6521     verb = max_verbosity
   6522   else  !}{

Page 180         Source Listing                  FM_SET_VERBOSITY
2021-06-01 08:55                                 field_manager.F90

   6523     verb = verbosity
   6524   endif  !}
   6525 
   6526 else  !}{
   6527 
   6528   if (verb .eq. 0) then  !{
   6529     verb = default_verbosity
   6530   else  !}{
   6531     verb = 0
   6532   endif  !}
   6533 
   6534 endif  !}
   6535 
   6536 write (out_unit,*)
   6537 write (out_unit,*) trim(note_header),                          &
   6538      'Verbosity now at level ', verb
   6539 write (out_unit,*)
   6540 
   6541 end subroutine  fm_set_verbosity  !}


ENTRY POINTS

  Name                                              
                                                    
 field_manager_mod_mp_fm_set_verbosity_             


SYMBOL CROSS REFERENCE

 Name                       Object Declared Type            Bytes Dimen Elements Attributes       References                        
                                                                                                                                    
 DEFAULT_VERBOSITY          Local  6529     I(4)            4           scalar                    581,6529                          
 FM_SET_VERBOSITY           Subr   6488                                                                                             
 MAX_VERBOSITY              Local  6520     I(4)            4           scalar                    582,6520,6521                     
 NOTE_HEADER                Param  6503     CHAR            64          scalar                    6537                              
 OUT_UNIT                   Local  6508     I(4)            4           scalar                    6510,6536,6537,6539               
 PRESENT                    Func   6516                                 scalar                    6516                              
 SUB_NAME                   Param  6502     CHAR            16          scalar                    6504                              
 TRIM                       Func   6503                                 scalar                    6503,6504,6537                    
 VERBOSITY                  Dummy  6488     I(4)            4           scalar   ARG,IN           6516,6518,6520,6523               

Page 181         Source Listing                  FM_SET_VERBOSITY
2021-06-01 08:55                                 field_manager.F90

   6542 ! </SUBROUTINE> NAME="fm_set_verbosity"
   6543 
   6544 end module field_manager_mod


SYMBOL CROSS REFERENCE

 Name                       Object Declared Type            Bytes Dimen Elements Attributes       References                        
                                                                                                                                    
 BRACKET_LEFT               Param  491      CHAR            1           scalar                                                      
 BRACKET_RIGHT              Param  492      CHAR            1           scalar                                                      
 CHAR                       Func   500                                  scalar                    500                               
 FIELD_MANAGER_END          Subr   235                                                            235                               
 FIELD_MANAGER_INIT         Subr   234                                                            234                               
 FIELD_MANAGER_MOD          Module 21                                                                                               
 FIELD_MGR_TYPE             Type   519                      96184       scalar   PRIV             524,559                           
 FIND_FIELD_INDEX_OLD       Func   454      I(4)            4           scalar                    237,1431,1435                     
 FIND_FIELD_INDEX_OLD@0     Local  1410     I(4)            4           scalar                                                      
 FMS2_IO_MOD                Module 196                                                            196                               
 FMS_MOD                    Module 194                                                            194                               
 FM_INIT_LOOP               Subr   261                                                            261                               
 FM_RESET_LOOP              Subr   270                                                            270                               
 FM_RETURN_ROOT             Subr   271                                                            271                               
 FM_SET_VERBOSITY           Subr   278                                                            278                               
 GET_FIELD_INFO             Subr   240                                                            240                               
 GET_FIELD_METHOD           Subr   242                                                            242                               
 GET_FIELD_METHODS          Subr   243                                                            243                               
 LINE_LEN                   Param  509      I(4)            4           scalar                                                      
 MPP_IO_MOD                 Module 193                                                            193                               
 MPP_MOD                    Module 184                                                            184                               
 NULL                       Func   353                                  scalar   PTR              353,434,540,545,546,547,548,549,55
                                                                                                  0,551,552,583,584,585,586         
 NUM_MODELS                 Param  314      I(4)            4           scalar                    314,342                           
 NUM_TYPES                  Param  508      I(4)            4           scalar                    567                               
 PARSE                      Local  458                                  scalar                    244                               

Page 182         Source Listing                  FM_SET_VERBOSITY
2021-06-01 08:55 Subprograms/Common Blocks       field_manager.F90



SUBPROGRAMS/COMMON BLOCKS

 Name                       Object Declared Type            Bytes Dimen Elements Attributes       References                        
                                                                                                                                    
 CHECK_FOR_NAME_DUPLICATION Subr   1046                                                           809                               
 CONCAT_STRINGS             Subr   6022                                                           5990,5994,5998,6001,6003          
 CREATE_FIELD               Func   1969     FIELD_DEF       400         scalar   PTR                                                
 DUMP_LIST                  Func   2100     L(4)            4           scalar                                                      
 FIELD_MANAGER_END          Subr   1334                                                                                             
 FIELD_MANAGER_INIT         Subr   606                                                                                              
 FIELD_MANAGER_MOD          Module 21                                                                                               
 FIND_BASE                  Subr   2265                                                                                             
 FIND_FIELD                 Func   2363     FIELD_DEF       400         scalar   PTR                                                
 FIND_FIELD_INDEX_NEW       Func   1442     I(4)            4           scalar                                                      
 FIND_FIELD_INDEX_OLD       Func   1410     I(4)            4           scalar                                                      
 FIND_HEAD                  Subr   2448                                                                                             
 FIND_LIST                  Func   2532     FIELD_DEF       400         scalar   PTR                                                
 FIND_METHOD                Func   6320     L(4)            4           scalar                    6297,6410                         
 FM_CHANGE_LIST             Func   2698     L(4)            4           scalar                                                      
 FM_CHANGE_ROOT             Func   2763     L(4)            4           scalar                                                      
 FM_COPY_LIST               Func   6058     I(4)            4           scalar                                                      
 FM_DUMP_LIST               Func   2875     L(4)            4           scalar                                                      
 FM_EXISTS                  Func   2950     L(4)            4           scalar                                                      
 FM_FIND_METHODS            Func   6215     L(4)            4           scalar                                                      
 FM_GET_CURRENT_LIST        Func   3091     CHAR            512         scalar                                                      
 FM_GET_INDEX               Func   3006     I(4)            4           scalar                                                      
 FM_GET_LENGTH              Func   3174     I(4)            4           scalar                                                      
 FM_GET_TYPE                Func   3268     CHAR            8           scalar                                                      
 FM_GET_VALUE_INTEGER       Func   3357     L(4)            4           scalar                                                      
 FM_GET_VALUE_LOGICAL       Func   3493     L(4)            4           scalar                                                      
 FM_GET_VALUE_REAL          Func   3619     L(4)            4           scalar                                                      
 FM_GET_VALUE_STRING        Func   3748     L(4)            4           scalar                                                      
 FM_INIT_LOOP               Subr   4224                                                                                             
 FM_INTERSECTION            Func   3893     FM_ARRAY_LIST_DEF                                                                       
                                                            80          scalar   PTR                                                
 FM_LOOP_OVER_LIST_NEW      Func   4242     L(4)            4           scalar   PRIV                                               
 FM_LOOP_OVER_LIST_OLD      Func   4095     L(4)            4           scalar   PRIV             4018,4039                         
 FM_MODIFY_NAME             Func   5556     L(4)            4           scalar                                                      
 FM_NEW_LIST                Func   4280     I(4)            4           scalar                                                      
 FM_NEW_VALUE_INTEGER       Func   4423     I(4)            4           scalar                                                      
 FM_NEW_VALUE_LOGICAL       Func   4677     I(4)            4           scalar                                                      
 FM_NEW_VALUE_REAL          Func   4912     I(4)            4           scalar                                                      
 FM_NEW_VALUE_STRING        Func   5147     I(4)            4           scalar                                                      
 FM_QUERY_METHOD            Func   5802     L(4)            4           scalar                                                      
 FM_RESET_LOOP              Subr   5398                                                                                             
 FM_RETURN_ROOT             Subr   5440                                                                                             
 FM_SET_VERBOSITY           Subr   6488                                                                                             
 GET_FIELD                  Func   5488     FIELD_DEF       400         scalar   PTR                                                
 GET_FIELD_INFO             Subr   1481                                                                                             
 GET_FIELD_METHOD           Subr   1541                                                                                             
 GET_FIELD_METHODS          Subr   1594                                                                                             
 INITIALIZE                 Subr   5632                                                                                             
 MAKE_LIST                  Func   5704     FIELD_DEF       400         scalar   PTR                                                
 NEW_NAME                   Subr   1082                                                           963,987                           
 PARSE_INTEGER              Func   1925     I(4)            4           scalar   PRIV                                               

Page 183         Source Listing                  FM_SET_VERBOSITY
2021-06-01 08:55 Subprograms/Common Blocks       field_manager.F90

 Name                       Object Declared Type            Bytes Dimen Elements Attributes       References                        
                                                                                                                                    
 PARSE_INTEGERS             Func   1753     I(4)            4           scalar   PRIV             1932                              
 PARSE_REAL                 Func   1911     I(4)            4           scalar   PRIV                                               
 PARSE_REALS                Func   1659     I(4)            4           scalar   PRIV             1918                              
 PARSE_STRING               Func   1939     I(4)            4           scalar   PRIV                                               
 PARSE_STRINGS              Func   1831     I(4)            4           scalar   PRIV             1946                              
 QUERY_METHOD               Func   5914     L(4)            4           scalar                    5861,5979                         
 SET_LIST_STUFF             Func   4193     L(4)            4           scalar                    4150,4157,4166                    
 STRIP_FRONT_BLANKS         Subr   1371                                                           1129,1131,1194,6414,6433          

COMPILER OPTIONS BEING USED

       -align noall                          -align nonone
       -align nocommons                      -align nodcommons
       -align noqcommons                     -align nozcommons
       -align records                        -align nosequence
       -align norec1byte                     -align norec2byte
       -align norec4byte                     -align norec8byte
       -align norec16byte                    -align norec32byte
       -align norec64byte                    -align noarray8byte
       -align noarray16byte                  -align noarray32byte
       -align noarray64byte                  -align noarray128byte
       -align noarray256byte                 -altparam
       -assume accuracy_sensitive            -assume nobscc
       -assume nobuffered_io                 -assume nobuffered_stdout
       -assume byterecl                      -assume nocontiguous_assumed_shape
       -assume nocontiguous_pointer          -assume cc_omp
       -assume nocstring                     -assume nodummy_aliases
       -assume nofpe_summary                 -assume noieee_fpe_flags
       -assume nominus0                      -assume noold_boz
       -assume old_complex_align             -assume old_unit_star
       -assume old_inquire_recl              -assume old_ldout_format
       -assume old_ldout_zero                -assume noold_logical_assign
       -assume noold_logical_ldio            -assume old_maxminloc
       -assume old_xor                       -assume noprotect_allocates
       -assume protect_constants             -assume noprotect_parens
       -assume split_common                  -assume source_include
       -assume nostd_intent_in               -assume std_minus0_rounding
       -assume nostd_mod_proc_name           -assume std_value
       -assume realloc_lhs                   -assume underscore
       -assume no2underscores                -assume norecursion
       -auto                            no   -auto_scalar
  no   -bintext                              -ccdefault default
       -check noarg_temp_created             -check noassume
       -check nobounds                       -check nocontiguous
       -check noformat                       -check nooutput_conversion
       -check nooverflow                     -check nopointers
       -check noshape                        -check nostack
       -check nouninitialized                -check noudio_iostat
       -coarray-num-procs 0             no   -coarray-config-file
       -convert native                       -cross_reference
       -D __INTEL_COMPILER=1910              -D __INTEL_COMPILER_UPDATE=0
       -D __unix__                           -D __unix
       -D __linux__                          -D __linux
       -D __gnu_linux__                      -D unix
       -D linux                              -D __ELF__

Page 184         Source Listing                  FM_SET_VERBOSITY
2021-06-01 08:55                                 field_manager.F90

       -D __x86_64                           -D __x86_64__
       -D __amd64                            -D __amd64__
       -D __INTEL_COMPILER_BUILD_DATE=20191121       -D _OPENMP=201611
       -D __INTEL_OFFLOAD                    -D __MMX__
       -D __SSE__                            -D __SSE_MATH__
       -D __SSE2__                           -D __SSE2_MATH__
       -D __pentium4                         -D __pentium4__
       -D __tune_pentium4__                  -D PACKAGE_NAME='"GFDL FMS Library"'
       -D PACKAGE_TARNAME='"FMS"'            -D PACKAGE_VERSION='"2021.02.0"'
       -D PACKAGE_STRING='"GFDL FMS Library 2021.02.0"'       -D PACKAGE_BUGREPORT='"gfdl.climate.model.info@noaa.gov"'
       -D PACKAGE_URL='"https://www.gfdl.noaa.gov/fms"'       -D PACKAGE='"FMS"'
       -D VERSION='"2021.02.0"'              -D STDC_HEADERS=1
       -D HAVE_SYS_TYPES_H=1                 -D HAVE_SYS_STAT_H=1
       -D HAVE_STDLIB_H=1                    -D HAVE_STRING_H=1
       -D HAVE_MEMORY_H=1                    -D HAVE_STRINGS_H=1
       -D HAVE_INTTYPES_H=1                  -D HAVE_STDINT_H=1
       -D HAVE_UNISTD_H=1                    -D HAVE_DLFCN_H=1
       -D LT_OBJDIR='".libs/"'               -D HAVE_MPI_H=1
       -D HAVE_NETCDF_H=1                    -D HAVE_SCHED_GETAFFINITY=1
       -D HAVE_MOD_MPI=1                     -D HAVE_MOD_NETCDF=1
       -D HAVE_CRAY_POINTER=1                -D HAVE_QUAD_PRECISION=1
       -D HAVE_INTERNAL_NML=1                -D use_netCDF=1
       -D use_libMPI=1                       -D INTERNAL_FILE_NML
       -double_size 64                  no   -d_lines
  no   -Qdyncom                              -error_limit 30
  no   -f66                             no   -f77rtl
  no   -fast                                 -fpscomp nofilesfromcmd
       -fpscomp nogeneral                    -fpscomp noioformat
       -fpscomp noldio_spacing               -fpscomp nologicals
  no   -fpconstant                           -fpe3
       -fprm nearest                         -ftz
       -fp_model noprecise                   -fp_model fast
       -fp_model nostrict                    -fp_model nosource
       -fp_model nodouble                    -fp_model noextended
       -fp_model novery_fast                 -fp_model noexcept
       -fp_model nono_except                 -fp_modbits nofp_contract
       -fp_modbits nono_fp_contract          -fp_modbits nofenv_access
       -fp_modbits nono_fenv_access          -fp_modbits nocx_limited_range
       -fp_modbits nono_cx_limited_range       -fp_modbits noprec_div
       -fp_modbits nono_prec_div             -fp_modbits noprec_sqrt
       -fp_modbits nono_prec_sqrt            -fp_modbits ftz
       -fp_modbits nono_ftz                  -fp_modbits nointrin_limited_range
       -fp_modbits nono_intrin_limited_range       -fp_modbits notrunc_compares
       -fp_modbits nono_trunc_compares       -fp_modbits noieee_nan_compares
       -fp_modbits nono_ieee_nan_compares       -fp_modbits honor_f32_conversion
       -fp_modbits nono_honor_f32_conversion       -fp_modbits honor_f64_conversion
       -fp_modbits nono_honor_f64_conversion       -fp_modbits nono_x87_copy
       -fp_modbits nono_no_x87_copy          -fp_modbits noexception_semantics
       -fp_modbits nono_exception_semantics       -fp_modbits noprecise_libm_functions
       -fp_modbits nono_precise_libm_functions       -heap_arrays 0
  no   -threadprivate_compat                 -free
       -g2                                   -iface nomixed_str_len_arg
       -iface nono_mixed_str_len_arg         -init noarrays
       -init nohuge                          -init noinfinity
       -init nominus_huge                    -init nominus_infinity
       -init nominus_tiny                    -init nonan
       -init nosnan                          -init notiny

Page 185         Source Listing                  FM_SET_VERBOSITY
2021-06-01 08:55                                 field_manager.F90

       -init nozero                     no   -intconstant
       -integer_size 32                 no   -mixed_str_len_arg
       -module ../.mods                      -names lowercase
  no   -noinclude                       no   -o
       -offload-build=host                   -openmp
       -openmp-simd                          -openmp-offload
       -O0                              no   -pad_source
       -real_size 64                    no   -recursive
       -reentrancy threaded                  -vec=simd
       -show nofullpath                      -show noinclude
       -show map                             -show options
  no   -syntax_only                     no   -threadcom
  no   -U                               no   -vms
       -w noall                              -w nonone
       -w noalignments                       -w nodeclarations
       -w noexternals                        -w nogeneral
       -w noignore_bounds                    -w noignore_loc
       -w nointerfaces                       -w noshape
       -w notruncated_source                 -w nouncalled
       -w nouninitialized                    -w nounused
       -w nousage                       no   -wrap-margins

       -includepath : /opt/netcdf/4.6.1/INTEL/include/,/opt/intel/2020/compilers_and_libraries/linux/pstl/include/,
           /opt/intel/2020/compilers_and_libraries_2020.0.166/linux/compiler/include/,.f90,./.f90,./.f90,../include/.f90,
           ./.f90,/opt/netcdf/4.6.1/INTEL/include/.f90,/opt/intel/2020/compilers_and_libraries/linux/mpi/intel64/include/.f90,
           /opt/intel/2020/compilers_and_libraries/linux/mpi/intel64/include/.f90,/opt/intel/2020/compilers_and_libraries/linux/ipp/include/.f90,
           /opt/intel/2020/compilers_and_libraries/linux/mkl/include/.f90,/opt/intel/2020/compilers_and_libraries/linux/pstl/include/.f90,
           /opt/intel/2020/compilers_and_libraries/linux/tbb/include/.f90,/opt/intel/2020/compilers_and_libraries/linux/daal/include/.f90,
           /opt/intel/2020/compilers_and_libraries_2020.0.166/linux/compiler/include/intel64/.f90,/opt/intel/2020/compilers_and_libraries_2020.0.166/linux/compiler/include/icc/.f90,
           /opt/intel/2020/compilers_and_libraries_2020.0.166/linux/compiler/include/.f90,/usr/local/include/.f90,
           /usr/lib/gcc/x86_64-redhat-linux/4.8.5/include/.f90,/usr/include/.f90,/usr/include/.f90,/usr/include/.f90
       -list filename : field_manager.lst
  no   -o

COMPILER: Intel(R) Fortran 19.1-1555
